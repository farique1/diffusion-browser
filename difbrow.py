# Diffuse Browser v2.3.
# Fred Rique (c) 2022.
# github.com/farique1/diffusion-browser
# Browse pictures and metadata generated by Stable Diffusion with Automatic1111 UI.

import os
import glob
import json
import math
import time
import shutil
import platform
import datetime
import subprocess
import collections
import configparser
import tkinter as tk
from operator import itemgetter
from tkinter.colorchooser import askcolor
from tkinter import ttk, font, filedialog
from PIL import Image, ImageTk, ImageOps, UnidentifiedImageError

# Constants
COL_NBR = 5
ROW_NBR = 5
GRID_IMG_SZ = 100
INFO_IMG_SZ = 250
BUTT_HEIGHT = 26
FONT_NAME = 'Tahoma'
FONT_SIZE = 10
FONT_WEIGHT = 'normal'
BG_COLOR = 'black'
FONT_COLOR = 'teal'
ACC_COLOR1 = 'goldenrod'
ACC_COLOR2 = 'grey70'
ALERT_COLOR = 'dark red'
TOP_PATH = 'D:/Stable Diffusion WebUI/stable-diffusion-webui/outputs/test'

FONT = [FONT_NAME, FONT_SIZE, FONT_WEIGHT]

BORDER = 1
PROGRAM_NAME = 'Diffusion\nBrowser'
ALL_PARAMETERS = 'all parameters'
SEARCH_HELP = 'enter search'
TEXT_INFO_DEFAULT = ('Diffusion Browser v2.0\n'
                     'github.com/farique1/diffusion-browser\n'
                     '(c) Fred Rique 2022\n\n'
                     'Browse pictures and metadata generated by Stable Diffusion.\n'
                     'Works with embedded PNG data from the automatic1111 repository.\n'
                     'Also works with converted files from invoke-ai and sd-webui repos '
                     'using the provided converters.')
INI_FILE = 'difbrowser.ini'
PARAMETERS_FILE = 'parameters.txt'
OS = platform.system()

with open(PARAMETERS_FILE, 'r') as file:
    TEXT_PARS = file.read().splitlines()

COMBO_VALUES = TEXT_PARS
COMBO_VALUES.insert(0, ALL_PARAMETERS)

# Variable initialization
new_pars = []
current_index = 0
current_seed = ''
current_image = ''
sort_reverse = True
time_format = '%Y-%m-%d %H:%M:%S'

# .ini file handling
local_path = os.path.split(os.path.abspath(__file__))[0]
ini_path = os.path.join(local_path, INI_FILE)
config_ini = configparser.ConfigParser()
if os.path.isfile(ini_path):
    try:
        config_ini.read(ini_path)
        config_sec = config_ini['CONFIGS']
        COL_NBR = int(config_sec.get('number_of_columns'))
        ROW_NBR = int(config_sec.get('number_of_lines'))
        GRID_IMG_SZ = int(config_sec.get('grid_image_size'))
        INFO_IMG_SZ = int(config_sec.get('preview_image_size'))
        BUTT_HEIGHT = int(config_sec.get('button_height'))
        FONT_NAME = config_sec.get('font_name')
        FONT_SIZE = int(config_sec.get('font_size'))
        FONT_WEIGHT = config_sec.get('font_weight')
        BG_COLOR = config_sec.get('background_color')
        FONT_COLOR = config_sec.get('main_color')
        ACC_COLOR1 = config_sec.get('accent_color_1')
        ACC_COLOR2 = config_sec.get('accent_color_2')
        ALERT_COLOR = config_sec.get('alert_color')
        TOP_PATH = config_sec.get('default_path')

        FONT = [FONT_NAME, FONT_SIZE, FONT_WEIGHT]
        TOP_PATH = os.path.normpath(TOP_PATH)

    except (ValueError, configparser.NoOptionError) as e:
        print(f'.INI file problem: {str(e)}')
        raise SystemExit(0)


def get_image_paths():
    '''Get images from the path'''

    files = []
    ext = ['.png', '.jpg']
    if os.path.isdir(TOP_PATH):
        for e in ext:
            file = glob.glob(os.path.normpath(TOP_PATH + '/**/*' + e), recursive=True)
            files.extend(file)

    return files


def resize_image(image, maxsize):
    '''Resize image maintaining aspect ratio and maximum size'''

    r1 = image.size[0] / maxsize[0]  # width ratio
    r2 = image.size[1] / maxsize[1]  # height ratio
    ratio = max(r1, r2)
    newsize = (int(image.size[0] / ratio), int(image.size[1] / ratio))
    image = image.resize(newsize, Image.Resampling.LANCZOS)
    return image


def on_mousewheel(event):
    '''Handles mouse wheel'''

    # Prevents mouse wheel from scrolling when outside grid
    if str(event.widget).split('.')[-1] == 'text_info' \
            or str(event.widget).split('.')[-1] == 'font_list' \
            or str(event.widget).split('.')[-1] == 'combo_box':
        return

    if OS == 'Linux':
        y_steps = 5
        if event.num == 4:
            y_steps *= -1
    elif OS == 'Darwin':
        y_steps = event.delta
    elif OS == 'Windows':
        y_steps = int(-1 * (event.delta / 120))

    canvas.yview_scroll(y_steps, 'units')


def click_grid_image(idx):
    '''Handles clicking on a image on the grid'''

    global current_seed
    global prev_button
    global current_index

    button = image_list[idx]['button']
    image = image_list[idx]['orig_image']
    embed_text = image_list[idx]['txt_info']

    blank = blank_image(ACC_COLOR1)

    image_keep = button.image
    button['image'] = blank
    prev_button.config(bg=BG_COLOR)
    button.config(bg=ACC_COLOR1)

    button.update()
    button.focus_set()

    image = resize_image(image, (INFO_IMG_SZ, INFO_IMG_SZ))
    image = ImageTk.PhotoImage(image)
    img_info['image'] = image
    img_info.image = image
    img_info.config(bg=BG_COLOR)

    # Get tag information for colorizing
    matches = []
    for i, line in enumerate(embed_text.splitlines(), 1):
        for tag in TEXT_PARS:
            tag_colon = f'{tag}:'
            if line.startswith(tag_colon):
                start = f'{str(i)}.{len(tag_colon)}'
                end = f'{str(i)}.{len(line)}'
                content = line[len(tag_colon):]
                matches.append((tag_colon, start, end, content))

    # Draw text
    text_info['state'] = 'normal'
    text_info.delete('1.0', 'end')
    text_info.insert('insert', embed_text)
    for match in matches:
        if match[0].startswith('seed:'):
            current_seed = match[3]
        color = ACC_COLOR2
        if match[3].strip().replace('.', '').isdigit() \
                or match[3].strip().replace(' x ', '').isdigit()  \
                or match[3].strip().replace(' ', '').isdigit():
            color = ACC_COLOR1
        if match[0].startswith('embedded info'):
            color = ACC_COLOR2
        text_info.tag_add(match[0], match[1], match[2])
        text_info.tag_config(match[0], foreground=color)
    text_info['state'] = 'disable'

    # Give a little time for Python to come to it's senses
    time.sleep(0.05)

    button['image'] = image_keep
    prev_button = button

    current_index = idx


def grid_keys(event, delta):
    '''Navigate grid with the arrow keys'''

    global current_index

    if (current_index + delta < 0) or (current_index + delta > len(image_list) - 1):
        return

    if image_list[current_index + delta]['button']['state'] == 'disabled':
        return

    current_index = current_index + delta
    image_amount = len(image_list)
    image_y = math.floor(current_index / COL_NBR)
    rows = math.ceil(image_amount / COL_NBR)
    button = image_list[current_index]['button']
    button_y = button.winfo_y()
    canvas_height = canvas.winfo_height()
    y_srt = canvas.yview()[0]
    y_end = canvas.yview()[1]
    y_len = y_end - y_srt
    total_height = int(canvas_height / y_len)
    canvas_y_top = int(total_height * y_srt)
    canvas_y_bot = int(total_height * y_end)
    canvas_position = image_y / rows
    img_len = 1 / rows

    # Only move if selection is outside the grid frame
    if (button_y > canvas_y_bot - GRID_IMG_SZ):
        canvas.yview_moveto(canvas_position - y_len + img_len)
    if (button_y <= canvas_y_top):
        canvas.yview_moveto(canvas_position)

    button.invoke()
    button.focus_set()


def maintain_aspect_ratio(event, original, c_full_img, aspect_ratio):
    '''Maintains aspect ratio when resizing the image window'''

    new_aspect_ratio = event.width / event.height
    if new_aspect_ratio > aspect_ratio:
        desired_width = event.width
        desired_height = int(event.width / aspect_ratio)
    else:
        desired_height = event.height
        desired_width = int(event.height * aspect_ratio)

    if event.width != desired_width or event.height != desired_height:
        try:
            event.widget.geometry(f'{desired_width}x{desired_height}')
            size = (desired_width, desired_height)
            resized = original.resize(size, Image.Resampling.LANCZOS)
            image = ImageTk.PhotoImage(resized)
            c_full_img.delete('IMG')
            c_full_img.create_image(0, 0, image=image, anchor='nw', tags='IMG')
            c_full_img.image = image
        except AttributeError:
            pass
        return 'break'


def show_full_image(idx):
    '''Handles clicking on the image preview'''

    if idx is None:
        return

    image_window = tk.Toplevel()
    image_window.title(f'{current_seed.strip()} - {image_list[idx]["file"]}')

    original = image_list[idx]['orig_image']

    # Prevent showing images bigger than the screen size
    max_width = min(original.size[0], image_window.winfo_screenwidth())
    max_height = min(original.size[1], image_window.winfo_screenheight())
    original = resize_image(original, (max_width, max_height))

    image = ImageTk.PhotoImage(original)

    x = root.winfo_x()
    y = root.winfo_y() + 30 + BUTT_HEIGHT
    dimensions = f'{image.width()}x{image.height()}+{x}+{y}'
    image_window.geometry(dimensions)

    frame = tk.Frame(image_window)
    frame.columnconfigure(0, weight=1)
    frame.rowconfigure(0, weight=1)

    c_full_img = tk.Canvas(image_window, bd=0, highlightthickness=0)
    c_full_img.create_image(0, 0, image=image, anchor='nw', tags='IMG')
    c_full_img.image = image
    c_full_img.grid(row=0, sticky='news')
    c_full_img.pack(fill='both', expand=1)

    image_window.update()
    width = image_window.winfo_width()
    height = image_window.winfo_height()
    image_window.bind('<Configure>', lambda event: maintain_aspect_ratio(event, original, c_full_img, width / height))
    image_window.bind('<Escape>', lambda event: image_window.destroy())


def show_image(idx):

    if idx is None:
        return

    path = image_list[idx]['file']

    if OS == 'Linux':
        default_app = subprocess.run(['xdg-mime', 'query', 'default', 'inode/directory'],
                                     stdout=subprocess.PIPE).stdout.decode('utf-8').strip()

        if default_app == 'org.kde.dolphin.desktop':
            subprocess.Popen(['dolphin', path])
        else:
            default_app == 'nautilus.desktop'
            subprocess.Popen(['nautilus', path])
    elif OS == 'Darwin':
        subprocess.Popen(["open", path])
    else:
        subprocess.Popen(["explorer", '/open,', path])


def new_path():
    '''Handles the new path button'''

    global TOP_PATH

    folder_selected = filedialog.askdirectory()
    if not folder_selected:
        return

    TOP_PATH = os.path.normpath(folder_selected)

    reset_interface()


def open_config():
    '''Main configuration window'''

    global config
    global conf_entries
    global conf_labels
    global bt_color_list
    global dummy

    # Create window
    config = tk.Toplevel()
    config.title('Configuration')
    config.grab_set()
    config.option_add('*font', FONT)
    config.resizable(True, True)
    x = root.winfo_x() + GRID_IMG_SZ * COL_NBR
    y = root.winfo_y() + 30 + BUTT_HEIGHT
    config.geometry(f'+{x}+{y}')
    config_frame = tk.Frame(config, bg=BG_COLOR)
    config_frame.pack(expand=True, fill='both')

    # Blank label to separate interface fro window top
    dummy = tk.Label(config_frame, text=' ', bg=BG_COLOR, fg=FONT_COLOR)
    dummy.grid(row=0)

    config_frame.grid_columnconfigure(0, weight=0)
    config_frame.grid_columnconfigure(1, weight=0)
    config_frame.grid_columnconfigure(1, weight=1)

    # Interface widgets content
    conf_cont = [['Number of columns', COL_NBR, None, None],
                 ['Number of rows', ROW_NBR, None, None],
                 ['Gird image size', GRID_IMG_SZ, None, None],
                 ['Preview image size', INFO_IMG_SZ, None, None],
                 ['Button height', BUTT_HEIGHT, None, None],
                 ['Font name', FONT[0], 'get', None, font_requester],
                 ['Font size', FONT[1], 'get', None, font_requester],
                 ['Font weight', FONT[2], 'get', None, font_requester],
                 ['Background color', BG_COLOR, 'pick', BG_COLOR, pick_color],
                 ['Main color', FONT_COLOR, 'pick', FONT_COLOR, pick_color],
                 ['Accent color 1', ACC_COLOR1, 'pick', ACC_COLOR1, pick_color],
                 ['Accent color 2', ACC_COLOR2, 'pick', ACC_COLOR2, pick_color],
                 ['Alert color', ALERT_COLOR, 'pick', ALERT_COLOR, pick_color],
                 ['Default path', TOP_PATH, 'get', None, change_config_path]]

    brd_bt_color_list = []
    bt_color_list = []
    conf_entries = []
    conf_labels = []
    for r, cont in enumerate(conf_cont, 1):
        label = tk.Label(config_frame, text=cont[0], bg=BG_COLOR, fg=FONT_COLOR)
        label.grid(row=r, column=0, sticky='e', padx=(20, 0))
        conf_labels.append(label)

        brd_bt_tbox = tk.Frame(config_frame, bg=BG_COLOR)
        brd_bt_tbox.grid(row=r, column=1, sticky='wens')
        tbox = tk.Entry(brd_bt_tbox, bg=ACC_COLOR1, fg=BG_COLOR, width=30, bd=0, name=str(r),
                        selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2)
        tbox.insert('insert', cont[1])
        tbox.pack(expand=True, fill='both', pady=1, padx=1)
        conf_entries.append(tbox)

        config_frame.rowconfigure(r, weight=1)

        if r > 8 and r < 14:
            tbox.bind('<Return>', lambda event, nbr=r: change_color(nbr))
            tbox.bind('<FocusOut>', lambda event, nbr=r: change_color(nbr))

        if (r > 0 and r < 6):
            tbox.bind('<Return>', lambda event, widget=tbox: test_int(widget))
            tbox.bind('<FocusOut>', lambda event, widget=tbox: test_int(widget))

        if cont[2]:
            brd_bt_action = tk.Frame(config_frame, bg=BG_COLOR)
            brd_bt_action.grid(row=r, column=2, sticky='wens')
            action = tk.Button(brd_bt_action, text=cont[2], bd=0,
                               bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
            action.bind('<ButtonRelease-1>', lambda event, func=cont[4], nbr=r, cur_col=cont[3]: func(nbr, cur_col))
            action.pack(expand=True, fill='both', pady=1, padx=1)

        if cont[3]:
            brd_bt_color = tk.Frame(config_frame, bg=BG_COLOR)
            brd_bt_color.grid(row=r, column=3, sticky='wens', padx=(0, 20))
            color = tk.Button(brd_bt_color, text='   ', bd=0, bg=cont[3], activebackground=cont[3])
            color.pack(expand=True, fill='both', pady=1, padx=1)
            color.bind('<ButtonRelease-1>', lambda event, func=cont[4], nbr=r, cur_col=cont[3]: func(nbr, cur_col))
            brd_bt_color_list.append(brd_bt_color)
            bt_color_list.append(color)

    brd_bt_color_list[0]['bg'] = FONT_COLOR

    # Align path text to the right
    conf_entries[13].xview_moveto(1)

    conf_entries[6].bind('<Return>', lambda e: change_button_height(conf_entries[6].get()))
    conf_entries[6].bind('<FocusOut>', lambda e: change_button_height(conf_entries[6].get()))

    conf_entries[7].bind('<Return>', lambda e: test_weight(conf_entries[7].get()))
    conf_entries[7].bind('<FocusOut>', lambda e: test_weight(conf_entries[7].get()))

    conf_entries[r - 1].bind('<Return>', lambda e, nbr=r: test_path(nbr, conf_entries[r - 1].get()))
    conf_entries[r - 1].bind('<FocusOut>', lambda e, nbr=r: test_path(nbr, conf_entries[r - 1].get()))

    btn_frame = tk.Frame(config_frame, bg=BG_COLOR)
    btn_frame.grid(row=r + 1, columnspan=4, sticky='ew', pady=(20, 20))
    btn_frame.grid_columnconfigure(0, weight=1)
    btn_frame.grid_columnconfigure(1, weight=1)

    brd_bt_btn_accept = tk.Frame(btn_frame, bg=BG_COLOR)
    brd_bt_btn_accept.grid(row=0, column=0, sticky='wens', padx=(20, 0))
    btn_accept = tk.Button(brd_bt_btn_accept, text='OK (restart)',
                           bg=FONT_COLOR, fg=BG_COLOR, bd=0, activebackground=ACC_COLOR1)
    btn_accept['command'] = lambda conf_entries=conf_entries: accept_config(btn_accept, conf_entries)
    btn_accept.pack(expand=True, fill='both', pady=1, padx=1)

    brd_btn_cancel = tk.Frame(btn_frame, bg=BG_COLOR)
    brd_btn_cancel.grid(row=0, column=1, sticky='wens', padx=(0, 20))
    btn_cancel = tk.Button(brd_btn_cancel, text='cancel', bd=0, command=config.destroy,
                           bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    btn_cancel.pack(expand=True, fill='both', pady=1, padx=1)


def test_weight(weight):
    weight = weight.strip()
    if weight != 'normal' and weight != 'bold' and weight != 'italic' and weight != '':
        conf_entries[7].config(bg=ALERT_COLOR)
    else:
        conf_entries[7].config(bg=ACC_COLOR1)


def test_int(widget):
    entry = widget.get()
    if not entry.isnumeric():
        widget.config(bg=ALERT_COLOR)
    else:
        widget.config(bg=ACC_COLOR1)


def test_path(r, path):
    '''Test the path validity'''
    if os.path.isdir(path):
        conf_entries[r - 1].config(bg=ACC_COLOR1)
    else:
        conf_entries[r - 1].config(bg=ALERT_COLOR)


def change_button_height(size):
    '''Update the button height configuration box'''

    test_int(conf_entries[6])

    if conf_entries[6]['bg'] != ALERT_COLOR:
        conf_entries[4].delete(0, 'end')
        conf_entries[4].insert('insert', int(int(size) * 2.5))


def change_config_path(r, cur_col):
    '''Get new path for the configuration'''

    # Open an inactive window to be able to disable the main interface
    dummy_window = tk.Toplevel()
    dummy_window.withdraw()
    config.grab_release()
    dummy_window.grab_set()

    folder_selected = filedialog.askdirectory()
    if folder_selected:
        conf_entries[r - 1].delete(0, 'end')
        conf_entries[r - 1].insert('insert', folder_selected)
        conf_entries[r - 1].xview_moveto(1)

    dummy_window.destroy()
    config.grab_set()


def pick_color(r, cur_col):
    '''Open a color picker'''

    # Open an inactive window to be able to disable the main interface
    dummy_window = tk.Toplevel()
    dummy_window.withdraw()
    config.grab_release()
    dummy_window.grab_set()

    conf_entries[r - 1].delete(0, 'end')
    color = askcolor(color=cur_col, title=conf_labels[r - 1]['text'])[1]

    if not color:
        color = cur_col
    conf_entries[r - 1].insert('insert', color)

    dummy_window.destroy()
    config.grab_set()

    change_color(r)


def change_color(r):
    '''Change the selected color'''

    if r < 9 or r > 13:
        return
    try:
        bt_color_list[r - 9]['bg'] = conf_entries[r - 1].get()
        conf_entries[r - 1].config(bg=ACC_COLOR1)
    except tk.TclError:
        conf_entries[r - 1].config(bg=ALERT_COLOR)


def accept_config(button, conf_entries):
    '''Close the configuration window applying changes'''

    global COL_NBR
    global ROW_NBR
    global GRID_IMG_SZ
    global INFO_IMG_SZ
    global BUTT_HEIGHT
    global FONT
    global BG_COLOR
    global FONT_COLOR
    global ACC_COLOR1
    global ACC_COLOR2
    global ALERT_COLOR
    global TOP_PATH

    change_button_height(conf_entries[6].get())

    button.focus_set()

    config.update()

    if conf_entries[0]['bg'] != ALERT_COLOR:
        COL_NBR = int(conf_entries[0].get())
    if conf_entries[1]['bg'] != ALERT_COLOR:
        ROW_NBR = int(conf_entries[1].get())
    if conf_entries[2]['bg'] != ALERT_COLOR:
        GRID_IMG_SZ = int(conf_entries[2].get())
    if conf_entries[3]['bg'] != ALERT_COLOR:
        INFO_IMG_SZ = int(conf_entries[3].get())
    if conf_entries[4]['bg'] != ALERT_COLOR:
        BUTT_HEIGHT = int(conf_entries[4].get())
    if conf_entries[6]['bg'] != ALERT_COLOR \
            and conf_entries[7]['bg'] != ALERT_COLOR:
        FONT = (conf_entries[5].get(),
                int(conf_entries[6].get()),
                conf_entries[7].get())
        BG_COLOR = bt_color_list[0]['bg']
        FONT_COLOR = bt_color_list[1]['bg']
        ACC_COLOR1 = bt_color_list[2]['bg']
        ACC_COLOR2 = bt_color_list[3]['bg']
        ALERT_COLOR = bt_color_list[4]['bg']
    if conf_entries[13]['bg'] != ALERT_COLOR:
        TOP_PATH = conf_entries[13].get()

    FONT_NAME = FONT[0]
    FONT_SIZE = FONT[1]
    FONT_WEIGHT = FONT[2]

    t_scr_width = root.winfo_screenwidth() * 0.9
    t_scr_height = root.winfo_screenheight() * 0.9

    # Check if the interface will fit on the current screen size
    if (COL_NBR * GRID_IMG_SZ + INFO_IMG_SZ) > t_scr_width \
            or (ROW_NBR * GRID_IMG_SZ) > t_scr_height \
            or INFO_IMG_SZ > t_scr_height:
        tk.messagebox.showinfo(title='Bad configuration',
                               message='Interface elements too big or too many.\n'
                                       'Will not fit within 90% of the screen.',
                               parent=config)
        return

    if not config_ini.has_section('CONFIGS'):
        config_ini.add_section('CONFIGS')
    config_ini.set('CONFIGS', 'number_of_columns', str(COL_NBR))
    config_ini.set('CONFIGS', 'number_of_lines', str(ROW_NBR))
    config_ini.set('CONFIGS', 'grid_image_size', str(GRID_IMG_SZ))
    config_ini.set('CONFIGS', 'preview_image_size', str(INFO_IMG_SZ))
    config_ini.set('CONFIGS', 'button_height', str(BUTT_HEIGHT))
    config_ini.set('CONFIGS', 'font_name', FONT_NAME)
    config_ini.set('CONFIGS', 'font_size', str(FONT_SIZE))
    config_ini.set('CONFIGS', 'font_weight', FONT_WEIGHT)
    config_ini.set('CONFIGS', 'background_color', BG_COLOR)
    config_ini.set('CONFIGS', 'main_color', FONT_COLOR)
    config_ini.set('CONFIGS', 'accent_color_1', ACC_COLOR1)
    config_ini.set('CONFIGS', 'accent_color_2', ACC_COLOR2)
    config_ini.set('CONFIGS', 'alert_color', ALERT_COLOR)
    config_ini.set('CONFIGS', 'default_path', TOP_PATH)

    with open(ini_path, 'w') as configfile:
        config_ini.write(configfile)

    config.destroy()

    reset_interface()


def font_requester(r, cur_col):
    '''Create a font requester'''

    dummy.focus_set()
    config.update()

    if conf_entries[5]['bg'] == ALERT_COLOR \
            or conf_entries[6]['bg'] == ALERT_COLOR \
            or conf_entries[7]['bg'] == ALERT_COLOR:
        return

    # global font_box
    global font_preview
    global size_entry
    global font_temp
    global font_req

    font_temp = [conf_entries[5].get(),
                 int(conf_entries[6].get()),
                 conf_entries[7].get()]

    font_req = tk.Toplevel()
    font_req.title('Font')

    available_fonts = font.families()
    available_fonts = sorted(available_fonts)

    font_box = tk.Listbox(font_req, highlightthickness=0, relief='flat', name='font_list',
                          bg=ACC_COLOR1, fg=BG_COLOR, selectbackground=FONT_COLOR)
    font_box.grid(row=0, columnspan=3, sticky='news')
    font_box.option_add('*font', FONT)

    sb = tk.Scrollbar(font_req, orient='vertical')
    sb.grid(row=0, column=3, sticky='news')

    font_box.configure(yscrollcommand=sb.set)
    sb.config(command=font_box.yview)

    config.grab_release()
    font_req.grab_set()

    for fonts in available_fonts:
        font_box.insert('end', fonts)

    # Duplicate the last element to prevent down key from overflowing the listbox items
    available_fonts.append(available_fonts[-1])

    font_box.bind("<ButtonRelease-1>", lambda e: change_font(
                  [available_fonts[font_box.curselection()[0]], int(size_entry.get()), font_temp[2]]))

    font_box.bind("<Up>", lambda e: change_font(
                  [available_fonts[font_box.curselection()[0] - 1], int(size_entry.get()), font_temp[2]]))

    font_box.bind("<Down>", lambda e: change_font(
                  [available_fonts[font_box.curselection()[0] + 1], int(size_entry.get()), font_temp[2]]))

    weight_list = []
    brd_norm_butt = tk.Frame(font_req, bg=BG_COLOR)
    brd_norm_butt.grid(row=1, column=0, sticky='nsew')
    norm_butt = tk.Button(brd_norm_butt, text="normal", bg=FONT_COLOR, fg=BG_COLOR,
                          activebackground=ACC_COLOR1, bd=0, command=lambda: font_weight(0, weight_list))
    norm_butt.pack(expand=True, fill='both', pady=1, padx=1)
    weight_list.append([norm_butt, 'normal'])

    brd_norm_bold = tk.Frame(font_req, bg=BG_COLOR)
    brd_norm_bold.grid(row=1, column=1, sticky='nsew')
    bold_butt = tk.Button(brd_norm_bold, text="bold", bg=FONT_COLOR, fg=BG_COLOR,
                          activebackground=ACC_COLOR1, bd=0, command=lambda: font_weight(1, weight_list))
    bold_butt.pack(expand=True, fill='both', pady=1, padx=1)
    weight_list.append([bold_butt, 'bold'])

    brd_norm_ital = tk.Frame(font_req, bg=BG_COLOR)
    brd_norm_ital.grid(row=1, column=2, columnspan=2, sticky='nsew')
    ital_butt = tk.Button(brd_norm_ital, text="italic", bg=FONT_COLOR, fg=BG_COLOR,
                          activebackground=ACC_COLOR1, bd=0, command=lambda: font_weight(2, weight_list))
    ital_butt.pack(expand=True, fill='both', pady=1, padx=1)
    weight_list.append([ital_butt, 'italic'])

    size_entry = tk.Entry(font_req, text="cancel", bd=0, bg=ACC_COLOR1, fg=BG_COLOR)
    size_entry.delete(0, 'end')
    size_entry.insert('insert', conf_entries[6].get())
    size_entry.bind('<Return>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
    size_entry.bind('<Tab>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
    size_entry.bind('<FocusOut>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
    size_entry.grid(row=2, column=0, columnspan=2, sticky='nsew')

    brd_siz_frm = tk.Frame(font_req, bg=BG_COLOR)
    brd_siz_frm.grid(row=2, column=2, columnspan=2, sticky='nsew')

    brd_siz_min = tk.Frame(brd_siz_frm, bg=BG_COLOR)
    brd_siz_min.grid(row=0, column=0, sticky='nsew')
    size_min = tk.Button(brd_siz_min, text="<", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                         command=lambda: siz_min_pls(-1, size_entry))
    size_min.pack(expand=True, fill='both', pady=1, padx=1)

    brd_siz_pls = tk.Frame(brd_siz_frm, bg=BG_COLOR)
    brd_siz_pls.grid(row=0, column=1, sticky='nsew')
    size_pls = tk.Button(brd_siz_pls, text=">", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                         command=lambda: siz_min_pls(1, size_entry))
    size_pls.pack(expand=True, fill='both', pady=1, padx=1)

    brd_siz_frm.columnconfigure(0, weight=1)
    brd_siz_frm.columnconfigure(1, weight=1)

    brd_ok_butt = tk.Frame(font_req, bg=BG_COLOR)
    brd_ok_butt.grid(row=3, column=0, columnspan=2, sticky='nsew')
    ok_butt = tk.Button(brd_ok_butt, text="OK", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                        activebackground=ACC_COLOR1, command=accept_font)
    ok_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_cancel_butt = tk.Frame(font_req, bg=BG_COLOR)
    brd_cancel_butt.grid(row=3, column=2, columnspan=2, sticky='nsew')
    cancel_butt = tk.Button(brd_cancel_butt, text="cancel", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                            activebackground=ACC_COLOR1, command=font_req.destroy)
    cancel_butt.pack(expand=True, fill='both', pady=1, padx=1)

    font_preview = tk.Entry(font_req, justify='center', bd=0,
                            bg=BG_COLOR, fg=FONT_COLOR, font=(FONT[0], FONT[1], FONT[2]))
    font_preview.insert('insert', 'Diffusion')
    font_preview.grid(row=4, columnspan=4, sticky='nsew')

    font_req.rowconfigure(0, weight=1)
    font_req.columnconfigure(0, weight=1)
    font_req.columnconfigure(1, weight=1)
    font_req.columnconfigure(2, weight=1)
    font_req.columnconfigure(3, weight=0)

    font_req.resizable(True, True)
    font_req.update_idletasks()
    font_req_width = int(config.winfo_width() / 2)
    font_req.geometry(f'{font_req_width}x{config.winfo_height()}+{config.winfo_x()}+{config.winfo_y()}')


def siz_min_pls(delta, entry):
    '''Buttons to change the font size'''

    size = int(entry.get())
    size += delta
    if size < 1:
        size = 1
    entry.delete(0, 'end')
    entry.insert('insert', size)

    change_font([font_temp[0], int(size), font_temp[2]])


def font_weight(weight, weight_list):
    '''Handles clicking on the font weight buttons'''

    global font_temp
    for item in weight_list:
        item[0]['bg'] = FONT_COLOR
        item[0]['fg'] = BG_COLOR

    weight_list[weight][0]['bg'] = BG_COLOR
    weight_list[weight][0]['fg'] = FONT_COLOR

    font_temp[2] = weight_list[weight][1]
    font_temp[1] = int(size_entry.get())

    change_font(font_temp)


def change_font(font_arg):
    '''Change the current font'''

    global font_temp
    font_temp = font_arg
    font_preview.config(font=font_temp)


def accept_font():
    '''Close the font requester accepting the changes'''

    conf_entries[4].delete(0, 'end')
    conf_entries[4].insert('insert', int(int(size_entry.get()) * 2.5))
    conf_entries[5].delete(0, 'end')
    conf_entries[5].insert('insert', font_temp[0])
    conf_entries[6].delete(0, 'end')
    conf_entries[6].insert('insert', size_entry.get())
    conf_entries[7].delete(0, 'end')
    conf_entries[7].insert('insert', font_temp[2])
    config.grab_set()
    font_req.destroy()


def copy_to_clipboard(event, info=''):
    '''Copy to clipboard'''
    try:
        if event:
            if event.num == 1:
                info = text_info.get('sel.first', 'sel.last')
            else:
                text_info.focus_set()
                text_info.tag_add('sel', "1.0", 'end')
                info = text_info.get('1.0', 'end')
                text_info.update()
                time.sleep(0.1)
                text_info.tag_remove('sel', "1.0", 'end')
        root.clipboard_clear()
        root.clipboard_append(info)
        root.update()
    except tk.TclError:
        return


def explore_folder(path):
    '''Open explorer on the current location'''

    if not path or path == 0:
        return

    if isinstance(path, int):
        path = image_list[path]['file']

    if OS == 'Linux':
        default_app = subprocess.run(['xdg-mime', 'query', 'default', 'inode/directory'],
                                     stdout=subprocess.PIPE).stdout.decode('utf-8').strip()

        if default_app == 'org.kde.dolphin.desktop':
            subprocess.Popen(['dolphin', '--select', path])
        else:
            default_app == 'nautilus.desktop'
            subprocess.Popen(['nautilus', '--select', path])
    elif OS == 'Darwin':
        subprocess.Popen(["open", "-R", path])
    else:
        subprocess.Popen(["explorer", '/select,', path])


def save_info(idx, ask=False):
    '''Save the image information to a text file'''

    if not idx:
        return

    embed_text = image_list[idx]['txt_info']

    orig_file = image_list[idx]['file']
    orig_file = os.path.splitext(orig_file)[0]
    orig_file = f'{orig_file}.txt'
    orig_name = os.path.basename(orig_file)

    if ask:
        orig_file = filedialog.asksaveasfile(initialfile=orig_name)
        if not orig_file:
            return
        orig_file = orig_file.name

    with open(orig_file, 'w') as f:
        f.write(embed_text)


def reset_interface():
    '''Resets the program'''

    frame_all.destroy()
    main()


def clear_info():
    '''Clear current image and text information'''

    img_info.config(bg=FONT_COLOR, text=PROGRAM_NAME, image='')
    text_info['state'] = 'normal'
    text_info.delete('1.0', 'end')
    text_info.insert('insert', TEXT_INFO_DEFAULT)
    text_info['state'] = 'disable'


def refresh_grid():
    '''Update new / deleted images files'''

    global image_list_master
    global image_list

    old_files = [image_data['file'] for image_data in image_list_master]
    new_files = get_image_paths()

    if not collections.Counter(old_files) == collections.Counter(new_files):
        apagados = list(set(old_files) - set(new_files))
        novos = list(set(new_files) - set(old_files))

        for image_data in image_list:
            image_data['button'].destroy()

        if apagados:
            image_list_temp = []
            for image_data in image_list_master:
                if image_data['file'] not in apagados:
                    image_list_temp.append(image_data)
            image_list_master = image_list_temp
            image_list = image_list_master

        if novos:
            image_list_temp = image_list_master
            image_list_master = []
            for c, file in enumerate(novos):
                item_dict = {'button': None,
                             'grid_image': None,
                             'orig_image': None,
                             'dic_info': None,
                             'txt_info': None,
                             'file': file,
                             'index': c}
                image_list_master.append(item_dict)
            image_list_master = generate_image_list('', '', master=True)
            image_list_master.extend(image_list_temp)
            image_list = image_list_master

        sort_images('created', reverse=True)

        lbl_files.config(text=f'{len(image_list_master)} images')


def blank_image(color, a=0, w=None, h=None):
    '''Create a blank image'''

    if w is None:
        w = GRID_IMG_SZ

    if h is None:
        h = GRID_IMG_SZ

    blank = Image.new(color=color, mode="RGB", size=(w, h))
    blank.putalpha(a)
    blank = ImageTk.PhotoImage(blank)

    return blank


def read_image_info(original_image, image_path):
    '''Read the images embedded information'''

    source = ''
    embed = {}
    embed_par = {}
    image_format = original_image.format.upper()

    if image_format == 'PNG':
        embed = original_image.text
        embed_raw = ''.join(str(embed))

    elif image_format == 'JPEG':
        img_exif = original_image._getexif()
        embed_raw = ''.join(str(img_exif))

        if img_exif is not None:
            embed = list(img_exif.items())[1][1]

            if not isinstance(embed, int) and not isinstance(embed, str):
                embed = [chr(d) for d in embed if d > 0]
                embed = ''.join(embed)
                embed = embed.removeprefix('UNICODE')

                if embed.startswith('Upscale:'):
                    embed = {'extras': embed}
                else:
                    embed = {'parameters': embed}

    if embed:
        if isinstance(embed, int) or isinstance(embed, str):
            embed = {}

        if 'parameters' in embed.keys():
            source = 'automatic1111'
            parameters = embed['parameters']
            prompt = parameters.partition('Steps: ')[0]
            negative_prompt = prompt.partition('Negative prompt: ')[2]
            parameters = 'Steps: ' + parameters.partition('Steps: ')[2]

            if negative_prompt:
                prompt = prompt.partition('Negative prompt: ')[0]
                embed_par['prompt'] = prompt.strip().replace('\n', ', ')
                embed_par['negative prompt'] = negative_prompt.strip().replace('\n', ', ')
            else:
                embed_par['prompt'] = prompt.strip()

            parameters = parameters.split(',')

            for par in parameters:
                par_list = par.split(':')
                title = par_list[0].strip().lower()
                content = par_list[1].strip().lower()
                embed_par[title] = content

        elif 'extras' in embed.keys():
            source = 'automatic1111 extras'
            modules = embed['extras'].split('\n')
            embed_par = {}
            for c, module in enumerate(modules):
                parameters = module.split(',')
                for par in parameters:
                    if par:
                        par_list = par.split(':')
                        title = f'{par_list[0].strip().lower()} {str(c + 1)}'
                        content = par_list[1].strip().lower()
                        embed_par[title] = content
        else:
            try:
                source = list(embed.keys())[0]
                embed_par = json.loads(embed[source])
            except (json.decoder.JSONDecodeError, IndexError):
                embed_par['embedded info'] = embed_raw
    else:
        embed_par['embedded info'] = 'no information'

    # Additional information
    real_size = original_image.size[0], original_image.size[1]

    img_format = os.path.basename(image_path)
    img_format = img_format.split('.')[-1]

    file_time = os.path.getmtime(image_path)
    file_time = datetime.datetime.fromtimestamp(file_time)
    file_time = file_time.strftime(time_format)

    embed_par[' '] = ' '
    if source:
        embed_par['source'] = source
    embed_par['real_size'] = f'{real_size[0]} x {real_size[1]}'
    embed_par['format'] = img_format
    embed_par['created'] = str(file_time)
    embed_par['path'] = image_path

    embed_list = []
    for key in TEXT_PARS:
        if key in embed_par:
            if key != ' ':
                embed_list.append(f'{key}: {embed_par[key]}\n')
            else:
                embed_list.append('\n')

    embed_txt = ''.join(embed_list)

    dif_pars = list(set(embed_par.keys()) - set(TEXT_PARS))
    for par in dif_pars:
        if par not in new_pars and par.strip() != '':
            new_pars.append(par)

    return embed_txt, embed_par


def generate_image_list(search_string, parameter_string, invert=False, master=False):

    if master:
        t = len(image_list_master)
        restart = tk.Toplevel()
        restart.title(f'Restarting')
        restart.resizable(False, False)
        restart.bind('<Escape>', lambda event: restart.destroy())
        restart_frame = tk.Frame(restart, bg=BG_COLOR)
        restart_frame.pack(expand=True, fill='both')

        load_img = tk.Label(restart_frame, bg=BG_COLOR, fg=FONT_COLOR,
                            font=(FONT[0], int(FONT[1] * 1.2), FONT[2]),
                            text='Loading images, please wait.')
        load_img.pack(pady=0, padx=50)

        loading = tk.Label(restart_frame, bg=BG_COLOR, fg=ACC_COLOR1,
                           font=(FONT[0], int(FONT[1] * 1.2), FONT[2]),
                           text=f'{0} of {t}')
        loading.pack(pady=0, padx=50)

        bar_lenght = GRID_IMG_SZ * COL_NBR / 2
        style = ttk.Style()
        style.configure('TProgressbar', relief='flat', borderwidth=0, background=FONT_COLOR, foreground=BG_COLOR)
        progress = ttk.Progressbar(restart_frame, orient='horizontal', length=bar_lenght, mode='determinate')
        progress.pack(pady=10, padx=50)

        # Update restart to get width and height
        restart.update()

        x = root.winfo_x() + int(((GRID_IMG_SZ * COL_NBR) - restart.winfo_width()) / 2)
        y = root.winfo_y() + BUTT_HEIGHT + int(((GRID_IMG_SZ * ROW_NBR) - restart.winfo_height()) / 2)
        restart.geometry(f'+{x}+{y}')

    c = 0
    image_list = []
    image_error = []
    parameter_string = parameter_string.strip()

    # start = time.time()
    for image_data in image_list_master:
        file = image_data['file']
        if master:
            try:
                original_image = Image.open(file)
            except UnidentifiedImageError:
                image_error.append(file)
                continue
            grid_image = resize_image(original_image, (GRID_IMG_SZ, GRID_IMG_SZ))
            grid_image = ImageTk.PhotoImage(grid_image)
            embed_text, embed_dict = read_image_info(original_image, file)
        else:
            grid_image = image_data['grid_image']
            original_image = image_data['orig_image']
            embed_text = image_data['txt_info']
            embed_dict = image_data['dic_info']

        embed_search = embed_text
        if parameter_string != ALL_PARAMETERS and parameter_string != '':
            embed_search = embed_dict.get(parameter_string, '')

        if invert:
            if search_string.lower() not in embed_search:
                item_dict = {'button': None,
                             'grid_image': grid_image,
                             'orig_image': original_image,
                             'txt_info': embed_text,
                             'dic_info': embed_dict,
                             'file': file,
                             'index': c}
                image_list.append(item_dict)
                c += 1
        else:
            if search_string.lower() in embed_search:
                item_dict = {'button': None,
                             'grid_image': grid_image,
                             'orig_image': original_image,
                             'txt_info': embed_text,
                             'dic_info': embed_dict,
                             'file': file,
                             'index': c}
                image_list.append(item_dict)
                c += 1

        if master:
            prog = int(c / t * 100)
            try:
                loading['text'] = f'{c} of {t}'
                progress['value'] = prog
            except tk.TclError:
                break
            progress.update()

        lbl_files.config(text=f'{c} images')

    # print(time.time() - start)

    lbl_files.config(text=f'{c} images')

    if master:
        restart.destroy()

    if image_error:
        image_error_copy = '\n'.join(image_error)
        tense = ['']
        if len(image_error) > 1:
            tense = ['s']

        copy_to_clipboard(None, image_error_copy)

        message = (f'Found {len(image_error)} image{tense[0]} with error.\n\n'
                   f'{image_error_copy}\n\n'
                   f'Path{tense[0]} copied to the clipboard.')
        res = tk.messagebox.showinfo(title='Image error.', message=message, parent=root)

    if new_pars:
        pars_copy = '\n'.join(new_pars)

        tense = ['', 'it', 'its', 'it', 'was']
        if len(new_pars) > 1:
            tense = ['s', 'them', 'their', 'they', 'were']

        message = (f'Found {len(new_pars)} new parameter{tense[0]}.\n\n'
                   f'{pars_copy}\n\n'
                   f'Add {tense[1]} to parameters.txt?\n'
                   f'({tense[3]} will be added before the space separator)\n\n'
                   f'If yes, open parameters.txt and adjust {tense[2]} order.\n\n'
                   f'If not, {tense[3]} {tense[4]} be copied to the clipboard '
                   f'and can be added manually.')

        res = tk.messagebox.askquestion(title='New parameter found.', message=message, parent=root)

        copy_to_clipboard(None, pars_copy)

        if res == 'yes':
            with open(PARAMETERS_FILE, 'r') as file:
                temp_pars = file.read().splitlines()

            pos = len(temp_pars) - 6
            temp_pars[pos:pos] = new_pars

            with open(PARAMETERS_FILE, 'w') as file:
                file.write('\n'.join(temp_pars))

    return image_list


def save_image(event, idx):

    if idx == 0:
        return

    orig_file = image_list[idx]['file']
    orig_name = os.path.basename(orig_file)
    dest_file = filedialog.asksaveasfile(initialfile=orig_name)

    if not dest_file:
        return

    dest_file = dest_file.name
    shutil.copy2(orig_file, dest_file)


def enter_search(search_string):
    '''When entering the search box'''

    if search_string == SEARCH_HELP:
        entry_search.configure(fg=BG_COLOR)
        entry_search.delete(0, 'end')
        return ''

    return search_string


def search_images(search_string, parameter_string, invert=False):
    '''Sow images matching a search string'''

    global image_list

    search_string = enter_search(search_string)
    parameter_string = parameter_string.strip()

    for image_data in image_list:
        image_data['button'].destroy()

    image_list = generate_image_list(search_string, parameter_string, invert)

    grid_buttons()

    clear_info()


def expose_images(search_string, parameter_string, invert=False):
    '''Disable non matching images'''

    search_string = enter_search(search_string)
    parameter_string = parameter_string.strip()

    for image_data in image_list:
        embed_dict = image_data['dic_info']
        embed_text = image_data['txt_info']

        if parameter_string != ALL_PARAMETERS and parameter_string != '':
            embed_text = embed_dict.get(parameter_string, '')

        image_data['button'].config(bg=BG_COLOR, state='normal')

        if invert:
            if search_string.lower() in embed_text:
                image_data['button'].config(bg=ACC_COLOR2, state='disabled')
        else:
            if search_string.lower() not in embed_text:
                image_data['button'].config(bg=ACC_COLOR2, state='disabled')


def info_overlay(parameter_string):
    '''Overlay information on grid image'''

    parameter_string = parameter_string.strip()

    for image_data in image_list:
        overlay = ''
        embed_dict = image_data['dic_info']

        if parameter_string != ALL_PARAMETERS and parameter_string != '':
            overlay = embed_dict.get(parameter_string, '')
            image = image_data['orig_image'].convert("L")
            image = resize_image(image, (GRID_IMG_SZ, GRID_IMG_SZ))
            image = ImageOps.colorize(image, black=BG_COLOR, white=FONT_COLOR)
            image = ImageTk.PhotoImage(image)
        else:
            image = image_data['grid_image']

        image_data['button'].config(image=image, text=overlay, fg=ACC_COLOR1,
                                    compound="center", wraplength=GRID_IMG_SZ,
                                    justify='left', padx=0, pady=0)
        image_data['button'].image = image
        frame_buttons.update_idletasks()


def sort_images(parameter_string, reverse=None):
    '''Sort the images'''

    global image_list
    global sort_reverse

    parameter_string = parameter_string.strip()

    if parameter_string == ALL_PARAMETERS or parameter_string == '':
        parameter_string = 'created'

    if reverse is not None:
        sort_reverse = not reverse

    for c, image_data in enumerate(image_list):

        embed_dict = image_data['dic_info']

        sort = embed_dict.get(parameter_string, '')
        if parameter_string == 'created':
            sort = datetime.datetime.strptime(sort, time_format)
        image_list[c]['index'] = sort

    # if all items are int make them all int()
    if all(str(items['index']).isdigit() or items['index'] == '' for items in image_list):
        for c, image_data in enumerate(image_list):
            image_list[c]['index'] = int(image_data['index']) if image_data['index'] != '' else 0

    sort_reverse = not sort_reverse
    image_list.sort(key=itemgetter('index'), reverse=sort_reverse)

    grid_buttons()

    clear_info()


def grid_buttons():
    '''Create grid buttons'''

    global prev_button
    global image_list

    if not image_list:
        return

    bx = by = 0
    for idx, image_data in enumerate(image_list):
        butt_image = image_data['grid_image']
        button = tk.Button(frame_buttons, width=GRID_IMG_SZ, height=GRID_IMG_SZ, borderwidth=0,
                           relief='flat', name=str(idx), image=butt_image,
                           highlightthickness=BORDER, activebackground=BG_COLOR, bg=ACC_COLOR2)

        button['command'] = lambda idx=idx: click_grid_image(idx)

        button.bind('<Left>', lambda event: grid_keys(event, -1))
        button.bind('<Right>', lambda event: grid_keys(event, 1))
        button.bind('<Up>', lambda event: grid_keys(event, -COL_NBR))
        button.bind('<Down>', lambda event: grid_keys(event, COL_NBR))

        button.bind('<Double-Button-1>', lambda event, idx=idx: show_full_image(idx))
        button.bind('<Return>', lambda event, idx=idx: show_full_image(idx))
        button.bind('<space>', lambda event, idx=idx: show_full_image(idx))

        button.bind('<Shift-Double-Button-1>', lambda event, idx=idx: show_image(idx))
        button.bind('<Shift-Return>', lambda event, idx=idx: show_image(idx))
        button.bind('<Shift-space>', lambda event, idx=idx: show_image(idx))

        button.bind("<Button-3>", lambda event, idx=idx: menu_popup(event, idx))
        button.bind("<Button-2>", lambda event, idx=idx: menu_popup(event, idx))

        button.bind('<Control-s>', lambda event: save_image(event, current_index))
        button.bind('<Control-S>', lambda event: save_image(event, current_index))

        button.bind('<Control-f>', lambda event: explore_folder(current_index))
        button.bind('<Control-F>', lambda event: explore_folder(current_index))

        button.bind('<Control-c>', lambda event=2: copy_to_clipboard(event, current_index))
        button.bind('<Control-C>', lambda event=2: copy_to_clipboard(event, current_index))

        button.bind('<Control-i>', lambda event: save_info(current_index))
        button.bind('<Control-I>', lambda event: save_info(current_index))
        button.bind('<Shift-Control-i>', lambda event: save_info(current_index, True))
        button.bind('<Shift-Control-I>', lambda event: save_info(current_index, True))

        button.grid(row=bx, column=by)
        button.image = butt_image

        # Needed to make disabled show correct bg color without affecting border at start
        button.config(bg=BG_COLOR)

        image_list[idx]['button'] = button

        by += 1
        if by % COL_NBR == 0:
            by = 0
            bx += 1

    prev_button = button

    # Update buttons frames idle tasks to let tkinter calculate buttons sizes
    frame_buttons.update_idletasks()

    # Set the canvas scrolling region
    canvas.config(scrollregion=canvas.bbox('all'))


def menu_popup(event, idx):
    '''Open popup menu and make index global'''
    global popup_index

    pop_menu.delete(0)
    filename = os.path.basename(image_list[idx]['file'])[:20] + '...'
    pop_menu.insert_cascade(0, label=filename, foreground=FONT_COLOR, background=BG_COLOR,
                            activebackground=BG_COLOR, activeforeground=ACC_COLOR1, command=lambda: menu_items(7))

    popup_index = idx
    try:
        pop_menu.tk_popup(event.x_root, event.y_root)
    finally:
        pop_menu.grab_release()


def menu_items(item):
    '''Deal with menu choices'''

    if item == 0:
        show_full_image(popup_index)

    elif item == 1:
        show_image(popup_index)

    elif item == 2:
        explore_folder(popup_index)

    elif item == 3:
        embed_txt = image_list[popup_index]['txt_info']
        copy_to_clipboard(None, embed_txt)

    elif item == 4:
        save_info(popup_index)

    elif item == 5:
        save_info(popup_index, True)

    elif item == 7:
        filename = image_list[popup_index]['file']
        copy_to_clipboard(None, filename)

    else:
        save_image(None, popup_index)


def first_run():
    '''Cold start the program'''
    global image_list
    global image_list_master
    global sort_reverse

    for image_data in image_list:
        image_data['button'].destroy()

    image_list = generate_image_list('', '', master=True)
    image_list_master = image_list

    sort_reverse = False

    sort_images('')


def main():
    '''Create the main window'''

    global canvas
    global img_info
    global text_info
    global lbl_files
    global frame_all
    global frame_buttons
    global entry_search
    global pop_menu
    global lbl_key
    global lbl_help
    global image_list
    global image_list_master
    global current_index

    current_index = 0

    # Must be here to refresh when changing config
    root.option_add('*font', FONT)

    root.bind('<Prior>', lambda event: canvas.yview_scroll(-1, 'pages'))
    root.bind('<Next>', lambda event: canvas.yview_scroll(1, 'pages'))

    root.bind('<Control-p>', lambda event: explore_folder(TOP_PATH))
    root.bind('<Control-P>', lambda event: explore_folder(TOP_PATH))

    root.bind('<Control-r>', lambda event: refresh_grid())
    root.bind('<Control-R>', lambda event: refresh_grid())

    root.bind('<Control-s>', lambda event: entry_search.focus_set())
    root.bind('<Control-S>', lambda event: entry_search.focus_set())

    root.bind('<Control-m>', lambda event: combo_params.focus_set())
    root.bind('<Control-M>', lambda event: combo_params.focus_set())

    root.bind('<Control-o>', lambda event: sort_images(combo_params.get()))
    root.bind('<Control-O>', lambda event: sort_images(combo_params.get()))
    root.bind('<Shift-Control-o>', lambda event: sort_images(''))
    root.bind('<Shift-Control-O>', lambda event: sort_images(''))

    root.bind('<Control-l>', lambda event=2: info_overlay(combo_params.get()))
    root.bind('<Control-L>', lambda event=2: info_overlay(combo_params.get()))
    root.bind('<Shift-Control-l>', lambda event=2: info_overlay(''))
    root.bind('<Shift-Control-L>', lambda event=2: info_overlay(''))

    # Frame to hold the entire interface
    frame_all = tk.Frame(root, bg=BG_COLOR)
    frame_all.pack(fill=None, expand=False)

    # Top frame for labels and buttons
    frame_top = tk.Frame(frame_all, bg=BG_COLOR, height=BUTT_HEIGHT)
    frame_top.grid(row=0, column=0, sticky='news')
    frame_top.grid_propagate(False)

    frame_top.grid_rowconfigure(0, weight=1)
    frame_top.grid_columnconfigure(0, weight=1)
    frame_top.grid_columnconfigure(1, weight=0)

    # Top left sub frame for labels
    frame_top_l = tk.Frame(frame_top, bg=BG_COLOR)
    frame_top_l.grid(row=0, column=0, sticky='ewns')

    frame_top_l.grid_rowconfigure(0, weight=1)
    frame_top_l.grid_columnconfigure(0, weight=0)
    frame_top_l.grid_columnconfigure(1, weight=1)

    # Top right sub frame for buttons
    frame_top_r = tk.Frame(frame_top, width=INFO_IMG_SZ, bg=BG_COLOR)
    frame_top_r.grid(row=0, column=1, sticky='ewns')
    frame_top_r.grid_propagate(False)

    frame_top_r.grid_rowconfigure(0, weight=1)
    frame_top_r.grid_columnconfigure(0, weight=1)
    frame_top_r.grid_columnconfigure(1, weight=2)
    frame_top_r.grid_columnconfigure(2, weight=2)
    frame_top_r.grid_columnconfigure(3, weight=2)

    # Number of files label, top left frame
    lbl_files = tk.Label(frame_top_l, bg=BG_COLOR, fg=ACC_COLOR1, text=f'images')
    lbl_files.grid(row=0, column=0, sticky='w')

    # Current path label, top left frame
    lbl_path = tk.Button(frame_top_l,
                         bg=BG_COLOR, fg=FONT_COLOR, bd=0, command=lambda: copy_to_clipboard(None, TOP_PATH),
                         activeforeground=ACC_COLOR1, activebackground=BG_COLOR,
                         text=TOP_PATH, anchor='e', justify='right')
    lbl_path.grid(row=0, column=1, sticky='w')

    # Refresh button, top right frame
    brd_bt_refr = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_refr.grid(row=0, column=0, sticky='snwe')
    butt_refr = tk.Button(brd_bt_refr, text='!', bd=0, command=refresh_grid,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_refr.pack(expand=True, fill='both', pady=1, padx=1)

    # Path button, top right frame
    brd_bt_path = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_path.grid(row=0, column=1, sticky='snwe')
    butt_path = tk.Button(brd_bt_path, text='new path', bd=0, command=new_path,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_path.pack(expand=True, fill='both', pady=1, padx=1)

    # Explorer button, top right frame
    brd_bt_open = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_open.grid(row=0, column=2, sticky='snwe')
    butt_open = tk.Button(brd_bt_open, text='show folder', bd=0, command=lambda: explore_folder(TOP_PATH),
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_open.pack(expand=True, fill='both', pady=1, padx=1)

    # Config button, top right frame
    brd_bt_conf = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_conf.grid(row=0, column=3, sticky='snwe')
    butt_conf = tk.Button(brd_bt_conf, text='config', bd=0, command=open_config,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_conf.pack(expand=True, fill='both', pady=1, padx=1)

    # Frame for the grid and info
    frame_main = tk.Frame(frame_all, bg=BG_COLOR)
    frame_main.grid(sticky='news')
    frame_main.grid(row=1, column=0, sticky='nw')

    # Frame for the info
    frame_info_height = GRID_IMG_SZ * ROW_NBR + (BORDER * 2 * ROW_NBR)
    info_frame = tk.Frame(frame_main, bg=BG_COLOR, width=INFO_IMG_SZ, height=frame_info_height)
    info_frame.grid(row=0, column=1, sticky='nw')

    # Button to show the selected image
    img_info = tk.Button(info_frame, bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1,
                         font=(FONT[0], FONT[1] * 3, 'bold'), borderwidth=0, text=PROGRAM_NAME)
    img_info.bind('<Button-1>', lambda event: show_full_image(current_index))
    img_info.bind('<Button-2>', lambda event: show_image(current_index))
    img_info.bind('<Button-3>', lambda event: show_image(current_index))
    img_info.bind('<Shift-Button-1>', lambda event: show_image(current_index))
    img_info.place(x=0, y=0, height=INFO_IMG_SZ, width=INFO_IMG_SZ)

    # Text box to show the selected image info
    text_info_height = GRID_IMG_SZ * ROW_NBR - INFO_IMG_SZ + (BORDER * 2 * ROW_NBR)
    text_info = tk.Text(info_frame, name='text_info',
                        bg=BG_COLOR, fg=FONT_COLOR,
                        selectbackground=FONT_COLOR, selectforeground=BG_COLOR,
                        borderwidth=0, padx=10, pady=10)
    text_info.bind('<ButtonRelease-1>', lambda event: copy_to_clipboard(event))
    text_info.bind('<ButtonRelease-2>', lambda event: copy_to_clipboard(event))
    text_info.bind('<ButtonRelease-3>', lambda event: copy_to_clipboard(event))

    text_info.insert('insert', TEXT_INFO_DEFAULT)
    text_info.place(x=0, y=INFO_IMG_SZ, height=text_info_height, width=INFO_IMG_SZ)
    text_info['state'] = 'disable'

    # Frame for the image grid
    frame_canvas = tk.Frame(frame_main, bg=BG_COLOR)
    frame_canvas.grid(row=0, column=0, sticky='nw')
    frame_canvas.grid_rowconfigure(0, weight=1)
    frame_canvas.grid_columnconfigure(0, weight=1)
    frame_canvas.grid_propagate(False)

    # Add a canvas in that frame
    canvas = tk.Canvas(frame_canvas, bg=BG_COLOR, borderwidth=0, highlightthickness=0)
    canvas.bind_all('<MouseWheel>', on_mousewheel)
    canvas.bind_all("<Button-4>", on_mousewheel)
    canvas.bind_all("<Button-5>", on_mousewheel)

    canvas.grid(row=0, column=0, sticky='news')

    # Create a frame to contain the buttons
    frame_buttons = tk.Frame(canvas, bg=BG_COLOR)
    canvas.create_window((0, 0), window=frame_buttons, anchor='nw')

    # Link a scrollbar to the canvas
    vsb = tk.Scrollbar(frame_canvas, orient='vertical', command=canvas.yview)
    vsb.grid(row=0, column=1, sticky='ns')
    canvas.configure(yscrollcommand=vsb.set)

    # Get image file names
    files = get_image_paths()
    image_list_master = []
    for file in files:
        item_dict = {'button': None,
                     'grid_image': None,
                     'orig_image': None,
                     'dic_info': None,
                     'txt_info': None,
                     'file': file,
                     'index': None}
        image_list_master.append(item_dict)
    image_list = image_list_master

    # Make the buttons
    grid_buttons()

    # Resize the canvas and frame
    grid_width = (COL_NBR * GRID_IMG_SZ + (BORDER * 2 * COL_NBR)) + vsb.winfo_width()
    grid_height = ROW_NBR * GRID_IMG_SZ + (BORDER * 2 * ROW_NBR)
    frame_canvas.config(width=grid_width, height=grid_height)

    # Frame for the search and info panel bottom
    bottom_frame = tk.Frame(frame_all, bg=BG_COLOR, height=BUTT_HEIGHT)
    bottom_frame.grid(row=2, column=0, sticky='news')

    # Frame for the search
    search_frame = tk.Frame(bottom_frame, bg=BG_COLOR)
    search_frame.place(x=0, height=BUTT_HEIGHT, width=grid_width)

    # Button to expose
    brd_bt_expose = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_expose.grid(row=0, column=0, sticky='news')
    butt_expose = tk.Button(brd_bt_expose, text='expose', bd=0,
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_expose.bind('<Return>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<space>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<Button-1>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<Control-Return>', lambda event: expose_images(entry_search.get(), combo_params.get(), invert=True))
    butt_expose.bind('<Control-space>', lambda event: expose_images(entry_search.get(), combo_params.get(), invert=True))
    butt_expose.bind('<Control-Button-1>', lambda event: expose_images(entry_search.get(), combo_params.get(), invert=True))
    butt_expose.bind('<Button-2>', lambda event: expose_images('', ''))
    butt_expose.bind('<Button-3>', lambda event: expose_images('', ''))
    butt_expose.bind('<Shift-Button-1>', lambda event: expose_images('', ''))
    butt_expose.bind('<Shift-Return>', lambda event: expose_images('', ''))
    butt_expose.bind('<Shift-space>', lambda event: expose_images('', ''))
    butt_expose.pack(expand=True, fill='both', pady=1, padx=1)

    # Button to search
    brd_bt_search = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_search.grid(row=0, column=1, sticky='news')
    butt_search = tk.Button(brd_bt_search, text='search', bd=0,
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_search.bind('<Return>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<space>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<Button-1>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<Control-Return>', lambda event: search_images(entry_search.get(), combo_params.get(), invert=True))
    butt_search.bind('<Control-space>', lambda event: search_images(entry_search.get(), combo_params.get(), invert=True))
    butt_search.bind('<Control-Button-1>', lambda event: search_images(entry_search.get(), combo_params.get(), invert=True))
    butt_search.bind('<Button-2>', lambda event: search_images('', ''))
    butt_search.bind('<Button-3>', lambda event: search_images('', ''))
    butt_search.bind('<Shift-Button-1>', lambda event: search_images('', ''))
    butt_search.bind('<Shift-Return>', lambda event: search_images('', ''))
    butt_search.bind('<Shift-space>', lambda event: search_images('', ''))
    butt_search.pack(expand=True, fill='both', pady=1, padx=1)

    # Search entry box
    brd_ent_search = tk.Frame(search_frame, bg=BG_COLOR)
    brd_ent_search.grid(row=0, column=2, sticky='nwes')
    entry_search = tk.Entry(brd_ent_search, bg=ACC_COLOR1, fg=FONT_COLOR, bd=0, name='entry_search',
                            selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2)
    entry_search.insert('insert', SEARCH_HELP)
    entry_search.bind('<FocusIn>', lambda event: enter_search(entry_search.get()))
    entry_search.bind('<Return>', lambda event: search_images(entry_search.get(), combo_params.get()))
    entry_search.bind('<Shift-Return>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    entry_search.bind('<Control-Return>', lambda event: search_images('', ''))
    entry_search.bind('<Control-Shift-Return>', lambda event: expose_images('', ''))
    entry_search.pack(expand=True, fill='both', pady=1, padx=1)

    # Search parameters
    brd_cb_param = tk.Frame(search_frame, bg=BG_COLOR)
    brd_cb_param.grid(row=0, column=3, sticky='snew')
    combo_params = ttk.Combobox(brd_cb_param, values=TEXT_PARS, name='combo_box', width=10)
    combo_params.current(0)
    combo_params.pack(expand=True, fill='both', pady=1, padx=1)
    combo_params.bind("<<ComboboxSelected>>", lambda event: combo_params.selection_clear())
    style = ttk.Style()
    style.theme_use('default')
    style.configure('TCombobox', relief='flat', background=FONT_COLOR, foreground=BG_COLOR,
                    fieldbackground=ACC_COLOR1, selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2)
    root.option_add('*TCombobox*Listbox*Background', FONT_COLOR)
    root.option_add('*TCombobox*Listbox*Foreground', BG_COLOR)
    root.option_add('*TCombobox*Listbox*selectBackground', ACC_COLOR1)
    root.option_add('*TCombobox*Listbox*selectForeground', BG_COLOR)

    # Button to sort
    brd_bt_sort = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_sort.grid(row=0, column=4, sticky='news')
    butt_sort = tk.Button(brd_bt_sort, text='sort', bd=0,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_sort.bind('<Return>', lambda event: sort_images(combo_params.get()))
    butt_sort.bind('<space>', lambda event: sort_images(combo_params.get()))
    butt_sort.bind('<Button-1>', lambda event: sort_images(combo_params.get()))
    butt_sort.bind('<Button-2>', lambda event: sort_images(''))
    butt_sort.bind('<Button-3>', lambda event: sort_images(''))
    butt_sort.bind('<Shift-Return>', lambda event: sort_images(''))
    butt_sort.bind('<Shift-space>', lambda event: sort_images(''))
    butt_sort.bind('<Shift-Button-1>', lambda event: sort_images(''))
    butt_sort.pack(expand=True, fill='both', pady=1, padx=1)

    # Button to show overlay
    brd_bt_overlay = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_overlay.grid(row=0, column=5, sticky='news')
    butt_overlay = tk.Button(brd_bt_overlay, text='overlay', bd=0,
                             bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_overlay.bind('<Return>', lambda event: info_overlay(combo_params.get()))
    butt_overlay.bind('<space>', lambda event: info_overlay(combo_params.get()))
    butt_overlay.bind('<Button-1>', lambda event: info_overlay(combo_params.get()))
    butt_overlay.bind('<Button-2>', lambda event: info_overlay(''))
    butt_overlay.bind('<Button-3>', lambda event: info_overlay(''))
    butt_overlay.bind('<Shift-Return>', lambda event: info_overlay(''))
    butt_overlay.bind('<Shift-space>', lambda event: info_overlay(''))
    butt_overlay.bind('<Shift-Button-1>', lambda event: info_overlay(''))
    butt_overlay.pack(expand=True, fill='both', pady=1, padx=1)

    search_frame.grid_rowconfigure(0, weight=1)
    search_frame.grid_columnconfigure(0, weight=0)
    search_frame.grid_columnconfigure(1, weight=0)
    search_frame.grid_columnconfigure(2, weight=2)
    search_frame.grid_columnconfigure(3, weight=1)
    search_frame.grid_columnconfigure(4, weight=0)
    search_frame.grid_columnconfigure(5, weight=0)

    # Frame for the info panel bottom
    info_panel_x = grid_width
    info_panel_frame = tk.Frame(bottom_frame, bg=BG_COLOR)
    info_panel_frame.place(x=info_panel_x, height=BUTT_HEIGHT, width=INFO_IMG_SZ)

    # Button to open folder containing image
    brd_bt_folder = tk.Frame(info_panel_frame, bg=BG_COLOR)
    brd_bt_folder.grid(row=0, column=0, sticky='news')
    butt_folder = tk.Button(brd_bt_folder, text='show in folder', bd=0,
                            command=lambda: explore_folder(current_index),
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_folder.pack(expand=True, fill='both', pady=1, padx=1)

    # Button to save information
    brd_bt_save_info = tk.Frame(info_panel_frame, bg=BG_COLOR)
    brd_bt_save_info.grid(row=0, column=1, sticky='news')
    butt_save_info = tk.Button(brd_bt_save_info, text='save info', bd=0,
                               bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_save_info.pack(expand=True, fill='both', pady=1, padx=1)
    butt_save_info.bind('<Return>', lambda event: save_info(current_index))
    butt_save_info.bind('<space>', lambda event: save_info(current_index))
    butt_save_info.bind('<Button-1>', lambda event: save_info(current_index))
    butt_save_info.bind('<Button-2>', lambda event: save_info(current_index, True))
    butt_save_info.bind('<Button-3>', lambda event: save_info(current_index, True))
    butt_save_info.bind('<Shift-Return>', lambda event: save_info(current_index, True))
    butt_save_info.bind('<Shift-space>', lambda event: save_info(current_index, True))
    butt_save_info.bind('<Shift-Button-1>', lambda event: save_info(current_index, True))

    info_panel_frame.grid_rowconfigure(0, weight=1)
    info_panel_frame.grid_columnconfigure(0, weight=1)
    info_panel_frame.grid_columnconfigure(1, weight=1)

    # Popup menu
    pop_menu = tk.Menu(root, tearoff=0, relief='flat', bg=FONT_COLOR,
                       activebackground=ACC_COLOR1, activeforeground=BG_COLOR, disabledforeground=FONT_COLOR,
                       borderwidth=0, activeborderwidth=0)
    # pop_menu.add_separator()
    pop_menu.add_separator()
    pop_menu.add_command(label='open image internal', foreground=BG_COLOR, command=lambda: menu_items(0))
    pop_menu.add_command(label='open image in system', foreground=BG_COLOR, command=lambda: menu_items(1))
    pop_menu.add_command(label='show image in folder', foreground=BG_COLOR, command=lambda: menu_items(2))
    pop_menu.add_command(label='copy image to folder', foreground=BG_COLOR, command=lambda: menu_items(6))
    pop_menu.add_command(label='save info', foreground=BG_COLOR, command=lambda: menu_items(4))
    pop_menu.add_command(label='save info as', foreground=BG_COLOR, command=lambda: menu_items(5))
    pop_menu.add_command(label='copy info to clipboard', foreground=BG_COLOR, command=lambda: menu_items(3))

    # Adjustments for MacOS
    lbl_path.config(highlightbackground=BG_COLOR)
    butt_path.config(highlightbackground=BG_COLOR)
    butt_refr.config(highlightbackground=BG_COLOR)
    butt_open.config(highlightbackground=BG_COLOR)
    butt_conf.config(highlightbackground=BG_COLOR)
    butt_folder.config(highlightbackground=BG_COLOR)
    butt_save_info.config(highlightbackground=BG_COLOR)
    butt_search.config(highlightbackground=BG_COLOR)
    butt_expose.config(highlightbackground=BG_COLOR)
    text_info.config(highlightbackground=BG_COLOR)
    entry_search.config(highlightbackground=BG_COLOR)

    # Launch the GUI
    root.after(50, lambda: first_run())
    root.mainloop()


root = tk.Tk()
root.configure(background='black')
root.title('Diffusion Browser')
root.bind_class("Button", "<Key-Return>", lambda event: event.widget.invoke())

if OS == 'Linux':
    root.resizable(True, True)
else:
    root.resizable(False, False)

main()
