# Diffuse Browser v2.2.
# Fred Rique (c) 2022.
# github.com/farique1/diffusion-browser
# Browse pictures and metadata generated by Stable Diffusion with Automatic1111 UI.

import os
import glob
import json
import math
import time
import shutil
import platform
import datetime
import subprocess
import collections
import configparser
import tkinter as tk
from tkinter import ttk
from tkinter import font
from tkinter import filedialog
from tkinter.colorchooser import askcolor
from PIL import Image, ImageTk, UnidentifiedImageError

# Constants
COL_NBR = 5
ROW_NBR = 5
GRID_IMG_SZ = 100
INFO_IMG_SZ = 250
BUTT_HEIGHT = 26
FONT_NAME = 'Tahoma'
FONT_SIZE = 10
FONT_WEIGHT = 'normal'
BG_COLOR = 'black'
FONT_COLOR = 'teal'
ACC_COLOR1 = 'goldenrod'
ACC_COLOR2 = 'grey70'
ALERT_COLOR = 'dark red'
TOP_PATH = 'D:/Stable Diffusion WebUI/stable-diffusion-webui/outputs/'

FONT = [FONT_NAME, FONT_SIZE, FONT_WEIGHT]

BORDER = 1
PROGRAM_NAME = 'Diffusion\nBrowser'
SEARCH_HELP = 'enter search/expose | SHIFT+button = clear | parameter narrows search ->'
TEXT_INFO_DEFAULT = ('Diffusion Browser v2.0\n'
                     'github.com/farique1/diffusion-browser\n'
                     '(c) Fred Rique 2022\n\n'
                     'Browse pictures and metadata generated by Stable Diffusion.\n'
                     'Works with embedded PNG data from the automatic1111 repository.\n'
                     'Also works with converted files from invoke-ai and sd-webui repos '
                     'using the provided converters.')
OS = platform.system()

with open('parameters.txt', 'r') as file:
    TEXT_PARS = file.read().splitlines()

COMBO_VALUES = TEXT_PARS
COMBO_VALUES.insert(0, 'all parameters')

# Variable initialization
new_pars = []
current_seed = ''
current_image = ''
image_filepath = ''

# .ini file handling
local_path = os.path.split(os.path.abspath(__file__))[0]
ini_path = os.path.join(local_path, 'difbrowser.ini')
config_ini = configparser.ConfigParser()
if os.path.isfile(ini_path):
    try:
        config_ini.read(ini_path)
        config_sec = config_ini['CONFIGS']
        COL_NBR = int(config_sec.get('number_of_columns'))
        ROW_NBR = int(config_sec.get('number_of_lines'))
        GRID_IMG_SZ = int(config_sec.get('grid_image_size'))
        INFO_IMG_SZ = int(config_sec.get('preview_image_size'))
        BUTT_HEIGHT = int(config_sec.get('button_height'))
        FONT_NAME = config_sec.get('font_name')
        FONT_SIZE = int(config_sec.get('font_size'))
        FONT_WEIGHT = config_sec.get('font_weight')
        BG_COLOR = config_sec.get('background_color')
        FONT_COLOR = config_sec.get('main_color')
        ACC_COLOR1 = config_sec.get('accent_color_1')
        ACC_COLOR2 = config_sec.get('accent_color_2')
        ALERT_COLOR = config_sec.get('alert_color')
        TOP_PATH = config_sec.get('default_path')

        FONT = [FONT_NAME, FONT_SIZE, FONT_WEIGHT]

    except (ValueError, configparser.NoOptionError) as e:
        print(f'.INI file problem: {str(e)}')
        raise SystemExit(0)


def get_image_paths():
    '''Get images from the path'''

    ext = ['.png', '.jpg']
    files = []
    for e in ext:
        file = glob.glob(TOP_PATH + '/**/*' + e, recursive=True)
        files.extend(file)

    # Sort by modified date
    files.sort(key=os.path.getmtime, reverse=True)

    return files


def resize_image(image, maxsize):
    '''Resize image maintaining aspect ratio and maximum size'''

    r1 = image.size[0] / maxsize[0]  # width ratio
    r2 = image.size[1] / maxsize[1]  # height ratio
    ratio = max(r1, r2)
    newsize = (int(image.size[0] / ratio), int(image.size[1] / ratio))
    image = image.resize(newsize, Image.Resampling.LANCZOS)
    return image


def on_mousewheel(event):
    '''Handles mouse wheel'''

    # Prevents mouse wheel from scrolling when outside grid
    if str(event.widget).split('.')[-1] == 'text_info' \
            or str(event.widget).split('.')[-1] == 'font_list' \
            or str(event.widget).split('.')[-1] == 'combo_box':
        return

    if OS == 'Linux':
        y_steps = 5
        if event.num == 4:
            y_steps *= -1
    elif OS == 'Darwin':
        y_steps = event.delta
    elif OS == 'Windows':
        y_steps = int(-1 * (event.delta / 120))

    canvas.yview_scroll(y_steps, 'units')


def click_grid_image(image_data, idx):
    '''Handles clicking on a image on the grid'''

    global current_seed
    global image_filepath
    global prev_button

    button = image_data[idx][0]
    image = image_data[idx][2]
    embed_info = image_data[idx][3]
    file = image_data[idx][4]

    blank = blank_image(ACC_COLOR1)

    image_keep = button.image
    button['image'] = blank
    prev_button.config(bg=BG_COLOR)
    button.config(bg=ACC_COLOR1)

    button.update()
    button.focus_set()

    image_filepath = file

    # original_image = Image.open(file)
    image = resize_image(image, (INFO_IMG_SZ, INFO_IMG_SZ))
    image = ImageTk.PhotoImage(image)
    img_info['image'] = image
    img_info.image = image
    img_info.config(bg=BG_COLOR)
    img_info['text'] = idx

    # Get tag information for colorizing
    matches = []
    for i, line in enumerate(embed_info, 1):
        for tag in TEXT_PARS:
            tag_colon = f'{tag}:'
            if line.startswith(tag_colon):
                start = f'{str(i)}.{len(tag_colon)}'
                end = f'{str(i)}.{len(line)}'
                content = line[len(tag_colon):]
                matches.append((tag_colon, start, end, content))

    # Draw text
    text_info['state'] = 'normal'
    text_info.delete('1.0', 'end')
    embed_info = ''.join(embed_info)
    text_info.insert('insert', embed_info)
    for match in matches:
        if match[0].startswith('seed:'):
            current_seed = match[3]
        color = ACC_COLOR2
        if match[3].strip().replace('.', '').isdigit() \
                or match[3].strip().replace(' x ', '').isdigit()  \
                or match[3].strip().replace(' ', '').isdigit():
            color = ACC_COLOR1
        if match[0].startswith('embedded info'):
            color = ALERT_COLOR
        text_info.tag_add(match[0], match[1], match[2])
        text_info.tag_config(match[0], foreground=color)
    text_info['state'] = 'disable'

    # Give a little time for Python to come to it's senses
    time.sleep(0.05)

    button['image'] = image_keep
    prev_button = button


def grid_keys(event, idx, delta):
    '''Navigate grid with the arrow keys'''

    if (idx + delta < 0) or (idx + delta > len(image_list) - 1):
        return

    if image_list[idx + delta][0]['state'] == 'disabled':
        return

    idx = idx + delta
    image_amount = len(image_list)
    image_y = math.floor(idx / COL_NBR)
    rows = math.ceil(image_amount / COL_NBR)
    button = image_list[idx][0]
    button_y = button.winfo_y()
    canvas_height = canvas.winfo_height()
    y_srt = canvas.yview()[0]
    y_end = canvas.yview()[1]
    y_len = y_end - y_srt
    total_height = int(canvas_height / y_len)
    canvas_y_top = int(total_height * y_srt)
    canvas_y_bot = int(total_height * y_end)
    canvas_position = image_y / rows
    img_len = 1 / rows

    # Only move if selection is outside the grid frame
    if (button_y > canvas_y_bot - GRID_IMG_SZ):
        canvas.yview_moveto(canvas_position - y_len + img_len)
    if (button_y <= canvas_y_top):
        canvas.yview_moveto(canvas_position)

    button.invoke()
    button.focus_set()


def read_image_info(original_image, image_path):
    '''Read the images embedded information'''

    source = ''
    image_format = original_image.format
    try:
        if image_format == 'PNG':
            embed = original_image.text
        elif image_format == 'JPEG':
            img_exif = original_image._getexif()
            data = list(img_exif.items())[1][1]
            if not isinstance(data, int):
                embed = [chr(d) for d in data if d > 0]
                embed = ''.join(embed)
                embed = embed[7:]
                if embed.startswith('Upscale'):
                    embed = {'extras': embed}
                else:
                    embed = {'parameters': embed}
            else:
                embed = False
        if embed:
            embed_key = list(embed.keys())[0]
            # If image is from automatic1111 or other sources
            if embed_key == 'parameters':
                source = 'automatic1111'

                parameters = embed[embed_key]
                prompt = parameters.partition('Steps: ')[0]
                negative_prompt = prompt.partition('Negative prompt: ')[2]
                parameters = 'Steps: ' + parameters.partition('Steps: ')[2]

                if negative_prompt:
                    prompt = prompt.partition('Negative prompt: ')[0]
                    embed_par = [('prompt', prompt.strip().replace('\n', ', '))]
                    embed_par.append(('negative prompt', negative_prompt.strip().replace('\n', ', ')))
                else:
                    embed_par = [('prompt', prompt.strip())]

                parameters = parameters.split(',')

                for par in parameters:
                    tag = par.split(':')[0].strip().lower()
                    content = par[len(tag) + 2:].strip()
                    embed_par.append((tag, content))

            elif embed_key == 'extras':
                source = 'automatic1111 extras'

                parameters = embed[embed_key].replace('\n', ',')
                parameters = parameters.split(',')

                embed_par = []
                for par in parameters:
                    if par:
                        tag = par.split(':')[0].strip().lower()
                        content = par[len(tag) + 2:].strip()
                        embed_par.append((tag, content))
            else:
                try:
                    source = embed_key

                    embed_par = json.loads(embed[embed_key])
                    embed_par = list(embed_par.items())

                    if not embed_par:
                        embed_par = [('embedded info', 'not found')]
                except json.decoder.JSONDecodeError:
                    embed_par = [('embedded info', 'unknown type')]
        else:
            embed = ''
            embed_par = [('embedded info', 'not found')]

    except AttributeError:
        embed_par = [('embedded info', 'not found')]
    except IndexError:
        embed_par = [('embedded info', 'unknown format')]

    # Additional information
    real_size = original_image.size[0], original_image.size[1]

    img_format = os.path.basename(image_path)
    img_format = img_format.split('.')[-1]

    file_time = os.path.getmtime(image_path)
    file_time = datetime.datetime.fromtimestamp(file_time)
    file_time = file_time.strftime("%d-%m-%Y %H:%M:%S")

    embed_par.append((' ', ' '))
    embed_par.append(('source', source))
    embed_par.append(('real_size', f'{real_size[0]} x {real_size[1]}'))
    embed_par.append(('format', img_format))
    embed_par.append(('created', str(file_time)))
    embed_par.append(('path', image_path))

    try:
        embed_par.sort(key=lambda i: TEXT_PARS.index(i[0]))
    except ValueError:
        pars_list = [item[0] for item in embed_par]
        dif_pars = list(set(pars_list) - set(TEXT_PARS))
        for par in dif_pars:
            if par not in new_pars and par.strip() != '':
                new_pars.append(par)

    # Convert to string
    embed_txt = []
    for par in embed_par:
        if par[0] != ' ':
            embed_txt.append(': '.join(par) + '\n')
        else:
            embed_txt.append('\n')

    return embed_txt


def maintain_aspect_ratio(event, original, c_full_img, aspect_ratio):
    '''Maintains aspect ratio when resizing the image window'''

    new_aspect_ratio = event.width / event.height
    if new_aspect_ratio > aspect_ratio:
        desired_width = event.width
        desired_height = int(event.width / aspect_ratio)
    else:
        desired_height = event.height
        desired_width = int(event.height * aspect_ratio)

    if event.width != desired_width or event.height != desired_height:
        try:
            event.widget.geometry(f'{desired_width}x{desired_height}')
            size = (desired_width, desired_height)
            resized = original.resize(size, Image.Resampling.LANCZOS)
            image = ImageTk.PhotoImage(resized)
            c_full_img.delete('IMG')
            c_full_img.create_image(0, 0, image=image, anchor='nw', tags='IMG')
            c_full_img.image = image
        except AttributeError:
            pass
        return 'break'


def show_full_image(idx):
    '''Handles clicking on the image preview'''

    if not idx:
        idx = img_info['text']

    if idx == PROGRAM_NAME:
        return

    image_window = tk.Toplevel()
    image_window.title(f'{current_seed.strip()} - {image_list[idx][4]}')

    original = image_list[idx][2]

    # Prevent showing images bigger than the screen size
    max_width = min(original.size[0], image_window.winfo_screenwidth())
    max_height = min(original.size[1], image_window.winfo_screenheight())
    original = resize_image(original, (max_width, max_height))

    image = ImageTk.PhotoImage(original)

    x = root.winfo_x()
    y = root.winfo_y() + 30 + BUTT_HEIGHT
    dimensions = f'{image.width()}x{image.height()}+{x}+{y}'
    image_window.geometry(dimensions)

    frame = tk.Frame(image_window)
    frame.columnconfigure(0, weight=1)
    frame.rowconfigure(0, weight=1)

    c_full_img = tk.Canvas(image_window, bd=0, highlightthickness=0)
    c_full_img.create_image(0, 0, image=image, anchor='nw', tags='IMG')
    c_full_img.image = image
    c_full_img.grid(row=0, sticky='news')
    c_full_img.pack(fill='both', expand=1)

    image_window.update()
    width = image_window.winfo_width()
    height = image_window.winfo_height()
    image_window.bind('<Configure>', lambda event: maintain_aspect_ratio(event, original, c_full_img, width / height))
    image_window.bind('<Escape>', lambda event: image_window.destroy())


def show_image(path):

    if not path:
        return

    path = os.path.normpath(path)

    if OS == 'Linux':
        default_app = subprocess.run(['xdg-mime', 'query', 'default', 'inode/directory'], stdout=subprocess.PIPE).stdout.decode('utf-8').strip()

        if default_app == 'org.kde.dolphin.desktop':
            subprocess.Popen(['dolphin', path])
        else:
            default_app == 'nautilus.desktop'
            subprocess.Popen(['nautilus', path])
    elif OS == 'Darwin':
        subprocess.Popen(["open", path])
    else:
        subprocess.Popen(["explorer", '/open,', path])


def new_path():
    '''Handles the new path button'''

    global TOP_PATH

    folder_selected = filedialog.askdirectory()
    if not folder_selected:
        return

    TOP_PATH = folder_selected

    reset_interface()


def open_config():
    '''Main configuration window'''

    global config
    global conf_entries
    global conf_labels
    global bt_color_list

    config = tk.Toplevel()
    config.title('Configuration')
    config.grab_set()
    config.option_add('*font', FONT)
    config.resizable(True, True)
    x = root.winfo_x() + GRID_IMG_SZ * COL_NBR
    y = root.winfo_y() + 30 + BUTT_HEIGHT
    config.geometry(f'+{x}+{y}')
    config_frame = tk.Frame(config, bg=BG_COLOR)
    config_frame.pack(expand=True, fill='both')

    dummy = tk.Label(config_frame, text=' ', bg=BG_COLOR)
    dummy.grid(row=0)

    config_frame.grid_columnconfigure(0, weight=0)
    config_frame.grid_columnconfigure(1, weight=0)
    config_frame.grid_columnconfigure(1, weight=1)

    conf_cont = [['Number of columns', COL_NBR, None, None],
                 ['Number of rows', ROW_NBR, None, None],
                 ['Gird image size', GRID_IMG_SZ, None, None],
                 ['Preview image size', INFO_IMG_SZ, None, None],
                 ['Button height', BUTT_HEIGHT, None, None],
                 ['Font name', FONT[0], 'get', None, font_requester],
                 ['Font size', FONT[1], 'get', None, font_requester],
                 ['Font weight', FONT[2], 'get', None, font_requester],
                 ['Background color', BG_COLOR, 'pick', BG_COLOR, pick_color],
                 ['Main color', FONT_COLOR, 'pick', FONT_COLOR, pick_color],
                 ['Accent color 1', ACC_COLOR1, 'pick', ACC_COLOR1, pick_color],
                 ['Accent color 2', ACC_COLOR2, 'pick', ACC_COLOR2, pick_color],
                 ['Alert color', ALERT_COLOR, 'pick', ALERT_COLOR, pick_color],
                 ['Default path', TOP_PATH, 'get', None, change_config_path]]

    brd_bt_color_list = []
    bt_color_list = []
    conf_entries = []
    conf_labels = []
    for r, cont in enumerate(conf_cont, 1):
        label = tk.Label(config_frame, text=cont[0], bg=BG_COLOR, fg=FONT_COLOR)
        label.grid(row=r, column=0, sticky='e', padx=(20, 0))
        conf_labels.append(label)

        brd_bt_tbox = tk.Frame(config_frame, bg=BG_COLOR)
        brd_bt_tbox.grid(row=r, column=1, sticky='wens')
        tbox = tk.Entry(brd_bt_tbox, bg=ACC_COLOR1, fg=BG_COLOR, width=30, bd=0, name=str(r),
                        selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2)
        tbox.insert('insert', cont[1])
        tbox.bind('<Return>', lambda event, nbr=r: change_color(nbr))
        tbox.bind('<Tab>', lambda event, nbr=r: change_color(nbr))
        tbox.pack(expand=True, fill='both', pady=1, padx=1)
        conf_entries.append(tbox)

        config_frame.rowconfigure(r, weight=1)

        if cont[2]:
            brd_bt_action = tk.Frame(config_frame, bg=BG_COLOR)
            brd_bt_action.grid(row=r, column=2, sticky='wens')
            action = tk.Button(brd_bt_action, text=cont[2], bd=0,
                               bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
            action.bind('<ButtonRelease-1>', lambda event, func=cont[4], nbr=r, cur_col=cont[3]: func(nbr, cur_col))
            action.pack(expand=True, fill='both', pady=1, padx=1)

        if cont[3]:
            brd_bt_color = tk.Frame(config_frame, bg=BG_COLOR)
            brd_bt_color.grid(row=r, column=3, sticky='wens', padx=(0, 20))
            color = tk.Button(brd_bt_color, text='   ', bd=0, bg=cont[3], activebackground=cont[3])
            color.pack(expand=True, fill='both', pady=1, padx=1)
            color.bind('<ButtonRelease-1>', lambda event, func=cont[4], nbr=r, cur_col=cont[3]: func(nbr, cur_col))
            brd_bt_color_list.append(brd_bt_color)
            bt_color_list.append(color)

    brd_bt_color_list[0]['bg'] = FONT_COLOR
    conf_entries[13].xview_moveto(1)

    conf_entries[6].bind('<Return>', lambda e: change_button_height(conf_entries[6].get()))
    conf_entries[6].bind('<Tab>', lambda e: change_button_height(conf_entries[6].get()))
    conf_entries[6].bind('<FocusOut>', lambda e: change_button_height(conf_entries[6].get()))

    btn_frame = tk.Frame(config_frame, bg=BG_COLOR)
    btn_frame.grid(row=r + 1, columnspan=4, sticky='ew', pady=(20, 20))
    btn_frame.grid_columnconfigure(0, weight=1)
    btn_frame.grid_columnconfigure(1, weight=1)

    brd_bt_btn_accept = tk.Frame(btn_frame, bg=BG_COLOR)
    brd_bt_btn_accept.grid(row=0, column=0, sticky='wens', padx=(20, 0))
    btn_accept = tk.Button(brd_bt_btn_accept, text='OK (restart)',
                           bg=FONT_COLOR, fg=BG_COLOR, bd=0, activebackground=ACC_COLOR1)
    btn_accept['command'] = lambda arg=conf_entries: accept_config(arg)
    btn_accept.pack(expand=True, fill='both', pady=1, padx=1)

    brd_btn_cancel = tk.Frame(btn_frame, bg=BG_COLOR)
    brd_btn_cancel.grid(row=0, column=1, sticky='wens', padx=(0, 20))
    btn_cancel = tk.Button(brd_btn_cancel, text='cancel', bd=0, command=config.destroy,
                           bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    btn_cancel.pack(expand=True, fill='both', pady=1, padx=1)


def change_button_height(size):
    '''Update the button height configuration box'''

    conf_entries[4].delete(0, 'end')
    conf_entries[4].insert('insert', int(int(size) * 2.5))


def change_config_path(r, cur_col):
    '''Get new path for the configuration'''

    # Open an inactive window to be able to disable the main interface
    dummy_window = tk.Toplevel()
    dummy_window.withdraw()
    config.grab_release()
    dummy_window.grab_set()

    folder_selected = filedialog.askdirectory()
    if folder_selected:
        conf_entries[r - 1].delete(0, 'end')
        conf_entries[r - 1].insert('insert', folder_selected)
        conf_entries[r - 1].xview_moveto(1)

    dummy_window.destroy()
    config.grab_set()


def pick_color(r, cur_col):
    '''Open a color picker'''

    # Open an inactive window to be able to disable the main interface
    dummy_window = tk.Toplevel()
    dummy_window.withdraw()
    config.grab_release()
    dummy_window.grab_set()

    conf_entries[r - 1].delete(0, 'end')
    color = askcolor(color=cur_col, title=conf_labels[r - 1]['text'])[1]

    if not color:
        color = cur_col
    conf_entries[r - 1].insert('insert', color)

    dummy_window.destroy()
    config.grab_set()

    change_color(r)


def change_color(r):
    '''Change the selected color'''

    if r < 9 or r > 13:
        return
    try:
        bt_color_list[r - 9]['bg'] = conf_entries[r - 1].get()
    except tk.TclError:
        conf_entries[r - 1].delete(0, 'end')
        conf_entries[r - 1].insert('insert', 'Invalid color')


def accept_config(conf_entries):
    '''Close the configuration window applying changes'''

    global COL_NBR
    global ROW_NBR
    global GRID_IMG_SZ
    global INFO_IMG_SZ
    global BUTT_HEIGHT
    global FONT
    global BG_COLOR
    global FONT_COLOR
    global ACC_COLOR1
    global ACC_COLOR2
    global ALERT_COLOR
    global TOP_PATH

    t_col_nbr = int(conf_entries[0].get())
    t_row_nbr = int(conf_entries[1].get())
    t_grid_img_sz = int(conf_entries[2].get())
    t_info_img_sz = int(conf_entries[3].get())
    t_scr_width = root.winfo_screenwidth() * 0.9
    t_scr_height = root.winfo_screenheight() * 0.9

    change_button_height(conf_entries[6].get())

    # Check if the interface will fit on the current screen size
    if (t_col_nbr * t_grid_img_sz + t_info_img_sz) > t_scr_width \
            or (t_row_nbr * t_grid_img_sz) > t_scr_height \
            or t_info_img_sz > t_scr_height:
        tk.messagebox.showinfo(title='Bad configuration',
                               message='Interface elements too big or too many.\n'
                                       'Will not fit within 90% of the screen.',
                               parent=config)
        return

    COL_NBR = int(conf_entries[0].get())
    ROW_NBR = int(conf_entries[1].get())
    GRID_IMG_SZ = int(conf_entries[2].get())
    INFO_IMG_SZ = int(conf_entries[3].get())
    BUTT_HEIGHT = int(conf_entries[4].get())
    FONT = (conf_entries[5].get(),
            int(conf_entries[6].get()),
            conf_entries[7].get())
    BG_COLOR = bt_color_list[0]['bg']
    FONT_COLOR = bt_color_list[1]['bg']
    ACC_COLOR1 = bt_color_list[2]['bg']
    ACC_COLOR2 = bt_color_list[3]['bg']
    ALERT_COLOR = bt_color_list[4]['bg']
    TOP_PATH = conf_entries[13].get()

    FONT_NAME = FONT[0]
    FONT_SIZE = FONT[1]
    FONT_WEIGHT = FONT[2]

    if not config_ini.has_section('CONFIGS'):
        config_ini.add_section('CONFIGS')
    config_ini.set('CONFIGS', 'number_of_columns', str(COL_NBR))
    config_ini.set('CONFIGS', 'number_of_lines', str(ROW_NBR))
    config_ini.set('CONFIGS', 'grid_image_size', str(GRID_IMG_SZ))
    config_ini.set('CONFIGS', 'preview_image_size', str(INFO_IMG_SZ))
    config_ini.set('CONFIGS', 'button_height', str(BUTT_HEIGHT))
    config_ini.set('CONFIGS', 'font_name', FONT_NAME)
    config_ini.set('CONFIGS', 'font_size', str(FONT_SIZE))
    config_ini.set('CONFIGS', 'font_weight', FONT_WEIGHT)
    config_ini.set('CONFIGS', 'background_color', BG_COLOR)
    config_ini.set('CONFIGS', 'main_color', FONT_COLOR)
    config_ini.set('CONFIGS', 'accent_color_1', ACC_COLOR1)
    config_ini.set('CONFIGS', 'accent_color_2', ACC_COLOR2)
    config_ini.set('CONFIGS', 'alert_color', ALERT_COLOR)
    config_ini.set('CONFIGS', 'default_path', TOP_PATH)

    with open(ini_path, 'w') as configfile:
        config_ini.write(configfile)

    config.destroy()

    reset_interface()


def font_requester(r, cur_col):
    '''Create a font requester'''

    # global font_box
    global font_pick
    global size_entry
    global font_temp
    global font_req

    font_temp = FONT

    font_req = tk.Toplevel()
    font_req.title('Font')

    available_fonts = font.families()
    available_fonts = sorted(available_fonts)

    font_box = tk.Listbox(font_req, highlightthickness=0, relief='flat', name='font_list',
                          bg=ACC_COLOR1, fg=BG_COLOR, selectbackground=FONT_COLOR)
    font_box.grid(row=0, columnspan=3, sticky='news')
    font_box.option_add('*font', FONT)

    sb = tk.Scrollbar(font_req, orient='vertical')
    sb.grid(row=0, column=3, sticky='news')

    font_box.configure(yscrollcommand=sb.set)
    sb.config(command=font_box.yview)

    config.grab_release()
    font_req.grab_set()

    for fonts in available_fonts:
        font_box.insert('end', fonts)

    # Duplicate the last element to prevent down key from overflowing the listbox items
    available_fonts.append(available_fonts[-1])

    font_box.bind("<ButtonRelease-1>", lambda e: change_font(
                  [available_fonts[font_box.curselection()[0]], int(size_entry.get()), font_temp[2]]))

    font_box.bind("<Up>", lambda e: change_font(
                  [available_fonts[font_box.curselection()[0] - 1], int(size_entry.get()), font_temp[2]]))

    font_box.bind("<Down>", lambda e: change_font(
                  [available_fonts[font_box.curselection()[0] + 1], int(size_entry.get()), font_temp[2]]))

    weight_list = []
    brd_norm_butt = tk.Frame(font_req, bg=BG_COLOR)
    brd_norm_butt.grid(row=1, column=0, sticky='nsew')
    norm_butt = tk.Button(brd_norm_butt, text="N", bg=FONT_COLOR, fg=BG_COLOR,
                          font=(FONT[0], FONT[1], 'normal'), activebackground=ACC_COLOR1,
                          bd=0, command=lambda: font_weight(0, weight_list))
    norm_butt.pack(expand=True, fill='both', pady=1, padx=1)
    weight_list.append([norm_butt, 'normal'])

    brd_norm_bold = tk.Frame(font_req, bg=BG_COLOR)
    brd_norm_bold.grid(row=1, column=1, sticky='nsew')
    bold_butt = tk.Button(brd_norm_bold, text="B", bg=FONT_COLOR, fg=BG_COLOR,
                          font=(FONT[0], FONT[1], 'bold'), activebackground=ACC_COLOR1,
                          bd=0, command=lambda: font_weight(1, weight_list))
    bold_butt.pack(expand=True, fill='both', pady=1, padx=1)
    weight_list.append([bold_butt, 'bold'])

    brd_norm_ital = tk.Frame(font_req, bg=BG_COLOR)
    brd_norm_ital.grid(row=1, column=2, columnspan=2, sticky='nsew')
    ital_butt = tk.Button(brd_norm_ital, text="I", bg=FONT_COLOR, fg=BG_COLOR,
                          font=(FONT[0], FONT[1], 'italic'), activebackground=ACC_COLOR1,
                          bd=0, command=lambda: font_weight(2, weight_list))
    ital_butt.pack(expand=True, fill='both', pady=1, padx=1)
    weight_list.append([ital_butt, 'italic'])

    size_entry = tk.Entry(font_req, text="cancel", bd=0, bg=ACC_COLOR1, fg=BG_COLOR)
    size_entry.delete(0, 'end')
    size_entry.insert('insert', conf_entries[6].get())
    size_entry.bind('<Return>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
    size_entry.bind('<Tab>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
    size_entry.bind('<FocusOut>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
    size_entry.grid(row=2, column=0, columnspan=2, sticky='nsew')

    brd_siz_frm = tk.Frame(font_req, bg=BG_COLOR)
    brd_siz_frm.grid(row=2, column=2, columnspan=2, sticky='nsew')

    brd_siz_min = tk.Frame(brd_siz_frm, bg=BG_COLOR)
    brd_siz_min.grid(row=0, column=0, sticky='nsew')
    size_min = tk.Button(brd_siz_min, text="<", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                         command=lambda: siz_min_pls(-1, size_entry))
    size_min.pack(expand=True, fill='both', pady=1, padx=1)

    brd_siz_pls = tk.Frame(brd_siz_frm, bg=BG_COLOR)
    brd_siz_pls.grid(row=0, column=1, sticky='nsew')
    size_pls = tk.Button(brd_siz_pls, text=">", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                         command=lambda: siz_min_pls(1, size_entry))
    size_pls.pack(expand=True, fill='both', pady=1, padx=1)

    brd_siz_frm.columnconfigure(0, weight=1)
    brd_siz_frm.columnconfigure(1, weight=1)

    brd_ok_butt = tk.Frame(font_req, bg=BG_COLOR)
    brd_ok_butt.grid(row=3, column=0, columnspan=2, sticky='nsew')
    ok_butt = tk.Button(brd_ok_butt, text="OK", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                        activebackground=ACC_COLOR1, command=accept_font)
    ok_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_cancel_butt = tk.Frame(font_req, bg=BG_COLOR)
    brd_cancel_butt.grid(row=3, column=2, columnspan=2, sticky='nsew')
    cancel_butt = tk.Button(brd_cancel_butt, text="cancel", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                            activebackground=ACC_COLOR1, command=font_req.destroy)
    cancel_butt.pack(expand=True, fill='both', pady=1, padx=1)

    font_pick = tk.Entry(font_req, justify='center', bd=0,
                         bg=BG_COLOR, fg=FONT_COLOR, font=(FONT[0], FONT[1], FONT[2]))
    font_pick.insert('insert', 'Diffusion')
    font_pick.grid(row=4, columnspan=4, sticky='nsew')

    font_req.rowconfigure(0, weight=1)
    font_req.columnconfigure(0, weight=1)
    font_req.columnconfigure(1, weight=1)
    font_req.columnconfigure(2, weight=1)
    font_req.columnconfigure(3, weight=0)

    font_req.resizable(True, True)
    font_req.update_idletasks()
    font_req_width = int(config.winfo_width() / 2)
    font_req.geometry(f'{font_req_width}x{config.winfo_height()}+{config.winfo_x()}+{config.winfo_y()}')


def siz_min_pls(delta, entry):
    '''Buttons to change the font size'''

    size = int(entry.get())
    size += delta
    if size < 1:
        size = 1
    entry.delete(0, 'end')
    entry.insert('insert', size)

    change_font([font_temp[0], int(size), font_temp[2]])


def font_weight(weight, weight_list):
    '''Handles clicking on the font weight buttons'''

    global font_temp
    for item in weight_list:
        item[0]['bg'] = FONT_COLOR
        item[0]['fg'] = BG_COLOR

    weight_list[weight][0]['bg'] = BG_COLOR
    weight_list[weight][0]['fg'] = FONT_COLOR

    font_temp[2] = weight_list[weight][1]
    font_temp[1] = int(size_entry.get()),

    change_font(font_temp)


def change_font(font_arg):
    '''Change the current font'''

    global font_temp
    font_temp = font_arg
    font_pick.config(font=font_temp)


def accept_font():
    '''Close the font requester accepting the changes'''

    conf_entries[4].delete(0, 'end')
    conf_entries[4].insert('insert', int(int(size_entry.get()) * 2.5))
    conf_entries[5].delete(0, 'end')
    conf_entries[5].insert('insert', font_temp[0])
    conf_entries[6].delete(0, 'end')
    conf_entries[6].insert('insert', size_entry.get())
    conf_entries[7].delete(0, 'end')
    conf_entries[7].insert('insert', font_temp[2])
    config.grab_set()
    font_req.destroy()


def copy_to_clipboard(event, info):
    '''Copy to clipboard'''

    try:
        if event:
            info = text_info.get('sel.first', 'sel.last')
        root.clipboard_clear()
        root.clipboard_append(info)
        root.update()
    except tk.TclError:
        return


def explore_folder(path):
    '''Open explorer on the current location'''

    if not path:
        return

    path = os.path.normpath(path)

    if OS == 'Linux':
        default_app = subprocess.run(['xdg-mime', 'query', 'default', 'inode/directory'], stdout=subprocess.PIPE).stdout.decode('utf-8').strip()

        if default_app == 'org.kde.dolphin.desktop':
            subprocess.Popen(['dolphin', '--select', path])
        else:
            default_app == 'nautilus.desktop'
            subprocess.Popen(['nautilus', '--select', path])
    elif OS == 'Darwin':
        subprocess.Popen(["open", "-R", path])
    else:
        subprocess.Popen(["explorer", '/select,', path])


def reset_interface():
    '''Resets the program'''

    frame_all.destroy()
    main()


def refresh_grid():
    '''Update new / deleted images files'''

    global image_list_master
    global image_list

    old_files = [item[4] for item in image_list_master]
    new_files = get_image_paths()

    if not collections.Counter(old_files) == collections.Counter(new_files):
        apagados = list(set(old_files) - set(new_files))
        novos = list(set(new_files) - set(old_files))

        for image_data in image_list:
            image_data[0].destroy()

        if apagados:
            image_list_temp = []
            for item in image_list_master:
                if item[4] not in apagados:
                    image_list_temp.append(item)
            image_list_master = image_list_temp
            image_list = image_list_master

        if novos:
            image_list_temp = image_list_master
            image_list_master = []
            for c, file in enumerate(novos):
                image_list_master.append([None, None, None, None, file, c])
            image_list_master = generate_image_list('', '', master=True)
            image_list_master.extend(image_list_temp)
            image_list = image_list_master

        grid_buttons()
        lbl_files.config(text=f'{len(image_list_master)} images')

        img_info.config(bg=FONT_COLOR, text=PROGRAM_NAME, image='')
        text_info['state'] = 'normal'
        text_info.delete('1.0', 'end')
        text_info.insert('insert', TEXT_INFO_DEFAULT)
        text_info['state'] = 'disable'


def blank_image(color, a=0, w=None, h=None):
    '''Create a blank image'''

    if w is None:
        w = GRID_IMG_SZ

    if h is None:
        h = GRID_IMG_SZ

    blank = Image.new(color=color, mode="RGB", size=(w, h))
    blank.putalpha(a)
    blank = ImageTk.PhotoImage(blank)

    return blank


def search_images(search_string, parameter_string):
    '''Sow images matching a search string'''

    global image_list

    search_string = enter_search(search_string)

    for image_data in image_list:
        image_data[0].destroy()

    image_list = generate_image_list(search_string, parameter_string)

    grid_buttons()


def expose_images(search_string, parameter_string):
    '''Disable non matching images'''

    search_string = enter_search(search_string)
    parameter_string = parameter_string.strip()

    for c, image_data in enumerate(image_list):
        embed_info = image_data[3]

        embed_txt = ''
        if parameter_string == 'all parameters' or parameter_string == '':
            embed_txt = ''.join(embed_info)
            embed_txt = embed_txt.lower()
        else:
            for e in embed_info:
                tag = e.split(':')[0]
                if tag == parameter_string:
                    embed_txt = e[len(tag) + 2:].lower()
                    break
            else:
                embed_txt = ''

        image_data[0].config(bg=BG_COLOR, state='normal')
        if search_string.lower() not in embed_txt:
            image_data[0].config(bg=ACC_COLOR2, state='disabled')


def enter_search(search_string):
    '''When entering the search box'''

    if search_string == SEARCH_HELP:
        entry_search.configure(fg=BG_COLOR)
        entry_search.delete(0, 'end')
        return ''

    return search_string


def generate_image_list(search_string, parameter_string, master=False):

    if master:
        t = len(image_list_master)
        restart = tk.Toplevel()
        restart.title(f'Restarting')
        restart.resizable(False, False)
        restart.bind('<Escape>', lambda event: restart.destroy())
        restart_frame = tk.Frame(restart, bg=BG_COLOR)
        restart_frame.pack(expand=True, fill='both')

        load_img = tk.Label(restart_frame, bg=BG_COLOR, fg=FONT_COLOR,
                            font=(FONT[0], int(FONT[1] * 1.2), FONT[2]),
                            text='Loading images, please wait.')
        load_img.pack(pady=0, padx=50)

        loading = tk.Label(restart_frame, bg=BG_COLOR, fg=ACC_COLOR1,
                           font=(FONT[0], int(FONT[1] * 1.2), FONT[2]),
                           text=f'{0} of {t}')
        loading.pack(pady=0, padx=50)

        bar_lenght = GRID_IMG_SZ * COL_NBR / 2
        style = ttk.Style()
        style.configure('TProgressbar', relief='flat', borderwidth=0, background=FONT_COLOR, foreground=BG_COLOR)
        progress = ttk.Progressbar(restart_frame, orient='horizontal', length=bar_lenght, mode='determinate')
        progress.pack(pady=10, padx=50)

        # Update restart to get width and height
        restart.update()

        x = root.winfo_x() + int(((GRID_IMG_SZ * COL_NBR) - restart.winfo_width()) / 2)
        y = root.winfo_y() + BUTT_HEIGHT + int(((GRID_IMG_SZ * ROW_NBR) - restart.winfo_height()) / 2)
        restart.geometry(f'+{x}+{y}')

    c = 0
    image_list = []
    parameter_string = parameter_string.strip()

    # start = time.time()
    image_error = []
    for image_data in image_list_master:
        file = image_data[4]
        if master:
            try:
                original_image = Image.open(file)
            except UnidentifiedImageError:
                image_error.append(file)
                continue
            grid_image = resize_image(original_image, (GRID_IMG_SZ, GRID_IMG_SZ))
            grid_image = ImageTk.PhotoImage(grid_image)
            embed_info = read_image_info(original_image, file)
        else:
            grid_image = image_data[1]
            original_image = image_data[2]
            embed_info = image_data[3]

        embed_txt = ''
        if parameter_string == 'all parameters' or parameter_string == '':
            embed_txt = ''.join(embed_info)
            embed_txt = embed_txt.lower()
        else:
            for e in embed_info:
                tag = e.split(':')[0]
                if tag == parameter_string:
                    embed_txt = e[len(tag) + 2:].lower()
                    break
            else:
                embed_txt = ''

        if search_string.lower() in embed_txt:
            image_list.append([None, grid_image, original_image, embed_info, file, c])
            c += 1

        if master:
            prog = int(c / t * 100)
            try:
                loading['text'] = f'{c} of {t}'
                progress['value'] = prog
            except tk.TclError:
                break
            progress.update()

        lbl_files.config(text=f'{c} images')

    # print(time.time() - start)

    lbl_files.config(text=f'{c} images')

    if master:
        restart.destroy()

    if image_error:
        image_error_copy = '\n'.join(image_error)
        tense = ['']
        if len(image_error) > 1:
            tense = ['s']

        copy_to_clipboard(None, image_error_copy)

        message = (f'Found {len(image_error)} image{tense[0]} with error.\n\n'
                   f'{image_error_copy}\n\n'
                   f'Path{tense[0]} copied to the clipboard.')
        res = tk.messagebox.showinfo(title='Image error.', message=message, parent=root)

    if new_pars:
        pars_copy = '\n'.join(new_pars)
        tense = ['', 'it', 'its', 'it', 'was']
        if len(new_pars) > 1:
            tense = ['s', 'them', 'their', 'they', 'were']
        message = (f'Found {len(new_pars)} new parameter{tense[0]}.\n\n'
                   f'{pars_copy}\n\n'
                   f'Add {tense[1]} to parameters.txt?\n'
                   f'({tense[3]} will be added before the space separator)\n\n'
                   f'If yes, open parameters.txt and adjust {tense[2]} order.\n\n'
                   f'If not, {tense[3]} {tense[4]} be copied to the clipboard '
                   f'and can be added manually.')
        res = tk.messagebox.askquestion(title='New parameter found.', message=message, parent=root)

        copy_to_clipboard(None, pars_copy)

        if res == 'yes':
            with open('parameters.txt', 'r') as file:
                temp_pars = file.read().splitlines()

            pos = len(temp_pars) - 6
            temp_pars[pos:pos] = new_pars

            with open('parameters.txt', 'w') as file:
                file.write('\n'.join(temp_pars))

    return image_list


def save_image(event, idx):
    orig_file = image_list[idx][4]
    orig_name = os.path.basename(orig_file)
    dest_file = filedialog.asksaveasfile(initialfile=orig_name)

    if not dest_file:
        return

    dest_file = dest_file.name
    shutil.copy2(orig_file, dest_file)


def grid_buttons():
    '''Create grid buttons'''

    global prev_button
    global image_list

    if not image_list:
        return

    bx = by = 0
    for idx, image_data in enumerate(image_list):
        button = tk.Button(frame_buttons, image=image_data[1], relief='flat', name=str(idx),  # text=idx, compound="center",
                           highlightthickness=BORDER, borderwidth=0, activebackground=BG_COLOR, bg=ACC_COLOR2)
        button['command'] = lambda idx=idx: click_grid_image(image_list, idx)
        button.bind('<Double-Button-1>', lambda event, idx=idx: show_full_image(idx))
        button.bind('<Return>', lambda event, idx=idx: show_full_image(idx))
        button.bind('<space>', lambda event, idx=idx: show_full_image(idx))
        button.bind('<Shift-Double-Button-1>', lambda event, idx=idx: show_image(image_list[idx]))
        button.bind('<Shift-Return>', lambda event, idx=idx: show_image(image_list[idx]))
        button.bind('<Shift-space>', lambda event, idx=idx: show_image(image_list[idx]))
        button.bind('<Left>', lambda event, idx=idx: grid_keys(event, idx, -1))
        button.bind('<Right>', lambda event, idx=idx: grid_keys(event, idx, 1))
        button.bind('<Up>', lambda event, idx=idx: grid_keys(event, idx, -COL_NBR))
        button.bind('<Down>', lambda event, idx=idx: grid_keys(event, idx, COL_NBR))
        button.bind('<Control-c>', lambda event, idx=idx: save_image(event, idx))
        button.bind("<Button-3>", lambda event, idx=idx: menu_popup(event, idx))
        button.bind("<Button-2>", lambda event, idx=idx: menu_popup(event, idx))
        button.grid(row=bx, column=by)
        button.image = image_data[1]

        # Needed to make disabled show correct bg color without affecting border at start
        button.config(bg=BG_COLOR)

        image_list[idx][0] = button

        by += 1
        if by % COL_NBR == 0:
            by = 0
            bx += 1

    prev_button = button

    # Update buttons frames idle tasks to let tkinter calculate buttons sizes
    frame_buttons.update_idletasks()

    # Set the canvas scrolling region
    canvas.config(scrollregion=canvas.bbox('all'))


def menu_popup(event, idx):
    global index

    index = idx

    try:
        pop_menu.tk_popup(event.x_root, event.y_root)
    finally:
        pop_menu.grab_release()


def menu_items(item):
    if item == 0:
        show_full_image(index)
    elif item == 1:
        print(index)
        image_filepath = image_list[index][4]
        show_image(image_filepath)
    elif item == 2:
        image_filepath = image_list[index][4]
        explore_folder(image_filepath)
    elif item == 3:
        embed_txt = ''.join(image_list[index][3])
        embed_txt = embed_txt.lower()
        copy_to_clipboard(None, embed_txt)
    else:
        save_image(None, index)


def first_run():
    '''Cold start the program'''
    global image_list
    global image_list_master

    for image_data in image_list:
        image_data[0].destroy()

    image_list = generate_image_list('', '', master=True)
    image_list_master = image_list

    grid_buttons()


def main():
    '''Create the main window'''

    global canvas
    global img_info
    global text_info
    global lbl_files
    global frame_all
    global frame_buttons
    global entry_search
    global pop_menu
    global image_list
    global image_list_master

    # Must be here to refresh when changing config
    root.option_add('*font', FONT)

    # Frame to hold the entire interface
    frame_all = tk.Frame(root, bg=BG_COLOR)
    frame_all.pack(fill=None, expand=False)

    # Top frame for labels and buttons
    frame_top = tk.Frame(frame_all, bg=BG_COLOR, height=BUTT_HEIGHT)
    frame_top.grid(row=0, column=0, sticky='news')
    frame_top.grid_propagate(False)

    frame_top.grid_rowconfigure(0, weight=1)
    frame_top.grid_columnconfigure(0, weight=1)
    frame_top.grid_columnconfigure(1, weight=0)

    # Top left sub frame for labels
    frame_top_l = tk.Frame(frame_top, bg=BG_COLOR)
    frame_top_l.grid(row=0, column=0, sticky='ewns')

    frame_top_l.grid_rowconfigure(0, weight=1)
    frame_top_l.grid_columnconfigure(0, weight=0)
    frame_top_l.grid_columnconfigure(1, weight=1)

    # Top right sub frame for buttons
    frame_top_r = tk.Frame(frame_top, width=INFO_IMG_SZ, bg=BG_COLOR)
    frame_top_r.grid(row=0, column=1, sticky='ewns')
    frame_top_r.grid_propagate(False)

    frame_top_r.grid_rowconfigure(0, weight=1)
    frame_top_r.grid_columnconfigure(0, weight=1)
    frame_top_r.grid_columnconfigure(1, weight=2)
    frame_top_r.grid_columnconfigure(2, weight=2)
    frame_top_r.grid_columnconfigure(3, weight=2)

    # Number of files label, top left frame
    lbl_files = tk.Label(frame_top_l, bg=BG_COLOR, fg=ACC_COLOR1, text=f'images')
    lbl_files.grid(row=0, column=0, sticky='w')

    # Current path label, top left frame
    lbl_path = tk.Button(frame_top_l,
                         bg=BG_COLOR, fg=FONT_COLOR, bd=0, command=lambda: copy_to_clipboard(None, TOP_PATH),
                         activeforeground=ACC_COLOR1, activebackground=BG_COLOR,
                         text=TOP_PATH, anchor='e', justify='right')
    lbl_path.grid(row=0, column=1, sticky='w')

    # Refresh button, top right frame
    brd_bt_refr = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_refr.grid(row=0, column=0, sticky='snwe')
    butt_refr = tk.Button(brd_bt_refr, text='!', bd=0, command=refresh_grid,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_refr.pack(expand=True, fill='both', pady=1, padx=1)

    # Path button, top right frame
    brd_bt_path = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_path.grid(row=0, column=1, sticky='snwe')
    butt_path = tk.Button(brd_bt_path, text='path', bd=0, command=new_path,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_path.pack(expand=True, fill='both', pady=1, padx=1)

    # Explorer button, top right frame
    brd_bt_open = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_open.grid(row=0, column=2, sticky='snwe')
    butt_open = tk.Button(brd_bt_open, text='show folder', bd=0, command=lambda: explore_folder(TOP_PATH),
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_open.pack(expand=True, fill='both', pady=1, padx=1)

    # Config button, top right frame
    brd_bt_conf = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_conf.grid(row=0, column=3, sticky='snwe')
    butt_conf = tk.Button(brd_bt_conf, text='config', bd=0, command=open_config,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_conf.pack(expand=True, fill='both', pady=1, padx=1)

    # Frame for the grid and info
    frame_main = tk.Frame(frame_all, bg=BG_COLOR)
    frame_main.grid(sticky='news')
    frame_main.grid(row=1, column=0, sticky='nw')

    # Frame for the info
    frame_info_height = GRID_IMG_SZ * ROW_NBR + (BORDER * 2 * ROW_NBR)
    info_frame = tk.Frame(frame_main, bg=BG_COLOR, width=INFO_IMG_SZ, height=frame_info_height)
    info_frame.grid(row=0, column=1, sticky='nw')

    # Button to show the selected image
    img_info = tk.Button(info_frame, bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1,
                         text=PROGRAM_NAME, font=(FONT[0], FONT[1] * 3, 'bold'),
                         borderwidth=0, name='teste')
    img_info.bind('<Button-1>', lambda event: show_full_image(None))
    img_info.bind('<Shift-Button-1>', lambda event: show_image(image_filepath))
    img_info.place(x=0, y=0, height=INFO_IMG_SZ, width=INFO_IMG_SZ)

    # Text box to show the selected image info
    text_info_height = GRID_IMG_SZ * ROW_NBR - INFO_IMG_SZ + (BORDER * 2 * ROW_NBR)
    text_info = tk.Text(info_frame, name='text_info',
                        bg=BG_COLOR, fg=FONT_COLOR,
                        selectbackground=FONT_COLOR, selectforeground=BG_COLOR,
                        borderwidth=0, padx=10, pady=10)
    text_info.bind('<ButtonRelease-1>', lambda event, clip='info_text': copy_to_clipboard(event, clip))

    text_info.insert('insert', TEXT_INFO_DEFAULT)
    text_info.place(x=0, y=INFO_IMG_SZ, height=text_info_height, width=INFO_IMG_SZ)
    text_info['state'] = 'disable'

    # Frame for the image grid
    frame_canvas = tk.Frame(frame_main, bg=BG_COLOR)
    frame_canvas.grid(row=0, column=0, sticky='nw')
    frame_canvas.grid_rowconfigure(0, weight=1)
    frame_canvas.grid_columnconfigure(0, weight=1)
    frame_canvas.grid_propagate(False)

    # Add a canvas in that frame
    canvas = tk.Canvas(frame_canvas, bg=BG_COLOR, borderwidth=0, highlightthickness=0)
    canvas.bind_all('<MouseWheel>', on_mousewheel)
    canvas.bind_all("<Button-4>", on_mousewheel)
    canvas.bind_all("<Button-5>", on_mousewheel)

    canvas.grid(row=0, column=0, sticky='news')

    # Create a frame to contain the buttons
    frame_buttons = tk.Frame(canvas, bg=BG_COLOR)
    canvas.create_window((0, 0), window=frame_buttons, anchor='nw')

    # Link a scrollbar to the canvas
    vsb = tk.Scrollbar(frame_canvas, orient='vertical', command=canvas.yview)
    vsb.grid(row=0, column=1, sticky='ns')
    canvas.configure(yscrollcommand=vsb.set)

    # Get image file names
    files = get_image_paths()
    image_list_master = []
    for file in files:
        image_list_master.append([None, None, None, None, file, None])
    image_list = image_list_master

    # Make the buttons
    grid_buttons()

    # Resize the canvas and frame
    grid_width = (COL_NBR * GRID_IMG_SZ + (BORDER * 2 * COL_NBR)) + vsb.winfo_width()
    grid_height = ROW_NBR * GRID_IMG_SZ + (BORDER * 2 * ROW_NBR)
    frame_canvas.config(width=grid_width, height=grid_height)

    # Frame for the search and explorer
    bottom_frame = tk.Frame(frame_all, bg=BG_COLOR, height=BUTT_HEIGHT)
    bottom_frame.grid(row=2, column=0, sticky='news')

    # Frame for the search
    search_frame = tk.Frame(bottom_frame, bg=BG_COLOR)
    search_frame.place(x=0, height=BUTT_HEIGHT, width=grid_width)

    # Button to expose
    brd_bt_expose = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_expose.grid(row=0, column=0, sticky='news')
    butt_expose = tk.Button(brd_bt_expose, text=' expose ', bd=0,
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_expose.bind('<Return>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<space>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<Button-1>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<Shift-Button-1>', lambda event: expose_images('', ''))
    butt_expose.bind('<Shift-Return>', lambda event: expose_images('', ''))
    butt_expose.bind('<Shift-space>', lambda event: expose_images('', ''))
    butt_expose.pack(expand=True, fill='both', pady=1, padx=1)

    # Button to search
    brd_bt_search = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_search.grid(row=0, column=1, sticky='news')
    butt_search = tk.Button(brd_bt_search, text=' search ', bd=0,
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_search.bind('<Return>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<space>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<Button-1>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<Shift-Button-1>', lambda event: search_images('', ''))
    butt_search.bind('<Shift-Return>', lambda event: search_images('', ''))
    butt_search.bind('<Shift-space>', lambda event: search_images('', ''))
    butt_search.pack(expand=True, fill='both', pady=1, padx=1)

    # Search entry box - placed here to maintain the TAB order
    brd_ent_search = tk.Frame(search_frame, bg=BG_COLOR)
    brd_ent_search.grid(row=0, column=2, sticky='nwes')
    entry_search = tk.Entry(brd_ent_search, bg=ACC_COLOR1, fg=FONT_COLOR, bd=0, name='entry_search',
                            selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2)
    entry_search.insert('insert', SEARCH_HELP)
    entry_search.bind('<Button-1>', lambda event: enter_search(entry_search.get()))
    entry_search.bind('<Return>', lambda event: search_images(entry_search.get(), combo_params.get()))
    entry_search.bind('<Shift-Return>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    entry_search.pack(expand=True, fill='both', pady=1, padx=1)

    # Search parameters
    brd_cb_param = tk.Frame(search_frame, bg=BG_COLOR)
    brd_cb_param.grid(row=0, column=3, sticky='sne')
    combo_params = ttk.Combobox(brd_cb_param, values=TEXT_PARS, name='combo_box')
    combo_params.current(0)
    combo_params.pack(expand=True, fill='both', pady=1, padx=1)
    combo_params.bind("<<ComboboxSelected>>", lambda event: combo_params.selection_clear())
    style = ttk.Style()
    style.theme_use('default')
    style.configure('TCombobox', relief='flat', background=FONT_COLOR, foreground=BG_COLOR,
                    fieldbackground=ACC_COLOR1, selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2)
    root.option_add('*TCombobox*Listbox*Background', FONT_COLOR)
    root.option_add('*TCombobox*Listbox*Foreground', BG_COLOR)
    root.option_add('*TCombobox*Listbox*selectBackground', ACC_COLOR1)
    root.option_add('*TCombobox*Listbox*selectForeground', BG_COLOR)

    search_frame.grid_columnconfigure(0, weight=0)
    search_frame.grid_columnconfigure(1, weight=0)
    search_frame.grid_columnconfigure(2, weight=1)
    search_frame.grid_columnconfigure(3, weight=0)

    # Button to open folder containing image
    folder_butt_x = grid_width
    brd_bt_folder = tk.Frame(bottom_frame, bg=BG_COLOR)
    brd_bt_folder.place(x=folder_butt_x, width=INFO_IMG_SZ)
    butt_folder = tk.Button(brd_bt_folder, text='show in folder', bd=0, command=lambda: explore_folder(image_filepath),
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_folder.pack(expand=True, fill='both', pady=1, padx=1)

    # Popup menu
    pop_menu = tk.Menu(root, tearoff=0, relief='flat', bg=FONT_COLOR,
                       activebackground=ACC_COLOR1, activeforeground=BG_COLOR, disabledforeground=FONT_COLOR,
                       borderwidth=0, activeborderwidth=0)
    pop_menu.add_separator()
    pop_menu.add_separator()
    pop_menu.add_command(label='open internal', command=lambda: menu_items(0))
    pop_menu.add_command(label='open in system', command=lambda: menu_items(1))
    pop_menu.add_command(label='show in folder', command=lambda: menu_items(2))
    pop_menu.add_command(label='copy information', command=lambda: menu_items(3))
    pop_menu.add_command(label='copy to folder', command=lambda: menu_items(4))

    # Adjustments for MacOS
    lbl_path.config(highlightbackground=BG_COLOR)
    butt_path.config(highlightbackground=BG_COLOR)
    butt_refr.config(highlightbackground=BG_COLOR)
    butt_open.config(highlightbackground=BG_COLOR)
    butt_conf.config(highlightbackground=BG_COLOR)
    butt_folder.config(highlightbackground=BG_COLOR)
    butt_search.config(highlightbackground=BG_COLOR)
    butt_expose.config(highlightbackground=BG_COLOR)
    text_info.config(highlightbackground=BG_COLOR)
    entry_search.config(highlightbackground=BG_COLOR)

    # Launch the GUI
    root.after(50, lambda: first_run())
    root.mainloop()


root = tk.Tk()
root.configure(background='black')
root.title('Diffusion Browser')
root.bind_class("Button", "<Key-Return>", lambda event: event.widget.invoke())
root.resizable(True, True)


main()
