# Diffuse Browser v3.0 (beta).
# Fred Rique (c) 2022 - 2024.
# github.com/farique1/diffusion-browser
# An easy way to view embedded image metadata of most AI generators.

# CHANGES
#   ALT+... > Search or expose exact
#   CONTROL+ALT+... > Search or expose exact inverted
#   HOME > Go to the top of the grid
#   END > Go to the bottom of the grid
#   SHIFT+UP > Go to the image one page above
#   SHIFT+DOWN > Go to the image one page below
#   CONTROL+UP > Go to the first image
#   CONTROL+DOWN > Go to the last image
#   Searching using PATH as a parameter will normalize the path

# FIX / ADD
#   Sometimes when searching for a word and after it sorting and overlaying,
#      the overlaying stops working on all shown images. (thesis: maybe it is
#      only overlaying the images that are "visible" on the grid if the grid
#      did not had been reduced by the search. Images that are farthest from
#      the first searched image than the height of the grid in images)
#   Searching for path will not set the path combobox to all folders
#   Use im.get_format_mimetype() or Image.MIME[img.format] or img.format
#      to determine the image type. Also to load images regardless of extension
#   Undock and dock the image and embedded info viewers (see teste.py)
#   Add active status to the folders
#   Scrollbar on the information view window
#   Multiple projects

import bz2
import os
import glob
import json
import math
import time
import pickle
import shutil
import platform
import datetime
import threading
import subprocess
import collections
import configparser
import tkinter as tk
from operator import itemgetter
from collections import OrderedDict

from tkinter.colorchooser import askcolor
from tkinter import ttk, font, filedialog
from PIL import Image, ImageTk, ImageOps, UnidentifiedImageError

# Constants
COL_NBR = 5
ROW_NBR = 5
GRID_IMG_SZ = 100
INFO_IMG_SZ = 250
BUTT_HEIGHT = 26
FONT_NAME = 'Tahoma'
FONT_SIZE = 10
FONT_WEIGHT = 'normal'
BG_COLOR = 'black'
FONT_COLOR = 'teal'
ACC_COLOR1 = 'goldenrod'
ACC_COLOR2 = 'grey70'
ALERT_COLOR = 'dark red'
# TOP_PATH = 'D:/Stable Diffusion WebUI/stable-diffusion-webui/outputs/test'

FONT = [FONT_NAME, FONT_SIZE, FONT_WEIGHT]

BORDER = 1
PROGRAM_NAME = 'Diffusion\nBrowser'
ALL_PARAMETERS = 'all parameters'
ALL_FOLDERS = 'all paths'
SEARCH_HELP = 'enter search'
TEXT_INFO_DEFAULT = ('Diffusion Browser v3.0\n'
                     'github.com/farique1/diffusion-browser\n'
                     '(c) Fred Rique 2022 - 2024\n\n'
                     'Browse pictures and metadata generated by Stable Diffusion.\n'
                     'Works with embedded data from most generators in the style of Automatic1111.\n'
                     'Converter provided for Fooocus log.html')

LOCAL_PATH = os.path.split(os.path.abspath(__file__))[0]
PROJECT_PATH = 'Projects'
default_project = 'default'
INI_FILE = os.path.join(LOCAL_PATH, PROJECT_PATH, default_project, 'difbrowser.ini')
PARAMETERS_FILE = os.path.join(LOCAL_PATH, PROJECT_PATH, default_project, 'parameters.txt')
DATA_FILE = os.path.join(LOCAL_PATH, PROJECT_PATH, default_project, 'data.pickle')
FOLDERS_FILE = os.path.join(LOCAL_PATH, PROJECT_PATH, default_project, 'folders.json')

OS = platform.system()

with open(PARAMETERS_FILE, 'r') as file:
    TEXT_PARS = file.read().splitlines()

COMBO_VALUES = TEXT_PARS
COMBO_VALUES.insert(0, ALL_PARAMETERS)

# Variable initialization
folders = []
image_list = []
new_pars = []
is_overlay = ''
current_index = 0
current_seed = ''
current_image = ''
sort_reverse = True
time_format = '%Y-%m-%d %H:%M:%S'

# .ini file handling
ini_path = os.path.join(LOCAL_PATH, INI_FILE)
config_ini = configparser.ConfigParser()
if os.path.isfile(ini_path):
    try:
        config_ini.read(ini_path)
        config_sec = config_ini['CONFIGS']
        COL_NBR = int(config_sec.get('number_of_columns'))
        ROW_NBR = int(config_sec.get('number_of_lines'))
        GRID_IMG_SZ = int(config_sec.get('grid_image_size'))
        INFO_IMG_SZ = int(config_sec.get('preview_image_size'))
        BUTT_HEIGHT = int(config_sec.get('button_height'))
        FONT_NAME = config_sec.get('font_name')
        FONT_SIZE = int(config_sec.get('font_size'))
        FONT_WEIGHT = config_sec.get('font_weight')
        BG_COLOR = config_sec.get('background_color')
        FONT_COLOR = config_sec.get('main_color')
        ACC_COLOR1 = config_sec.get('accent_color_1')
        ACC_COLOR2 = config_sec.get('accent_color_2')
        ALERT_COLOR = config_sec.get('alert_color')
        # TOP_PATH = config_sec.get('default_path')

        FONT = [FONT_NAME, FONT_SIZE, FONT_WEIGHT]
        # TOP_PATH = os.path.normpath(TOP_PATH)

    except (ValueError, configparser.NoOptionError) as e:
        print(f'.INI file problem: {str(e)}')
        raise SystemExit(0)

# Initialize
root = tk.Tk()

root.configure(background='black')
root.title('Diffusion Browser')
root.protocol("WM_DELETE_WINDOW", lambda: root.destroy())
root.bind_class("Button", "<Key-Return>", lambda event: event.widget.invoke())

if OS == 'Linux':
    root.resizable(True, True)
else:
    root.resizable(True, True)


def resize_image(image, maxsize):
    '''Resize image maintaining aspect ratio and maximum size'''

    r1 = image.size[0] / maxsize[0]  # width ratio
    r2 = image.size[1] / maxsize[1]  # height ratio
    ratio = max(r1, r2)
    newsize = (int(image.size[0] / ratio), int(image.size[1] / ratio))
    image = image.resize(newsize, Image.Resampling.LANCZOS)
    return image


def render_buttons(visible_buttons):
    # print(f'Started - {threading.current_thread()}')
    for button_data in visible_buttons:

        button = button_data['button']
        if not button:
            return

        image = Image.open(button_data['file'])
        image = resize_image(image, (GRID_IMG_SZ, GRID_IMG_SZ))
        overlay = ''

        if is_overlay:
            image = image.convert("L")
            image = ImageOps.colorize(image, black=BG_COLOR, white=FONT_COLOR)
            embed_dict = button_data['dic_info']
            overlay = embed_dict.get(is_overlay, '')

        image = ImageTk.PhotoImage(image)
        button.config(image=image, text=overlay)
        button.image = image


def refresh_images(x, y):
    '''Refresh images on the grid buttons'''
    if not image_list:
        return

    vsb.set(x, y)

    canvas_height = canvas.winfo_height()
    y_srt = canvas.yview()[0]
    y_end = canvas.yview()[1]
    y_len = y_end - y_srt
    total_height = canvas_height / y_len
    canvas_y_top = int(total_height * y_srt / (GRID_IMG_SZ + BORDER * 2))
    canvas_y_bot = int(total_height * y_end / (GRID_IMG_SZ + BORDER * 2)) + 1

    for r in range(canvas_y_top, canvas_y_bot):
        slice_start = r * COL_NBR
        slice_end = r * COL_NBR + COL_NBR

        visible_buttons = []
        for button_data in image_list[slice_start:slice_end]:
            if not button_data['has_image']:
                visible_buttons.append(button_data)
                button_data['has_image'] = True

        if visible_buttons:
            t = threading.Thread(target=render_buttons, args=(visible_buttons,))
            t.daemon = True
            t.start()


def on_mousewheel(event):
    '''Handles mouse wheel'''

    if OS == 'Linux':
        y_steps = 5
        if event.num == 4:
            y_steps *= -1
    elif OS == 'Darwin':
        y_steps = event.delta
    elif OS == 'Windows':
        y_steps = int(-1 * (event.delta / 120))

    if 'buttons_frame' in str(event.widget):
        canvas.yview_scroll(y_steps, 'units')
    # elif 'folders_frame' in str(event.widget):
    #     folders_canvas.yview_scroll(y_steps, 'units')


def click_grid_image(idx):
    '''Handles clicking on a image on the grid'''

    global current_seed
    global prev_button
    global current_index

    button = image_list[idx]['button']
    embed_text = image_list[idx]['txt_info']

    image = Image.open(image_list[idx]['file'])

    # image_keep = button.image
    prev_button.config(bg=BG_COLOR, width=GRID_IMG_SZ, height=GRID_IMG_SZ, bd=0, relief='flat')
    button.config(bg=ACC_COLOR1, width=GRID_IMG_SZ - 6, height=GRID_IMG_SZ - 6, bd=3, relief='ridge')

    # button.update()
    button.focus_set()

    image = resize_image(image, (INFO_IMG_SZ, INFO_IMG_SZ))
    image = ImageTk.PhotoImage(image)
    img_info['image'] = image
    img_info.image = image
    img_info.config(bg=BG_COLOR)

    # Get tag information for colorizing
    matches = []
    for i, line in enumerate(embed_text.splitlines(), 1):
        for tag in TEXT_PARS:
            tag_colon = f'{tag}:'
            if line.startswith(tag_colon):
                start = f'{str(i)}.{len(tag_colon)}'
                end = f'{str(i)}.{len(line)}'
                content = line[len(tag_colon):]
                matches.append((tag_colon, start, end, content))

    # Draw text
    text_info['state'] = 'normal'
    text_info.delete('1.0', 'end')
    text_info.insert('insert', embed_text)
    for match in matches:
        if match[0].startswith('seed:'):
            current_seed = match[3]
        color = ACC_COLOR2
        if match[3].strip().replace('.', '').isdigit() \
                or match[3].strip().replace(' x ', '').isdigit()  \
                or match[3].strip().replace(' ', '').isdigit():
            color = ACC_COLOR1
        if match[0].startswith('embedded info'):
            color = ACC_COLOR2
        text_info.tag_add(match[0], match[1], match[2])
        text_info.tag_config(match[0], foreground=color)
    text_info['state'] = 'disable'

    # Give a little time for Python to come to it's senses
    time.sleep(0.05)

    prev_button = button

    current_index = idx


def grid_keys(event, delta, absolute=False):
    '''Navigate grid with the arrow keys.
    event: TK internal
    delta: Image amout to jump
    absolute: if the jump is relative or absolute (to the first or last image)'''

    global current_index

    prev_current_index = current_index

    if absolute:
        current_index = (len(image_list) - 1) * delta
    else:
        current_index = current_index + delta

    if (current_index < 0) or (current_index > len(image_list) - 1) or \
            not image_list[current_index]['search']:
        current_index = prev_current_index
        return

    image_amount = len(image_list)
    image_y = math.floor(current_index / COL_NBR)
    rows = math.ceil(image_amount / COL_NBR)
    button = image_list[current_index]['button']
    button_y = button.winfo_y()
    canvas_height = canvas.winfo_height()
    y_srt = canvas.yview()[0]
    y_end = canvas.yview()[1]
    y_len = y_end - y_srt
    total_height = int(canvas_height / y_len)
    canvas_y_top = int(total_height * y_srt)
    canvas_y_bot = int(total_height * y_end)
    canvas_position = image_y / rows
    img_len = 1 / rows

    # Only move if selection is outside the grid frame
    if (button_y > canvas_y_bot - GRID_IMG_SZ):
        canvas.yview_moveto(canvas_position - y_len + img_len)
    if (button_y <= canvas_y_top):
        canvas.yview_moveto(canvas_position)

    button.invoke()
    button.focus_set()


def maintain_aspect_ratio(event, original, c_full_img, aspect_ratio):
    '''Maintains aspect ratio when resizing the image window'''

    new_aspect_ratio = event.width / event.height
    if new_aspect_ratio > aspect_ratio:
        desired_width = event.width
        desired_height = int(event.width / aspect_ratio)
    else:
        desired_height = event.height
        desired_width = int(event.height * aspect_ratio)

    if event.width != desired_width or event.height != desired_height:
        try:
            event.widget.geometry(f'{desired_width}x{desired_height}')
            size = (desired_width, desired_height)
            resized = original.resize(size, Image.Resampling.LANCZOS)
            image = ImageTk.PhotoImage(resized)
            c_full_img.delete('IMG')
            c_full_img.create_image(0, 0, image=image, anchor='nw', tags='IMG')
            c_full_img.image = image
        except AttributeError:
            pass
        return 'break'


def show_full_image(idx):
    '''Handles clicking on the image preview'''

    if idx is None:
        return

    image_window = tk.Toplevel()
    image_window.title(f'{current_seed.strip()} - {image_list[idx]["file"]}')

    original = Image.open(image_list[idx]['file'])
    # original = image_list[idx]['orig_image']

    # Prevent showing images bigger than the screen size
    max_width = min(original.size[0], image_window.winfo_screenwidth())
    max_height = min(original.size[1], image_window.winfo_screenheight())
    original = resize_image(original, (max_width, max_height))

    image = ImageTk.PhotoImage(original)

    x = root.winfo_x()
    y = root.winfo_y() + 30 + BUTT_HEIGHT
    dimensions = f'{image.width()}x{image.height()}+{x}+{y}'
    image_window.geometry(dimensions)

    frame = tk.Frame(image_window)
    frame.columnconfigure(0, weight=1)
    frame.rowconfigure(0, weight=1)

    c_full_img = tk.Canvas(image_window, bd=0, highlightthickness=0)
    c_full_img.create_image(0, 0, image=image, anchor='nw', tags='IMG')
    c_full_img.image = image
    c_full_img.grid(row=0, sticky='news')
    c_full_img.pack(fill='both', expand=1)

    image_window.update()
    width = image_window.winfo_width()
    height = image_window.winfo_height()
    image_window.bind('<Configure>', lambda event: maintain_aspect_ratio(event, original, c_full_img, width / height))
    image_window.bind('<Escape>', lambda event: image_window.destroy())


def show_image(idx):

    if idx is None:
        return

    path = image_list[idx]['file']

    if OS == 'Linux':
        default_app = subprocess.run(['xdg-mime', 'query', 'default', 'inode/directory'],
                                     stdout=subprocess.PIPE).stdout.decode('utf-8').strip()

        if default_app == 'org.kde.dolphin.desktop':
            subprocess.Popen(['dolphin', path])
        else:
            default_app == 'nautilus.desktop'
            subprocess.Popen(['nautilus', path])
    elif OS == 'Darwin':
        subprocess.Popen(["open", path])
    else:
        subprocess.Popen(["explorer", '/open,', path])


def open_config():
    '''Main configuration window'''

    global config
    global conf_entries
    global conf_labels
    global bt_color_list
    global dummy

    # Create window
    config = tk.Toplevel()
    config.title('Configuration')
    config.grab_set()
    config.focus_set()
    config.option_add('*font', FONT)
    config.resizable(True, True)
    config_frame = tk.Frame(config, bg=BG_COLOR)
    config_frame.pack(expand=True, fill='both')

    # Blank label to separate interface fro window top
    dummy = tk.Label(config_frame, text=' ', bg=BG_COLOR, fg=FONT_COLOR)
    dummy.grid(row=0)

    config_frame.grid_columnconfigure(0, weight=0)
    # config_frame.grid_columnconfigure(1, weight=0)
    config_frame.grid_columnconfigure(1, weight=1)

    # Interface widgets content
    conf_cont = [['number of columns', COL_NBR, None, None],
                 ['number of rows', ROW_NBR, None, None],
                 ['gird image size', GRID_IMG_SZ, None, None],
                 ['preview image size', INFO_IMG_SZ, None, None],
                 ['button height', BUTT_HEIGHT, None, None],
                 ['font name', FONT[0], 'get', None, font_requester],
                 ['font size', FONT[1], 'get', None, font_requester],
                 ['font weight', FONT[2], 'get', None, font_requester],
                 ['background color', BG_COLOR, 'pick', BG_COLOR, pick_color],
                 ['main color', FONT_COLOR, 'pick', FONT_COLOR, pick_color],
                 ['accent color 1', ACC_COLOR1, 'pick', ACC_COLOR1, pick_color],
                 ['accent color 2', ACC_COLOR2, 'pick', ACC_COLOR2, pick_color],
                 ['alert color', ALERT_COLOR, 'pick', ALERT_COLOR, pick_color]]
    # ['Default path', TOP_PATH, 'get', None, change_config_path]]

    brd_bt_color_list = []
    bt_color_list = []
    conf_entries = []
    conf_labels = []
    for r, cont in enumerate(conf_cont, 1):
        label = tk.Label(config_frame, text=cont[0], bg=BG_COLOR, fg=FONT_COLOR)
        label.grid(row=r, column=0, sticky='e', padx=(20, 0))
        conf_labels.append(label)

        brd_bt_tbox = tk.Frame(config_frame, bg=BG_COLOR)
        brd_bt_tbox.grid(row=r, column=1, sticky='wens')
        tbox = tk.Entry(brd_bt_tbox, bg=ACC_COLOR1, fg=BG_COLOR, width=30, bd=0, name=str(r),
                        selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2)
        tbox.insert('insert', cont[1])
        tbox.pack(expand=True, fill='both', pady=1, padx=1)
        conf_entries.append(tbox)

        config_frame.rowconfigure(r, weight=1)

        if r > 8 and r < 14:
            tbox.bind('<Return>', lambda event, nbr=r: change_color(nbr))
            tbox.bind('<FocusOut>', lambda event, nbr=r: change_color(nbr))

        if (r > 0 and r < 6):
            tbox.bind('<Return>', lambda event, widget=tbox: test_int(widget))
            tbox.bind('<FocusOut>', lambda event, widget=tbox: test_int(widget))

        if cont[2]:
            brd_bt_action = tk.Frame(config_frame, bg=BG_COLOR)
            brd_bt_action.grid(row=r, column=2, sticky='wens')
            action = tk.Button(brd_bt_action, text=cont[2], bd=0,
                               bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
            action.bind('<ButtonRelease-1>', lambda event, func=cont[4], nbr=r, cur_col=cont[3]: func(nbr, cur_col))
            action.pack(expand=True, fill='both', pady=1, padx=1)

        if cont[3]:
            brd_bt_color = tk.Frame(config_frame, bg=BG_COLOR)
            brd_bt_color.grid(row=r, column=3, sticky='wens', padx=(0, 20))
            color = tk.Button(brd_bt_color, text='   ', bd=0, bg=cont[3], activebackground=cont[3])
            color.pack(expand=True, fill='both', pady=1, padx=1)
            color.bind('<ButtonRelease-1>', lambda event, func=cont[4], nbr=r, cur_col=cont[3]: func(nbr, cur_col))
            brd_bt_color_list.append(brd_bt_color)
            bt_color_list.append(color)

    brd_bt_color_list[0]['bg'] = FONT_COLOR

    # Align path text to the right
    # conf_entries[13].xview_moveto(1)

    conf_entries[6].bind('<Return>', lambda e: change_button_height(conf_entries[6].get()))
    conf_entries[6].bind('<FocusOut>', lambda e: change_button_height(conf_entries[6].get()))

    conf_entries[7].bind('<Return>', lambda e: test_weight(conf_entries[7].get()))
    conf_entries[7].bind('<FocusOut>', lambda e: test_weight(conf_entries[7].get()))

    # conf_entries[r - 1].bind('<Return>', lambda e, nbr=r: test_path(nbr, conf_entries[r - 1].get()))
    # conf_entries[r - 1].bind('<FocusOut>', lambda e, nbr=r: test_path(nbr, conf_entries[r - 1].get()))

    btn_frame = tk.Frame(config_frame, bg=BG_COLOR)
    btn_frame.grid(row=r + 1, columnspan=4, sticky='ew', pady=(20, 20))
    btn_frame.grid_columnconfigure(0, weight=1)
    btn_frame.grid_columnconfigure(1, weight=1)

    brd_bt_btn_accept = tk.Frame(btn_frame, bg=BG_COLOR)
    brd_bt_btn_accept.grid(row=0, column=0, sticky='wens', padx=(20, 0))
    btn_accept = tk.Button(brd_bt_btn_accept, text='OK (restart)',
                           bg=FONT_COLOR, fg=BG_COLOR, bd=0, activebackground=ACC_COLOR1)
    btn_accept['command'] = lambda conf_entries=conf_entries: accept_config(btn_accept, conf_entries)
    btn_accept.pack(expand=True, fill='both', pady=1, padx=1)

    brd_btn_cancel = tk.Frame(btn_frame, bg=BG_COLOR)
    brd_btn_cancel.grid(row=0, column=1, sticky='wens', padx=(0, 20))
    btn_cancel = tk.Button(brd_btn_cancel, text='cancel', bd=0, command=config.destroy,
                           bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    btn_cancel.pack(expand=True, fill='both', pady=1, padx=1)

    config.update()
    x = root.winfo_x() + root.winfo_width() - config.winfo_width()
    y = root.winfo_y() + 30 + BUTT_HEIGHT
    config.geometry(f'+{x}+{y}')


def test_weight(weight):
    weight = weight.strip()
    if weight != 'normal' and weight != 'bold' and weight != 'italic' and weight != '':
        conf_entries[7].config(bg=ALERT_COLOR)
    else:
        conf_entries[7].config(bg=ACC_COLOR1)


def test_int(widget):
    entry = widget.get()
    if not entry.isnumeric():
        widget.config(bg=ALERT_COLOR)
    else:
        widget.config(bg=ACC_COLOR1)


def change_button_height(size):
    '''Update the button height configuration box'''

    test_int(conf_entries[6])

    if conf_entries[6]['bg'] != ALERT_COLOR:
        conf_entries[4].delete(0, 'end')
        conf_entries[4].insert('insert', int(int(size) * 2.5))


def pick_color(r, cur_col):
    '''Open a color picker'''

    # Open an inactive window to be able to disable the main interface
    dummy_window = tk.Toplevel()
    dummy_window.withdraw()
    config.grab_release()
    dummy_window.grab_set()

    conf_entries[r - 1].delete(0, 'end')
    color = askcolor(color=cur_col, title=conf_labels[r - 1]['text'], parent=config)[1]

    if not color:
        color = cur_col
    conf_entries[r - 1].insert('insert', color)

    dummy_window.destroy()
    config.grab_set()

    change_color(r)


def change_color(r):
    '''Change the selected color'''

    if r < 9 or r > 13:
        return
    try:
        bt_color_list[r - 9]['bg'] = conf_entries[r - 1].get()
        conf_entries[r - 1].config(bg=ACC_COLOR1)
    except tk.TclError:
        conf_entries[r - 1].config(bg=ALERT_COLOR)


def accept_config(button, conf_entries):
    '''Close the configuration window applying changes'''

    global COL_NBR
    global ROW_NBR
    global GRID_IMG_SZ
    global INFO_IMG_SZ
    global BUTT_HEIGHT
    global FONT
    global BG_COLOR
    global FONT_COLOR
    global ACC_COLOR1
    global ACC_COLOR2
    global ALERT_COLOR
    # global TOP_PATH

    change_button_height(conf_entries[6].get())

    button.focus_set()

    config.update()

    if conf_entries[0]['bg'] != ALERT_COLOR:
        COL_NBR = int(conf_entries[0].get())
    if conf_entries[1]['bg'] != ALERT_COLOR:
        ROW_NBR = int(conf_entries[1].get())
    if conf_entries[2]['bg'] != ALERT_COLOR:
        GRID_IMG_SZ = int(conf_entries[2].get())
    if conf_entries[3]['bg'] != ALERT_COLOR:
        INFO_IMG_SZ = int(conf_entries[3].get())
    if conf_entries[4]['bg'] != ALERT_COLOR:
        BUTT_HEIGHT = int(conf_entries[4].get())
    if conf_entries[6]['bg'] != ALERT_COLOR \
            and conf_entries[7]['bg'] != ALERT_COLOR:
        FONT = (conf_entries[5].get(),
                int(conf_entries[6].get()),
                conf_entries[7].get())
        BG_COLOR = bt_color_list[0]['bg']
        FONT_COLOR = bt_color_list[1]['bg']
        ACC_COLOR1 = bt_color_list[2]['bg']
        ACC_COLOR2 = bt_color_list[3]['bg']
        ALERT_COLOR = bt_color_list[4]['bg']
    # if conf_entries[13]['bg'] != ALERT_COLOR:
    #     TOP_PATH = conf_entries[13].get()

    FONT_NAME = FONT[0]
    FONT_SIZE = FONT[1]
    FONT_WEIGHT = FONT[2]

    t_scr_width = root.winfo_screenwidth() * 0.9
    t_scr_height = root.winfo_screenheight() * 0.9

    # Check if the interface will fit on the current screen size
    if (COL_NBR * GRID_IMG_SZ + INFO_IMG_SZ) > t_scr_width \
            or (ROW_NBR * GRID_IMG_SZ) > t_scr_height \
            or INFO_IMG_SZ > t_scr_height:
        tk.messagebox.showinfo(title='Bad configuration',
                               message='Interface elements too big or too many.\n'
                                       'Will not fit within 90% of the screen.',
                               parent=config)
        return

    if not config_ini.has_section('CONFIGS'):
        config_ini.add_section('CONFIGS')
    config_ini.set('CONFIGS', 'number_of_columns', str(COL_NBR))
    config_ini.set('CONFIGS', 'number_of_lines', str(ROW_NBR))
    config_ini.set('CONFIGS', 'grid_image_size', str(GRID_IMG_SZ))
    config_ini.set('CONFIGS', 'preview_image_size', str(INFO_IMG_SZ))
    config_ini.set('CONFIGS', 'button_height', str(BUTT_HEIGHT))
    config_ini.set('CONFIGS', 'font_name', FONT_NAME)
    config_ini.set('CONFIGS', 'font_size', str(FONT_SIZE))
    config_ini.set('CONFIGS', 'font_weight', FONT_WEIGHT)
    config_ini.set('CONFIGS', 'background_color', BG_COLOR)
    config_ini.set('CONFIGS', 'main_color', FONT_COLOR)
    config_ini.set('CONFIGS', 'accent_color_1', ACC_COLOR1)
    config_ini.set('CONFIGS', 'accent_color_2', ACC_COLOR2)
    config_ini.set('CONFIGS', 'alert_color', ALERT_COLOR)
    # config_ini.set('CONFIGS', 'default_path', TOP_PATH)

    with open(ini_path, 'w') as configfile:
        config_ini.write(configfile)

    config.destroy()
    # update_grid()
    reset_interface()


def font_requester(r, cur_col):
    '''Create a font requester'''

    dummy.focus_set()
    config.update()

    if conf_entries[5]['bg'] == ALERT_COLOR \
            or conf_entries[6]['bg'] == ALERT_COLOR \
            or conf_entries[7]['bg'] == ALERT_COLOR:
        return

    # global font_box
    global font_preview
    global size_entry
    global font_temp
    global folders_req

    font_temp = [conf_entries[5].get(),
                 int(conf_entries[6].get()),
                 conf_entries[7].get()]

    folders_req = tk.Toplevel()
    folders_req.title('Font')

    available_fonts = font.families()
    available_fonts = sorted(available_fonts)

    font_box = tk.Listbox(folders_req, highlightthickness=0, relief='flat', name='font_list',
                          bg=ACC_COLOR1, fg=BG_COLOR, selectbackground=FONT_COLOR)
    font_box.grid(row=0, columnspan=3, sticky='news')
    font_box.option_add('font', FONT)

    sb = tk.Scrollbar(folders_req, orient='vertical')
    sb.grid(row=0, column=3, sticky='news')

    font_box.configure(yscrollcommand=sb.set)
    sb.config(command=font_box.yview)

    config.grab_release()
    folders_req.grab_set()
    folders_req.focus_set()

    for fonts in available_fonts:
        font_box.insert('end', fonts)

    # Duplicate the last element to prevent down key from overflowing the listbox items
    available_fonts.append(available_fonts[-1])

    font_box.bind("<ButtonRelease-1>", lambda e: change_font(
                  [available_fonts[font_box.curselection()[0]], int(size_entry.get()), font_temp[2]]))

    font_box.bind("<Up>", lambda e: change_font(
                  [available_fonts[font_box.curselection()[0] - 1], int(size_entry.get()), font_temp[2]]))

    font_box.bind("<Down>", lambda e: change_font(
                  [available_fonts[font_box.curselection()[0] + 1], int(size_entry.get()), font_temp[2]]))

    weight_list = []
    brd_norm_butt = tk.Frame(folders_req, bg=BG_COLOR)
    brd_norm_butt.grid(row=1, column=0, sticky='nsew')
    norm_butt = tk.Button(brd_norm_butt, text="normal", bg=FONT_COLOR, fg=BG_COLOR,
                          activebackground=ACC_COLOR1, bd=0, command=lambda: font_weight(0, weight_list))
    norm_butt.pack(expand=True, fill='both', pady=1, padx=1)
    weight_list.append([norm_butt, 'normal'])

    brd_norm_bold = tk.Frame(folders_req, bg=BG_COLOR)
    brd_norm_bold.grid(row=1, column=1, sticky='nsew')
    bold_butt = tk.Button(brd_norm_bold, text="bold", bg=FONT_COLOR, fg=BG_COLOR,
                          activebackground=ACC_COLOR1, bd=0, command=lambda: font_weight(1, weight_list))
    bold_butt.pack(expand=True, fill='both', pady=1, padx=1)
    weight_list.append([bold_butt, 'bold'])

    brd_norm_ital = tk.Frame(folders_req, bg=BG_COLOR)
    brd_norm_ital.grid(row=1, column=2, columnspan=2, sticky='nsew')
    ital_butt = tk.Button(brd_norm_ital, text="italic", bg=FONT_COLOR, fg=BG_COLOR,
                          activebackground=ACC_COLOR1, bd=0, command=lambda: font_weight(2, weight_list))
    ital_butt.pack(expand=True, fill='both', pady=1, padx=1)
    weight_list.append([ital_butt, 'italic'])

    size_entry = tk.Entry(folders_req, text="cancel", bd=0, bg=ACC_COLOR1, fg=BG_COLOR)
    size_entry.delete(0, 'end')
    size_entry.insert('insert', conf_entries[6].get())
    size_entry.bind('<Return>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
    size_entry.bind('<Tab>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
    size_entry.bind('<FocusOut>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
    size_entry.grid(row=2, column=0, columnspan=2, sticky='nsew')

    brd_siz_frm = tk.Frame(folders_req, bg=BG_COLOR)
    brd_siz_frm.grid(row=2, column=2, columnspan=2, sticky='nsew')

    brd_siz_min = tk.Frame(brd_siz_frm, bg=BG_COLOR)
    brd_siz_min.grid(row=0, column=0, sticky='nsew')
    size_min = tk.Button(brd_siz_min, text="<", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                         command=lambda: siz_min_pls(-1, size_entry))
    size_min.pack(expand=True, fill='both', pady=1, padx=1)

    brd_siz_pls = tk.Frame(brd_siz_frm, bg=BG_COLOR)
    brd_siz_pls.grid(row=0, column=1, sticky='nsew')
    size_pls = tk.Button(brd_siz_pls, text=">", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                         command=lambda: siz_min_pls(1, size_entry))
    size_pls.pack(expand=True, fill='both', pady=1, padx=1)

    brd_siz_frm.columnconfigure(0, weight=1)
    brd_siz_frm.columnconfigure(1, weight=1)

    brd_ok_butt = tk.Frame(folders_req, bg=BG_COLOR)
    brd_ok_butt.grid(row=3, column=0, columnspan=2, sticky='nsew')
    ok_butt = tk.Button(brd_ok_butt, text="OK", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                        activebackground=ACC_COLOR1, command=accept_font)
    ok_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_cancel_butt = tk.Frame(folders_req, bg=BG_COLOR)
    brd_cancel_butt.grid(row=3, column=2, columnspan=2, sticky='nsew')
    cancel_butt = tk.Button(brd_cancel_butt, text="cancel", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                            activebackground=ACC_COLOR1, command=folders_req.destroy)
    cancel_butt.pack(expand=True, fill='both', pady=1, padx=1)

    font_preview = tk.Entry(folders_req, justify='center', bd=0,
                            bg=BG_COLOR, fg=FONT_COLOR, font=(FONT[0], FONT[1], FONT[2]))
    font_preview.insert('insert', 'Diffusion')
    font_preview.grid(row=4, columnspan=4, sticky='nsew')

    folders_req.rowconfigure(0, weight=1)
    folders_req.columnconfigure(0, weight=1)
    folders_req.columnconfigure(1, weight=1)
    folders_req.columnconfigure(2, weight=1)
    folders_req.columnconfigure(3, weight=0)

    folders_req.resizable(True, True)
    folders_req.update_idletasks()
    font_req_width = int(config.winfo_width() / 2)
    folders_req.geometry(f'{font_req_width}x{config.winfo_height()}+{config.winfo_x()}+{config.winfo_y()}')


def siz_min_pls(delta, entry):
    '''Buttons to change the font size'''

    size = int(entry.get())
    size += delta
    if size < 1:
        size = 1
    entry.delete(0, 'end')
    entry.insert('insert', size)

    change_font([font_temp[0], int(size), font_temp[2]])


def font_weight(weight, weight_list):
    '''Handles clicking on the font weight buttons'''

    global font_temp
    for item in weight_list:
        item[0]['bg'] = FONT_COLOR
        item[0]['fg'] = BG_COLOR

    weight_list[weight][0]['bg'] = BG_COLOR
    weight_list[weight][0]['fg'] = FONT_COLOR

    font_temp[2] = weight_list[weight][1]
    font_temp[1] = int(size_entry.get())

    change_font(font_temp)


def change_font(font_arg):
    '''Change the current font'''

    global font_temp
    font_temp = font_arg
    font_preview.config(font=font_temp)


def accept_font():
    '''Close the font requester accepting the changes'''

    conf_entries[4].delete(0, 'end')
    conf_entries[4].insert('insert', int(int(size_entry.get()) * 2.5))
    conf_entries[5].delete(0, 'end')
    conf_entries[5].insert('insert', font_temp[0])
    conf_entries[6].delete(0, 'end')
    conf_entries[6].insert('insert', size_entry.get())
    conf_entries[7].delete(0, 'end')
    conf_entries[7].insert('insert', font_temp[2])
    config.grab_set()
    config.focus_set()
    folders_req.destroy()


def treeview_sort_column(widget, col, reverse):
    l = [(widget.set(k, col), k) for k in widget.get_children('')]
    l.sort(reverse=reverse)

    for index, (_, k) in enumerate(l):
        widget.move(k, '', index)

    widget.heading(col, command=lambda: treeview_sort_column(widget, col, not reverse))


def add_folder(widget, parent):
    '''Add path'''

    folder_selected = filedialog.askdirectory(parent=parent)

    if folder_selected:
        widget.insert('', 'end', text=('', folder_selected), value=('', folder_selected))


def toggle_subfolders(widget):
    if not widget.selection():
        return

    for item in widget.selection():
        item_values = widget.item(item)['values']
        subfolders = 'YES' if item_values[0] == '' else ''
        widget.item(item, text=(subfolders, item_values[1]), value=(subfolders, item_values[1]))


def treeview_delete(widget, parent):
    if not widget.selection():
        return
    quantity = len(widget.selection())
    message = f'{widget.item(widget.focus())["values"][1]} ' if quantity == 1 else f'{len(widget.selection())} items'
    query = tk.messagebox.askquestion(title='Delete item', message=f'Really delete {message}?', parent=parent)
    if query == 'yes':
        for item in widget.selection():
            widget.delete(item)


def save_folders(widget, parent):
    global folders

    folders = []
    for item in widget.get_children():
        child = widget.item(item)["values"]
        subfolders = '1' if child[0] == 'YES' else '0'
        folders.append((subfolders, child[1]))

    json_object = json.dumps(folders)

    with open(FOLDERS_FILE, "w") as f:
        f.write(json_object)

    parent.destroy()
    update_grid()
    # reset_interface()


def folders_requester():
    '''Create a folders requester'''

    folders_req = tk.Toplevel()
    folders_req.title('Paths')

    root.grab_release()
    folders_req.grab_set()
    folders_req.focus_set()

    folders_tree = ttk.Treeview(folders_req, column=('subf', 'path'), show='headings', height=100)
    folders_tree.heading('#0', text=' \n')
    folders_tree.heading('subf', text='subf', command=lambda: treeview_sort_column(folders_tree, 'subf', False))
    folders_tree.heading('path', text='paths', command=lambda: treeview_sort_column(folders_tree, 'path', False))
    folders_tree.column('subf', width=FONT[1] * 3, stretch='no')
    folders_tree.option_add('*font', FONT)
    folders_tree.grid(row=0, columnspan=4, sticky='news')

    sb_folders = tk.Scrollbar(folders_req, orient='vertical')
    sb_folders.grid(row=0, column=4, sticky='news')
    folders_tree.configure(yscrollcommand=sb_folders.set)
    sb_folders.config(command=folders_tree.yview)

    for folder in folders:
        recursive = 'YES' if folder[0] == '1' else ''
        folders_tree.insert('', 'end', text=(recursive, folder[1]), value=(recursive, folder[1]))

    brd_get_butt = tk.Frame(folders_req, bg=BG_COLOR)
    brd_get_butt.grid(row=2, column=0, sticky='nsew')
    get_butt = tk.Button(brd_get_butt, text="add", bg=FONT_COLOR, fg=BG_COLOR,
                         activebackground=ACC_COLOR1, bd=0)
    get_butt.bind('<Button-1>', lambda event: add_folder(folders_tree, folders_req))
    get_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_open_butt = tk.Frame(folders_req, bg=BG_COLOR)
    brd_open_butt.grid(row=2, column=1, sticky='nsew')
    open_butt = tk.Button(brd_open_butt, text="open", bg=FONT_COLOR, fg=BG_COLOR,
                          activebackground=ACC_COLOR1, bd=0, command=lambda: explore_folder(folders_tree.item(folders_tree.focus())))
    open_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_subf_butt = tk.Frame(folders_req, bg=BG_COLOR)
    brd_subf_butt.grid(row=2, column=2, sticky='nsew')
    subf_butt = tk.Button(brd_subf_butt, text="toggle subfolders", bg=FONT_COLOR, fg=BG_COLOR,
                          activebackground=ACC_COLOR1, bd=0, command=lambda: toggle_subfolders(folders_tree))
    subf_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_del_butt = tk.Frame(folders_req, bg=BG_COLOR)
    brd_del_butt.grid(row=2, column=3, columnspan=2, sticky='nsew')
    del_butt = tk.Button(brd_del_butt, text="delete", bg=ALERT_COLOR, fg=BG_COLOR,
                         activebackground=ACC_COLOR1, bd=0)
    del_butt.bind('<Button-1>', lambda event: treeview_delete(folders_tree, folders_req))
    del_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_ok_butt = tk.Frame(folders_req, bg=BG_COLOR)
    brd_ok_butt.grid(row=3, column=0, columnspan=2, sticky='nsew')
    ok_butt = tk.Button(brd_ok_butt, text='OK (rebuild)', bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                        activebackground=ACC_COLOR1, command=lambda: save_folders(folders_tree, folders_req))
    ok_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_cancel_butt = tk.Frame(folders_req, bg=BG_COLOR)
    brd_cancel_butt.grid(row=3, column=2, columnspan=3, sticky='nsew')
    cancel_butt = tk.Button(brd_cancel_butt, text='cancel', bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                            activebackground=ACC_COLOR1, command=folders_req.destroy)
    cancel_butt.pack(expand=True, fill='both', pady=1, padx=1)

    folders_req.rowconfigure(0, weight=1)
    folders_req.columnconfigure(0, weight=1)
    folders_req.columnconfigure(1, weight=1)
    folders_req.columnconfigure(2, weight=1)
    folders_req.columnconfigure(3, weight=1)

    folders_req.resizable(True, True)
    folders_req.update_idletasks()
    folders_req.update()
    x = root.winfo_x() + root.winfo_width() - 800
    y = root.winfo_y() + 30 + BUTT_HEIGHT
    folders_req.geometry(f'800x400+{x}+{y}')


def copy_to_clipboard(event, info=''):
    '''Copy to clipboard'''
    try:
        if event:
            if event.num == 1:
                info = text_info.get('sel.first', 'sel.last')
            else:
                text_info.focus_set()
                text_info.tag_add('sel', "1.0", 'end')
                info = text_info.get('1.0', 'end')
                text_info.update()
                time.sleep(0.1)
                text_info.tag_remove('sel', "1.0", 'end')
        root.clipboard_clear()
        root.clipboard_append(info)
        root.update()
    except tk.TclError:
        return


def explore_folder(path, r=None):
    '''Open explorer on the current location'''

    if OS == 'Linux':
        select = '--select'
    elif OS == 'Darwin':
        select = '-R'
    else:
        select = '/select,'

    if not path or path == 0:
        return
    elif isinstance(path, int):
        path = image_list[path]['file']
    elif isinstance(path, dict):
        if not path['values']:
            return

        path = path['values'][1]

        if OS == 'Linux':
            select = ''
        elif OS == 'Darwin':
            select = ''
        else:
            select = '/open,'

    path = os.path.normpath(path)

    if OS == 'Linux':
        default_app = subprocess.run(['xdg-mime', 'query', 'default', 'inode/directory'],
                                     stdout=subprocess.PIPE).stdout.decode('utf-8').strip()

        if default_app == 'org.kde.dolphin.desktop':
            subprocess.Popen(['dolphin', select, path])
        elif default_app == 'nautilus.desktop':
            subprocess.Popen(['nautilus', select, path])
        else:
            subprocess.Popen(['xdg-open', select, path])

    elif OS == 'Darwin':
        subprocess.Popen(["open", select, path])
    else:
        subprocess.Popen(["explorer ", select, path])


def save_info(idx, ask=False):
    '''Save the image information to a text file'''

    if not idx:
        return

    embed_text = image_list[idx]['txt_info']

    orig_file = image_list[idx]['file']
    orig_file = os.path.splitext(orig_file)[0]
    orig_file = f'{orig_file}.txt'
    orig_name = os.path.basename(orig_file)

    if ask:
        orig_file = filedialog.asksaveasfile(initialfile=orig_name)
        if not orig_file:
            return
        orig_file = orig_file.name

    with open(orig_file, 'w') as f:
        f.write(embed_text)


def reset_interface():
    '''Resets the program'''

    frame_all.destroy()
    main()


def clear_info():
    '''Clear current image and text information'''

    img_info.config(bg=FONT_COLOR, text=PROGRAM_NAME, image='')
    text_info['state'] = 'normal'
    text_info.delete('1.0', 'end')
    text_info.insert('insert', TEXT_INFO_DEFAULT)
    text_info['state'] = 'disable'


def read_image_info(original_image, image_path):
    '''Read the images embedded information'''

    source = ''
    embed = OrderedDict()
    embed_par = OrderedDict()
    image_format = original_image.format.upper()

    if image_format == 'PNG':
        embed = original_image.text
        embed_raw = ''.join(str(embed))

    elif image_format == 'JPEG':
        img_exif = original_image._getexif()
        embed_raw = ''.join(str(img_exif))

        if img_exif is not None:
            embed = list(img_exif.items())[1][1]

            if not isinstance(embed, int) and not isinstance(embed, str):
                embed = [chr(d) for d in embed if d > 0]
                embed = ''.join(embed)
                embed = embed.removeprefix('UNICODE')

                if embed.startswith('Upscale:'):
                    embed = {'extras': embed}
                else:
                    embed = {'parameters': embed}

    metadata_error = []
    if embed:
        try:
            if isinstance(embed, int) or isinstance(embed, str):
                embed = {}

            if 'parameters' in embed.keys():
                source = 'automatic1111'
                parameters = embed['parameters']
                prompt = parameters.partition('Steps: ')[0]
                negative_prompt = prompt.partition('Negative prompt: ')[2]
                parameters = 'Steps: ' + parameters.partition('Steps: ')[2]

                if negative_prompt:
                    prompt = prompt.partition('Negative prompt: ')[0]
                    embed_par['prompt'] = prompt.strip().replace('\n', ', ')
                    embed_par['negative prompt'] = negative_prompt.strip().replace('\n', ', ')
                else:
                    embed_par['prompt'] = prompt.strip()

                parameters = parameters.split(',')

                for par in parameters:
                    par_list = par.split(':')
                    title = par_list[0].strip().lower()
                    content = par_list[1].strip().lower()
                    embed_par[title] = content

            elif 'extras' in embed.keys():
                source = 'automatic1111 extras'
                modules = embed['extras'].split('\n')
                embed_par = {}
                for c, module in enumerate(modules):
                    parameters = module.split(',')
                    for par in parameters:
                        if par:
                            par_list = par.split(':')
                            title = f'{par_list[0].strip().lower()} {str(c + 1)}'
                            content = par_list[1].strip().lower()
                            embed_par[title] = content
            else:
                try:
                    source = list(embed.keys())[0]
                    embed_par = json.loads(embed[source])
                except (json.decoder.JSONDecodeError, IndexError):
                    embed_par['embedded info'] = embed_raw
        # Sorry for that but these metadata are a mess, never know what may come out of them.
        except Exception:
            embed_par['embedded info'] = embed_raw
            metadata_error.append(image_path)
    else:
        embed_par['embedded info'] = 'no information'

    if metadata_error:
        metadata_error_copy = '\n'.join(metadata_error)
        tense = ['']
        if len(metadata_error) > 1:
            tense = ['s']

        copy_to_clipboard(None, metadata_error_copy)

        message = (f'Failed to parse {len(metadata_error)} image{tense[0]} metadata.\n\n'
                   f'{metadata_error_copy}\n\n'
                   f'Path{tense[0]} copied to the clipboard.')
        tk.messagebox.showinfo(title='Metadata error.', message=message, parent=root)

    # Additional information
    real_size = original_image.size[0], original_image.size[1]

    img_format = os.path.basename(image_path)
    img_format = img_format.split('.')[-1]

    file_time = os.path.getmtime(image_path)
    file_time = datetime.datetime.fromtimestamp(file_time)
    file_time = file_time.strftime(time_format)

    embed_par[' '] = '\n'
    if source:
        embed_par['source'] = source
    embed_par['real_size'] = f'{real_size[0]} x {real_size[1]}'
    embed_par['format'] = img_format
    embed_par['created'] = str(file_time)
    embed_par['path'] = image_path

    embed_list = []
    for key in embed_par:
        # if key in embed_par:
        if key != ' ':
            embed_list.append(f'{key}: {embed_par[key]}\n')
        else:
            embed_list.append('\n')

    embed_txt = ''.join(embed_list)

    dif_pars = list(set(embed_par.keys()) - set(TEXT_PARS))
    for par in dif_pars:
        if par not in new_pars and par.strip() != '':
            new_pars.append(par)

    return embed_txt, embed_par


def progress_bar(amount, message, start=0):
    # Create progress bar
    restart = tk.Toplevel()
    restart.title(f'Processing')
    restart.resizable(False, False)
    restart.bind('<Escape>', lambda event: restart.destroy())
    restart_frame = tk.Frame(restart, bg=BG_COLOR)
    restart_frame.pack(expand=True, fill='both')

    load_img = tk.Label(restart_frame, bg=BG_COLOR, fg=FONT_COLOR,
                        font=(FONT[0], int(FONT[1] * 1.2), FONT[2]),
                        text=message)
    load_img.pack(pady=0, padx=50)

    loading = tk.Label(restart_frame, bg=BG_COLOR, fg=ACC_COLOR1,
                       font=(FONT[0], int(FONT[1] * 1.2), FONT[2]),
                       text=f'{start} of {amount}')
    loading.pack(pady=0, padx=50)

    bar_lenght = GRID_IMG_SZ * (COL_NBR + BORDER * 2) / 2
    style = ttk.Style()
    style.configure('TProgressbar', relief='flat', borderwidth=0, background=FONT_COLOR, foreground=BG_COLOR)
    progress = ttk.Progressbar(restart_frame, orient='horizontal', length=bar_lenght, mode='determinate')
    progress.pack(pady=10, padx=50)

    # Update restart to get width and height
    restart.update()

    x = root.winfo_x() + int((((GRID_IMG_SZ + BORDER * 2) * COL_NBR) - restart.winfo_width()) / 2)
    y = root.winfo_y() + BUTT_HEIGHT + int((((GRID_IMG_SZ + BORDER * 2) * ROW_NBR) - restart.winfo_height()) / 2)
    restart.geometry(f'+{x}+{y}')

    return loading, progress, restart


def save_image(event, idx):

    if idx == 0:
        return

    orig_file = image_list[idx]['file']
    orig_name = os.path.basename(orig_file)
    dest_file = filedialog.asksaveasfile(initialfile=orig_name)

    if not dest_file:
        return

    dest_file = dest_file.name
    shutil.copy2(orig_file, dest_file)


def info_overlay(parameter_string):
    '''Overlay information on grid image'''
    if len(threading.enumerate()) > ROW_NBR:
        return

    global is_overlay

    for image_data in image_list:
        image_data['has_image'] = False

    parameter_string = parameter_string.strip()

    if parameter_string != ALL_PARAMETERS and parameter_string != '':
        is_overlay = parameter_string
    else:
        is_overlay = ''

    refresh_images(vsb.get()[0], vsb.get()[1])


def expose_images(search_string, parameter_string, invert=False, exact=False):
    '''Disable non matching images'''
    if len(threading.enumerate()) > ROW_NBR:
        return

    search_string = enter_search(search_string)
    parameter_string = parameter_string.strip()

    for image_data in image_list:
        embed_dict = image_data['dic_info']
        embed_text = image_data['txt_info']

        if parameter_string != ALL_PARAMETERS and parameter_string != '':
            embed_text = embed_dict.get(parameter_string, '')

        image_data['button'].config(bg=BG_COLOR, state='normal')

        if exact:
            if invert:
                if search_string.lower() == embed_text.lower():
                    image_data['button'].config(bg=ACC_COLOR2, state='disabled')
            else:
                if search_string.lower() != embed_text.lower():
                    image_data['button'].config(bg=ACC_COLOR2, state='disabled')
        else:
            if invert:
                if search_string.lower() in embed_text.lower():
                    image_data['button'].config(bg=ACC_COLOR2, state='disabled')
            else:
                if search_string.lower() not in embed_text.lower():
                    image_data['button'].config(bg=ACC_COLOR2, state='disabled')


def enter_search(search_string):
    '''When entering the search box'''

    if search_string == SEARCH_HELP:
        entry_search.configure(fg=BG_COLOR)
        entry_search.delete(0, 'end')
        return ''

    return search_string


def search_images(search_string, parameter_string, invert=False, exact=False):
    '''Sow images matching a search string'''
    if len(threading.enumerate()) > ROW_NBR:
        return

    global image_list

    if parameter_string == 'path':
        search_string = os.path.normpath(search_string)

    search_string = enter_search(search_string)
    parameter_string = parameter_string.strip()

    reverse_label = f'not ' if invert else ''
    search_label = 'all' if search_string == '' else search_string
    parameter_label = 'all' if parameter_string == '' else parameter_string
    exact_label = ', exact' if exact else ''
    loading, progress, restart = progress_bar(amount=1, message='Searching', start=1)
    loading['text'] = f'{reverse_label}{search_label} in {parameter_label}{exact_label}'
    progress['value'] = 100
    progress.update()

    # start = time.time()
    for image_data in image_list:

        embed_text = image_data['txt_info']
        embed_dict = image_data['dic_info']

        embed_search = embed_text

        image_data['search'] = False

        if parameter_string != ALL_PARAMETERS and parameter_string != '':
            embed_search = embed_dict.get(parameter_string, '')

        if exact:
            if invert:
                if search_string.lower() != embed_search.lower():
                    image_data['search'] = True
            else:
                if search_string.lower() == embed_search.lower():
                    image_data['search'] = True
        else:
            if invert:
                if search_string.lower() not in embed_search.lower():
                    image_data['search'] = True
            else:
                if search_string.lower() in embed_search.lower():
                    image_data['search'] = True

    image_list.sort(key=itemgetter('search'), reverse=True)

    if parameter_string != 'path':
        lbl_path.current(0)

    modify_grid()
    clear_info()

    restart.destroy()


def sort_images(parameter_string, reverse=None, force=False):
    '''Sort the images'''
    if not force and len(threading.enumerate()) > ROW_NBR:
        return

    global image_list
    global sort_reverse

    parameter_string = parameter_string.strip()

    if parameter_string == ALL_PARAMETERS or parameter_string == '':
        parameter_string = 'created'

    if reverse is not None:
        sort_reverse = not reverse

    reverse_label = f', reverse' if sort_reverse else ''
    loading, progress, restart = progress_bar(amount=1, message='Sorting', start=1)
    loading['text'] = f'{parameter_string}{reverse_label}'
    progress['value'] = 100
    progress.update()

    for c, image_data in enumerate(image_list):

        embed_dict = image_data['dic_info']

        sort = embed_dict.get(parameter_string, '')
        if parameter_string == 'created':
            sort = datetime.datetime.strptime(sort, time_format)
        image_list[c]['sort'] = sort

    # if all items are int make them all int()
    if all(str(items['sort']).isdigit() or items['sort'] == '' for items in image_list):
        for c, image_data in enumerate(image_list):
            image_list[c]['sort'] = int(image_data['sort']) if image_data['sort'] != '' else 0

    sort_reverse = not sort_reverse
    image_list.sort(key=itemgetter('sort'), reverse=sort_reverse)

    modify_grid()
    clear_info()

    restart.destroy()


def search_paths():
    path = lbl_path.get()

    if path == ALL_FOLDERS or path == '':
        path = ''

    lbl_path.selection_clear()
    search_images(path, 'path')


def generate_image_list(files):
    global image_list_master
    global COMBO_VALUES
    global TEXT_PARS

    t = len(files)
    loading, progress, restart = progress_bar(t, 'Loading data, please wait.')

    # Get images data
    image_list_temp = []
    image_error = []
    for idx, file in enumerate(files):
        try:
            original_image = Image.open(file)
        except UnidentifiedImageError:
            image_error.append(file)
            continue
        embed_text, embed_dict = read_image_info(original_image, file)

        item_dict = {'button': None,
                     'has_image': False,
                     'txt_info': embed_text,
                     'dic_info': embed_dict,
                     'file': file,
                     'search': True,
                     'sort': ''}

        image_list_temp.append(item_dict)

        prog = int(idx / t * 100)
        try:
            loading['text'] = f'{idx} of {t}'
            progress['value'] = prog
        except tk.TclError:
            break
        progress.update()

        lbl_files.config(text=f'{idx} images')

    image_list_master = image_list_temp

    lbl_files.config(text=f'{idx} images')
    restart.destroy()

    if image_error:
        image_error_copy = '\n'.join(image_error)
        tense = ['']
        if len(image_error) > 1:
            tense = ['s']

        copy_to_clipboard(None, image_error_copy)

        message = (f'Found {len(image_error)} image{tense[0]} with error.\n\n'
                   f'{image_error_copy}\n\n'
                   f'Path{tense[0]} copied to the clipboard.')
        tk.messagebox.showinfo(title='Image error.', message=message, parent=root)

    if new_pars:
        pars_copy = '\n'.join(new_pars)

        tense = ['', 'it', 'its', 'it', 'was']
        if len(new_pars) > 1:
            tense = ['s', 'them', 'their', 'they', 'were']

        message = (f'Found {len(new_pars)} new parameter{tense[0]}.\n\n'
                   f'{pars_copy}\n\n'
                   f'{tense[3].capitalize()} {tense[4]} added to the parameters.txt.\n'
                   f'You can change {tense[2]} order on the file.\n')
        #    f'({tense[3]} will be added before the space separator)\n\n')
        #    f'If yes, open parameters.txt and adjust {tense[2]} order.\n\n'
        #    f'If not, {tense[3]} {tense[4]} copied to the clipboard '
        #    f'and can be added manually.')

        tk.messagebox.showinfo(title='New parameter found.', message=message, parent=root)

        copy_to_clipboard(None, pars_copy)

        with open(PARAMETERS_FILE, 'r') as file:
            TEXT_PARS = file.read().splitlines()

        pos = len(TEXT_PARS) - 6
        TEXT_PARS[pos:pos] = new_pars

        with open(PARAMETERS_FILE, 'w') as file:
            file.write('\n'.join(TEXT_PARS))

        COMBO_VALUES = TEXT_PARS
        COMBO_VALUES.insert(0, ALL_PARAMETERS)

        # with open(PARAMETERS_FILE, 'r') as file:
        #     TEXT_PARS = file.read().splitlines()
        # if res == 'yes':

    return image_list_temp


def update_grid():
    '''Update new / deleted images files'''

    global image_list

    old_files = [image_data['file'] for image_data in image_list]
    new_files = get_image_paths()

    if collections.Counter(old_files) == collections.Counter(new_files):
        return

    deleted_files = list(set(old_files) - set(new_files))
    new_files = list(set(new_files) - set(old_files))

    # Make a new list without the images on the deleted list
    # Also flag the ones not deleted as not having images so they can refresh
    # and reset the search and sort parameters
    image_list_temp = []
    for image_data in image_list:
        if image_data['file'] not in deleted_files:
            image_data['has_image'] = False
            image_data['search'] = True
            image_data['sort'] = ''
            image_list_temp.append(image_data)
        else:
            image_data['button'].destroy()

        image_list = image_list_temp

    if new_files:
        image_list_temp = generate_image_list(new_files)
        image_list.extend(image_list_temp)

    image_list_temp = []
    for image_data in image_list:
        image_list_temp.append(image_data.copy())
        image_list_temp[-1]['button'] = None

    with bz2.BZ2File(DATA_FILE, 'wb') as f:
        pickle.dump(image_list_temp, f)

    del image_list_temp

    create_grid()
    sort_images('created', reverse=True)
    clear_info()

    lbl_files.config(text=f'{len(image_list)} images')


def modify_grid():
    global prev_button

    if not image_list:
        return

    images = 0
    bx = by = 0
    for idx, image_data in enumerate(image_list):

        button = image_data['button']

        if not image_data['search']:
            button.grid_forget()
            continue

        button.grid(row=bx, column=by)
        button = modify_button(button, idx)

        by += 1
        if by % COL_NBR == 0:
            by = 0
            bx += 1

        images += 1

    lbl_files.config(text=f'{images} images')

    prev_button = button

    canvas.yview_moveto('0')
    refresh_images(vsb.get()[0], vsb.get()[1])

    canvas_height = max((images // COL_NBR) * (GRID_IMG_SZ + BORDER * 2) + GRID_IMG_SZ, canvas.winfo_height())
    canvas.configure(scrollregion=(0, 0, canvas.winfo_width(), canvas_height))


def create_grid():
    '''Create grid buttons'''
    global image_list

    if not image_list:
        return

    for idx, image_data in enumerate(image_list):
        if image_data['button'] is None:
            button = create_button(blank_image, idx)
            button.config(bg=BG_COLOR)  # Needed to make disabled show correct bg color without affecting border at start
            image_data['button'] = button


def create_button(image, index):

    button = tk.Button(frame_buttons, width=GRID_IMG_SZ, height=GRID_IMG_SZ, borderwidth=0,
                       relief='flat', name=str(index), image=image, highlightthickness=BORDER,
                       activebackground=BG_COLOR, bg=ACC_COLOR2, fg=ACC_COLOR1, bd=0,
                       compound="center", wraplength=GRID_IMG_SZ,
                       justify='left', padx=0, pady=0)

    return button


def modify_button(button, index):

    button['command'] = lambda index=index: click_grid_image(index)

    button.bind('<Left>', lambda event: grid_keys(event, -1))
    button.bind('<Right>', lambda event: grid_keys(event, 1))
    button.bind('<Up>', lambda event: grid_keys(event, -COL_NBR))
    button.bind('<Down>', lambda event: grid_keys(event, COL_NBR))

    root.bind('<Shift-Up>', lambda event: grid_keys(event, -COL_NBR * ROW_NBR + COL_NBR))
    root.bind('<Shift-Down>', lambda event: grid_keys(event, COL_NBR * ROW_NBR - COL_NBR))

    root.bind('<Control-Up>', lambda event: grid_keys(event, 0, True))
    root.bind('<Control-Down>', lambda event: grid_keys(event, 1, True))

    button.bind('<Double-Button-1>', lambda event, index=index: show_full_image(index))
    button.bind('<Return>', lambda event, index=index: show_full_image(index))
    button.bind('<space>', lambda event, index=index: show_full_image(index))

    button.bind('<Shift-Double-Button-1>', lambda event, index=index: show_image(index))
    button.bind('<Shift-Return>', lambda event, index=index: show_image(index))
    button.bind('<Shift-space>', lambda event, index=index: show_image(index))

    button.bind("<Button-3>", lambda event, index=index: menu_popup(event, index))
    button.bind("<Button-2>", lambda event, index=index: menu_popup(event, index))

    button.bind('<Control-s>', lambda event: save_image(event, current_index))
    button.bind('<Control-S>', lambda event: save_image(event, current_index))

    button.bind('<Control-f>', lambda event: explore_folder(current_index))
    button.bind('<Control-F>', lambda event: explore_folder(current_index))

    button.bind('<Control-c>', lambda event=2: copy_to_clipboard(event, current_index))
    button.bind('<Control-C>', lambda event=2: copy_to_clipboard(event, current_index))

    button.bind('<Control-i>', lambda event: save_info(current_index))
    button.bind('<Control-I>', lambda event: save_info(current_index))
    button.bind('<Shift-Control-i>', lambda event: save_info(current_index, True))
    button.bind('<Shift-Control-I>', lambda event: save_info(current_index, True))

    return button


def menu_popup(event, idx):
    '''Open popup menu and make index global'''
    global popup_index

    pop_menu.delete(0)
    filename = os.path.basename(image_list[idx]['file'])[:20] + '...'
    pop_menu.insert_cascade(0, label=filename, foreground=FONT_COLOR, background=BG_COLOR,
                            activebackground=BG_COLOR, activeforeground=ACC_COLOR1, command=lambda: menu_items(7))

    popup_index = idx
    try:
        pop_menu.tk_popup(event.x_root, event.y_root)
    finally:
        pop_menu.grab_release()


def menu_items(item):
    '''Deal with menu choices'''

    if item == 0:
        show_full_image(popup_index)

    elif item == 1:
        show_image(popup_index)

    elif item == 2:
        explore_folder(popup_index)

    elif item == 3:
        embed_txt = image_list[popup_index]['txt_info']
        copy_to_clipboard(None, embed_txt)

    elif item == 4:
        save_info(popup_index)

    elif item == 5:
        save_info(popup_index, True)

    elif item == 7:
        filename = image_list[popup_index]['file']
        copy_to_clipboard(None, filename)

    else:
        save_image(None, popup_index)


def first_run():
    global sort_reverse
    global is_overlay

    is_overlay = ''

    loading, progress, restart = progress_bar(amount=2, message='Initializing', start=1)

    progress['value'] = 50
    progress.update()

    load_success = load_image_list()

    if load_success:
        create_grid()
        update_grid()
        sort_images('', reverse=True, force=True)

        loading['text'] = f'2 of 2'
        progress['value'] = 100
        progress.update()

    # # Update buttons frames idle tasks to let tkinter calculate buttons sizes
    # frame_buttons.update_idletasks()

    # Set the canvas scrolling region
    canvas.config(scrollregion=canvas.bbox('all'))

    restart.destroy()


def get_image_paths():
    '''Get images from the path'''

    global folders

    files = []
    folders = []

    if not os.path.isfile(FOLDERS_FILE):
        return None

    folders_combo = []
    try:
        with open(FOLDERS_FILE, 'r') as file:
            folders = json.load(file)
    except (AttributeError, EOFError, ImportError, IndexError) as e:
        tk.messagebox.showinfo(title='Error loading folders.', message=e, parent=root)
        return None
    finally:
        ext = ['.png', '.jpg']
        for folder in folders:
            path = folder[1]
            folders_combo.append(path)
            recursive = True if folder[0] == '1' else False
            if os.path.isdir(path):
                for e in ext:
                    if recursive:
                        file = glob.glob(os.path.normpath(path + '/**/*' + e), recursive=True)
                    else:
                        file = glob.glob(os.path.normpath(path + '/*' + e), recursive=False)
                    files.extend(file)

    folders_combo.insert(0, ALL_FOLDERS)
    lbl_path.config(value=folders_combo)
    lbl_path.current(0)

    return files


def load_image_list():
    global image_list
    global image_list_master

    if os.path.isfile(DATA_FILE):
        try:
            with bz2.BZ2File(DATA_FILE, 'rb') as f:
                image_list = pickle.load(f)
        except (pickle.UnpicklingError,
                AttributeError, EOFError, ImportError, IndexError,
                Exception) as e:
            tk.messagebox.showinfo(title='Error loading data file.', message=e, parent=root)
            return False

    else:
        files = get_image_paths()
        if files is None:
            return False
        image_list = generate_image_list(files)
        with bz2.BZ2File(DATA_FILE, 'wb') as f:
            pickle.dump(image_list, f)

    return True


def main():
    '''Create the main window'''

    global vsb
    global canvas
    global img_info
    global text_info
    global lbl_files
    global frame_all
    global frame_buttons
    global entry_search
    global pop_menu
    global lbl_key
    global lbl_help
    global lbl_path
    global image_list
    global image_list_master
    global current_index
    global blank_image

    # Create a blank image
    blank_image = Image.new(color=(0, 0, 0), mode="RGB", size=(0, 0))
    blank_image.putalpha(0)
    blank_image = ImageTk.PhotoImage(blank_image, name='blank_image')

    current_index = 0

    # Must be here to refresh when changing config
    root.option_add('*font', FONT)

    root.bind('<Prior>', lambda event: canvas.yview_scroll(-1, 'pages'))
    root.bind('<Next>', lambda event: canvas.yview_scroll(1, 'pages'))

    root.bind('<Home>', lambda event: canvas.yview_moveto(0))
    root.bind('<End>', lambda event: canvas.yview_moveto(1))

    root.bind('<Control-p>', lambda event: explore_folder({'values': ['', lbl_path.get()]}))
    root.bind('<Control-P>', lambda event: explore_folder({'values': ['', lbl_path.get()]}))

    root.bind('<Control-r>', lambda event: update_grid())
    root.bind('<Control-R>', lambda event: update_grid())

    root.bind('<Control-s>', lambda event: entry_search.focus_set())
    root.bind('<Control-S>', lambda event: entry_search.focus_set())

    root.bind('<Control-m>', lambda event: combo_params.focus_set())
    root.bind('<Control-M>', lambda event: combo_params.focus_set())

    root.bind('<Control-o>', lambda event: sort_images(combo_params.get()))
    root.bind('<Control-O>', lambda event: sort_images(combo_params.get()))
    root.bind('<Shift-Control-o>', lambda event: sort_images(''))
    root.bind('<Shift-Control-O>', lambda event: sort_images(''))

    root.bind('<Control-l>', lambda event=2: info_overlay(combo_params.get()))
    root.bind('<Control-L>', lambda event=2: info_overlay(combo_params.get()))
    root.bind('<Shift-Control-l>', lambda event=2: info_overlay(''))
    root.bind('<Shift-Control-L>', lambda event=2: info_overlay(''))

    # Frame to hold the entire interface
    frame_all = tk.Frame(root, bg=BG_COLOR)
    frame_all.pack(fill=None, expand=False)

    # Top frame for labels and buttons
    frame_top = tk.Frame(frame_all, bg=BG_COLOR, height=BUTT_HEIGHT)
    frame_top.grid(row=0, column=0, sticky='news')
    frame_top.grid_propagate(False)

    frame_top.grid_rowconfigure(0, weight=1)
    frame_top.grid_columnconfigure(0, weight=1)
    frame_top.grid_columnconfigure(1, weight=0)

    # Top left sub frame for labels
    frame_top_l = tk.Frame(frame_top, bg=BG_COLOR)
    frame_top_l.grid(row=0, column=0, sticky='ewns')

    frame_top_l.grid_rowconfigure(0, weight=1)
    frame_top_l.grid_columnconfigure(0, weight=0)
    frame_top_l.grid_columnconfigure(1, weight=1)

    # Top right sub frame for buttons
    frame_top_r = tk.Frame(frame_top, width=INFO_IMG_SZ, bg=BG_COLOR)
    frame_top_r.grid(row=0, column=1, sticky='ewns')
    frame_top_r.grid_propagate(False)

    frame_top_r.grid_rowconfigure(0, weight=1)
    frame_top_r.grid_columnconfigure(0, weight=1)
    frame_top_r.grid_columnconfigure(1, weight=2)
    frame_top_r.grid_columnconfigure(2, weight=2)
    frame_top_r.grid_columnconfigure(3, weight=2)

    # Number of files label, top left frame
    lbl_files = tk.Label(frame_top_l, bg=BG_COLOR, fg=ACC_COLOR1, text=f'images')
    lbl_files.grid(row=0, column=0, sticky='w', padx=(10, 10))

    # Current path label, top left frame
    brd_lbl_path = tk.Frame(frame_top_l, bg=BG_COLOR)
    brd_lbl_path.grid(row=0, column=1, sticky='nsew')
    lbl_path = ttk.Combobox(brd_lbl_path, name='folders_combo', state='readonly')
    lbl_path.bind("<<ComboboxSelected>>", lambda event: search_paths())
    lbl_path.pack(expand=True, fill='both', pady=1, padx=1)

    # Refresh button, top right frame
    brd_bt_refr = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_refr.grid(row=0, column=0, sticky='snwe')
    butt_refr = tk.Button(brd_bt_refr, text='refresh', bd=0, command=update_grid,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_refr.pack(expand=True, fill='both', pady=1, padx=1)

    # Path button, top right frame
    brd_bt_path = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_path.grid(row=0, column=1, sticky='snwe')
    butt_path = tk.Button(brd_bt_path, text='paths', bd=0, command=folders_requester,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_path.pack(expand=True, fill='both', pady=1, padx=1)

    # Explorer button, top right frame
    brd_bt_open = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_open.grid(row=0, column=2, sticky='snwe')
    butt_open = tk.Button(brd_bt_open, text='open path', bd=0, command=lambda: explore_folder({'values': ['', lbl_path.get()]}),
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_open.pack(expand=True, fill='both', pady=1, padx=1)

    # Config button, top right frame
    brd_bt_conf = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_conf.grid(row=0, column=3, sticky='snwe')
    butt_conf = tk.Button(brd_bt_conf, text='config', bd=0, command=open_config,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_conf.pack(expand=True, fill='both', pady=1, padx=1)

    # Frame for the grid and info
    frame_main = tk.Frame(frame_all, bg=BG_COLOR)
    frame_main.grid(sticky='news')
    frame_main.grid(row=1, column=0, sticky='nw')

    # Frame for the info
    frame_info_height = GRID_IMG_SZ * ROW_NBR + (BORDER * 2 * ROW_NBR)
    info_frame = tk.Frame(frame_main, bg=BG_COLOR, width=INFO_IMG_SZ, height=frame_info_height)
    info_frame.grid(row=0, column=1, sticky='nw')

    # Button to show the selected image
    img_info = tk.Button(info_frame, bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1,
                         font=(FONT[0], FONT[1] * 3, 'bold'), borderwidth=0, text=PROGRAM_NAME)
    img_info.bind('<Button-1>', lambda event: show_full_image(current_index))
    img_info.bind('<Button-2>', lambda event: show_image(current_index))
    img_info.bind('<Button-3>', lambda event: show_image(current_index))
    img_info.bind('<Shift-Button-1>', lambda event: show_image(current_index))
    img_info.place(x=0, y=0, height=INFO_IMG_SZ, width=INFO_IMG_SZ)

    # Text box to show the selected image info
    text_info_height = GRID_IMG_SZ * ROW_NBR - INFO_IMG_SZ + (BORDER * 2 * ROW_NBR)
    text_info = tk.Text(info_frame, name='text_info',
                        bg=BG_COLOR, fg=FONT_COLOR,
                        selectbackground=FONT_COLOR, selectforeground=BG_COLOR,
                        borderwidth=0, padx=10, pady=10)
    text_info.bind('<ButtonRelease-1>', lambda event: copy_to_clipboard(event))
    text_info.bind('<ButtonRelease-2>', lambda event: copy_to_clipboard(event))
    text_info.bind('<ButtonRelease-3>', lambda event: copy_to_clipboard(event))

    text_info.insert('insert', TEXT_INFO_DEFAULT)
    text_info.place(x=0, y=INFO_IMG_SZ, height=text_info_height, width=INFO_IMG_SZ)
    text_info['state'] = 'disable'

    # Frame for the image grid
    frame_canvas = tk.Frame(frame_main, bg=BG_COLOR)
    frame_canvas.grid(row=0, column=0, sticky='nw')
    frame_canvas.grid_rowconfigure(0, weight=1)
    frame_canvas.grid_columnconfigure(0, weight=1)
    frame_canvas.grid_propagate(False)

    # Add a canvas in that frame
    canvas = tk.Canvas(frame_canvas, bg=BG_COLOR, borderwidth=0, highlightthickness=0)
    canvas.bind_all('<MouseWheel>', on_mousewheel)
    canvas.bind_all("<Button-4>", on_mousewheel)
    canvas.bind_all("<Button-5>", on_mousewheel)

    canvas.grid(row=0, column=0, sticky='news')

    # Create a frame to contain the buttons
    frame_buttons = tk.Frame(canvas, bg=BG_COLOR, name='buttons_frame')
    canvas.create_window((0, 0), window=frame_buttons, anchor='nw')

    # Link a scrollbar to the canvas
    vsb = tk.Scrollbar(frame_canvas, orient='vertical', command=canvas.yview)
    vsb.grid(row=0, column=1, sticky='ns')
    canvas.configure(yscrollcommand=refresh_images)

    # Resize the canvas and frame
    grid_width = (COL_NBR * GRID_IMG_SZ + (BORDER * 4 * COL_NBR)) + vsb.winfo_width() - 4
    grid_height = ROW_NBR * GRID_IMG_SZ + (BORDER * 2 * ROW_NBR)
    frame_canvas.config(width=grid_width, height=grid_height)

    # Frame for the search and info panel bottom
    bottom_frame = tk.Frame(frame_all, bg=BG_COLOR, height=BUTT_HEIGHT)
    bottom_frame.grid(row=2, column=0, sticky='news')

    # Frame for the search
    search_frame = tk.Frame(bottom_frame, bg=BG_COLOR)
    search_frame.place(x=0, height=BUTT_HEIGHT, width=grid_width)

    # Button to expose
    brd_bt_expose = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_expose.grid(row=0, column=0, sticky='news')
    butt_expose = tk.Button(brd_bt_expose, text='expose', bd=0,
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_expose.bind('<Return>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<space>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<Button-1>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<Control-Return>', lambda event: expose_images(entry_search.get(), combo_params.get(), invert=True))
    butt_expose.bind('<Control-space>', lambda event: expose_images(entry_search.get(), combo_params.get(), invert=True))
    butt_expose.bind('<Control-Button-1>', lambda event: expose_images(entry_search.get(), combo_params.get(), invert=True))
    butt_expose.bind('<Button-2>', lambda event: expose_images('', ''))
    butt_expose.bind('<Button-3>', lambda event: expose_images('', ''))
    butt_expose.bind('<Shift-Button-1>', lambda event: expose_images('', ''))
    butt_expose.bind('<Shift-Return>', lambda event: expose_images('', ''))
    butt_expose.bind('<Shift-space>', lambda event: expose_images('', ''))
    butt_expose.bind('<Alt-Return>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True))
    butt_expose.bind('<Alt-space>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True))
    butt_expose.bind('<Alt-Button-1>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True))
    butt_expose.bind('<Control-Alt-Return>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_expose.bind('<Control-Alt-space>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_expose.bind('<Control-Alt-Button-1>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_expose.pack(expand=True, fill='both', pady=1, padx=1)

    # Button to search
    brd_bt_search = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_search.grid(row=0, column=1, sticky='news')
    butt_search = tk.Button(brd_bt_search, text='search', bd=0,
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_search.bind('<Return>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<space>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<Button-1>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<Control-Return>', lambda event: search_images(entry_search.get(), combo_params.get(), invert=True))
    butt_search.bind('<Control-space>', lambda event: search_images(entry_search.get(), combo_params.get(), invert=True))
    butt_search.bind('<Control-Button-1>', lambda event: search_images(entry_search.get(), combo_params.get(), invert=True))
    butt_search.bind('<Button-2>', lambda event: search_images('', ''))
    butt_search.bind('<Button-3>', lambda event: search_images('', ''))
    butt_search.bind('<Shift-Button-1>', lambda event: search_images('', ''))
    butt_search.bind('<Shift-Return>', lambda event: search_images('', ''))
    butt_search.bind('<Shift-space>', lambda event: search_images('', ''))
    butt_search.bind('<Alt-Return>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True))
    butt_search.bind('<Alt-space>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True))
    butt_search.bind('<Alt-Button-1>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True))
    butt_search.bind('<Control-Alt-Return>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_search.bind('<Control-Alt-space>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_search.bind('<Control-Alt-Button-1>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_search.pack(expand=True, fill='both', pady=1, padx=1)

    # Search entry box
    brd_ent_search = tk.Frame(search_frame, bg=BG_COLOR)
    brd_ent_search.grid(row=0, column=2, sticky='nwes')
    entry_search = tk.Entry(brd_ent_search, bg=ACC_COLOR1, fg=FONT_COLOR, bd=0, name='entry_search',
                            selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2)
    entry_search.insert('insert', SEARCH_HELP)
    entry_search.bind('<FocusIn>', lambda event: enter_search(entry_search.get()))
    entry_search.bind('<Return>', lambda event: search_images(entry_search.get(), combo_params.get()))
    entry_search.bind('<Shift-Return>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    entry_search.bind('<Control-Return>', lambda event: search_images('', ''))
    entry_search.bind('<Control-Shift-Return>', lambda event: expose_images('', ''))
    entry_search.pack(expand=True, fill='both', pady=1, padx=1)

    # Search parameters
    brd_cb_param = tk.Frame(search_frame, bg=BG_COLOR)
    brd_cb_param.grid(row=0, column=3, sticky='snew')
    combo_params = ttk.Combobox(brd_cb_param, values=TEXT_PARS, name='combo_box', width=10)
    combo_params.current(0)
    combo_params.pack(expand=True, fill='both', pady=1, padx=1)
    combo_params.bind("<<ComboboxSelected>>", lambda event: combo_params.selection_clear())

    # Button to sort
    brd_bt_sort = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_sort.grid(row=0, column=4, sticky='news')
    butt_sort = tk.Button(brd_bt_sort, text='sort', bd=0,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_sort.bind('<Return>', lambda event: sort_images(combo_params.get()))
    butt_sort.bind('<space>', lambda event: sort_images(combo_params.get()))
    butt_sort.bind('<Button-1>', lambda event: sort_images(combo_params.get()))
    butt_sort.bind('<Button-2>', lambda event: sort_images(''))
    butt_sort.bind('<Button-3>', lambda event: sort_images(''))
    butt_sort.bind('<Shift-Return>', lambda event: sort_images(''))
    butt_sort.bind('<Shift-space>', lambda event: sort_images(''))
    butt_sort.bind('<Shift-Button-1>', lambda event: sort_images(''))
    butt_sort.pack(expand=True, fill='both', pady=1, padx=1)

    # Button to show overlay
    brd_bt_overlay = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_overlay.grid(row=0, column=5, sticky='news')
    butt_overlay = tk.Button(brd_bt_overlay, text='overlay', bd=0,
                             bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_overlay.bind('<Return>', lambda event: info_overlay(combo_params.get()))
    butt_overlay.bind('<space>', lambda event: info_overlay(combo_params.get()))
    butt_overlay.bind('<Button-1>', lambda event: info_overlay(combo_params.get()))
    butt_overlay.bind('<Button-2>', lambda event: info_overlay(''))
    butt_overlay.bind('<Button-3>', lambda event: info_overlay(''))
    butt_overlay.bind('<Shift-Return>', lambda event: info_overlay(''))
    butt_overlay.bind('<Shift-space>', lambda event: info_overlay(''))
    butt_overlay.bind('<Shift-Button-1>', lambda event: info_overlay(''))
    butt_overlay.pack(expand=True, fill='both', pady=1, padx=1)

    search_frame.grid_rowconfigure(0, weight=1)
    search_frame.grid_columnconfigure(0, weight=0)
    search_frame.grid_columnconfigure(1, weight=0)
    search_frame.grid_columnconfigure(2, weight=2)
    search_frame.grid_columnconfigure(3, weight=1)
    search_frame.grid_columnconfigure(4, weight=0)
    search_frame.grid_columnconfigure(5, weight=0)

    # Frame for the info panel bottom
    info_panel_x = grid_width
    info_panel_frame = tk.Frame(bottom_frame, bg=BG_COLOR)
    info_panel_frame.place(x=info_panel_x, height=BUTT_HEIGHT, width=INFO_IMG_SZ)

    # Button to open folder containing image
    brd_bt_folder = tk.Frame(info_panel_frame, bg=BG_COLOR)
    brd_bt_folder.grid(row=0, column=0, sticky='news')
    butt_folder = tk.Button(brd_bt_folder, text='show in folder', bd=0,
                            command=lambda: explore_folder(current_index),
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_folder.pack(expand=True, fill='both', pady=1, padx=1)

    # Button to save information
    brd_bt_save_info = tk.Frame(info_panel_frame, bg=BG_COLOR)
    brd_bt_save_info.grid(row=0, column=1, sticky='news')
    butt_save_info = tk.Button(brd_bt_save_info, text='save info', bd=0,
                               bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_save_info.pack(expand=True, fill='both', pady=1, padx=1)
    butt_save_info.bind('<Return>', lambda event: save_info(current_index))
    butt_save_info.bind('<space>', lambda event: save_info(current_index))
    butt_save_info.bind('<Button-1>', lambda event: save_info(current_index))
    butt_save_info.bind('<Button-2>', lambda event: save_info(current_index, True))
    butt_save_info.bind('<Button-3>', lambda event: save_info(current_index, True))
    butt_save_info.bind('<Shift-Return>', lambda event: save_info(current_index, True))
    butt_save_info.bind('<Shift-space>', lambda event: save_info(current_index, True))
    butt_save_info.bind('<Shift-Button-1>', lambda event: save_info(current_index, True))

    info_panel_frame.grid_rowconfigure(0, weight=1)
    info_panel_frame.grid_columnconfigure(0, weight=1)
    info_panel_frame.grid_columnconfigure(1, weight=1)

    # Popup menu
    pop_menu = tk.Menu(root, tearoff=0, relief='flat', bg=FONT_COLOR,
                       activebackground=ACC_COLOR1, activeforeground=BG_COLOR, disabledforeground=FONT_COLOR,
                       borderwidth=0, activeborderwidth=0)
    pop_menu.add_separator()
    pop_menu.add_command(label='open image internal', foreground=BG_COLOR, command=lambda: menu_items(0))
    pop_menu.add_command(label='open image in system', foreground=BG_COLOR, command=lambda: menu_items(1))
    pop_menu.add_command(label='show image in folder', foreground=BG_COLOR, command=lambda: menu_items(2))
    pop_menu.add_command(label='copy image to folder', foreground=BG_COLOR, command=lambda: menu_items(6))
    pop_menu.add_command(label='save info', foreground=BG_COLOR, command=lambda: menu_items(4))
    pop_menu.add_command(label='save info as', foreground=BG_COLOR, command=lambda: menu_items(5))
    pop_menu.add_command(label='copy info to clipboard', foreground=BG_COLOR, command=lambda: menu_items(3))

    # Adjustments for MacOS
    # lbl_path.config(highlightbackground=BG_COLOR)
    butt_path.config(highlightbackground=BG_COLOR)
    butt_refr.config(highlightbackground=BG_COLOR)
    butt_open.config(highlightbackground=BG_COLOR)
    butt_conf.config(highlightbackground=BG_COLOR)
    butt_folder.config(highlightbackground=BG_COLOR)
    butt_save_info.config(highlightbackground=BG_COLOR)
    butt_search.config(highlightbackground=BG_COLOR)
    butt_expose.config(highlightbackground=BG_COLOR)
    text_info.config(highlightbackground=BG_COLOR)
    entry_search.config(highlightbackground=BG_COLOR)

    style = ttk.Style()
    style.theme_use('default')
    style.configure('TCombobox', relief='flat', background=FONT_COLOR, foreground=BG_COLOR,
                    selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2,
                    arrowcolor=BG_COLOR, darkcolor=ACC_COLOR1)
    style.map('TCombobox', fieldbackground=[('disabled', ACC_COLOR1), ('!disabled', ACC_COLOR1)])
    root.option_add('*TCombobox*Listbox*Background', FONT_COLOR)
    root.option_add('*TCombobox*Listbox*Foreground', BG_COLOR)
    root.option_add('*TCombobox*Listbox*selectBackground', ACC_COLOR1)
    root.option_add('*TCombobox*Listbox*selectForeground', BG_COLOR)

    style.configure('Treeview', borderwidth=0, background=ACC_COLOR1, foreground=BG_COLOR, fieldbackground=ACC_COLOR1)
    style.map('Treeview', background=[('selected', FONT_COLOR)], foreground=[('selected', BG_COLOR)])
    style.configure('Treeview.Heading', background=FONT_COLOR)
    style.map('Treeview.Heading', background=[('pressed', ACC_COLOR1)])

    # Launch the GUI
    # frame_buttons.config(bg=ACC_COLOR1)
    # tk.messagebox.showinfo(title='Speed test', message='Ok to go.')
    # first_run()
    root.after(50, lambda: first_run())
    root.mainloop()


if __name__ == '__main__':
    main()
