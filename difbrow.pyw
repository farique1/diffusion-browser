# Diffuse Browser v3.1
# Fred Rique (c) 2022 - 2024.
# github.com/farique1/diffusion-browser
# An easy way to view embedded image metadata of most AI generators.

# CHANGES
# v3.0
#   Load image information and save for further use
#   Read image file on demand, threaded
#   Multiple paths
#   ALT+... > Search or expose exact
#   CONTROL+ALT+... > Search or expose exact inverted
#   HOME > Go to the top of the grid
#   END > Go to the bottom of the grid
#   SHIFT+UP > Go to the image one page above
#   SHIFT+DOWN > Go to the image one page below
#   CONTROL+UP > Go to the first image
#   CONTROL+DOWN > Go to the last image
#   Searching using PATH as a parameter will normalize the path
# v3.1
#   Paths requester
#      Toggle active or inactive folders
#      Double clicking on subfolders or active on the paths requester will toggle them
#      Double clicking on the path name will change it
#      RETURN, SPACE on the paths requester will toggle subfolders
#      SHIFT+RETURN, SHIFT+SPACE on the paths requester will toggle active
#      Button to change the selected path
#   Image grid
#      Right click an image now selects it
#      SHIFT+UP became ALT+UP
#      SHIFT+DOWN became ALT+DOWN
#      Multi select images
#         SHIFT+UP add select up
#         SHIFT+DOWN add select down
#         SHIFT+LEFT add select left
#         SHIFT+RIGHT add select right
#         shift+click select more
#         control+click select toggle
#         Menu title copy all selected
#         Menu item perform on all images
#         Keyboard shortcuts affects all selected images
#   Removed seed from the internal image viewer header
#   Optimizations
#      Load images one by one instead of by rows
#      Functions to consolidate selected and unselected button state
#   Several small tweaks on the GUI
#       Added Scrollbar to the information window
#      Themed the scrollbars
#      Exchanged open path and paths buttons positions
#      Moved refresh and open path buttons
#      Menu appearance
#      Some state color changes
#   Added save batch to folder menu item
#      SHIFT+CTRL+S activate batch copy
#   Paths combobox show all paths containing images
#   Metadata errors bunched together for display.
#   Change readme: ctr+l=overlay, ctrl+i=save info
#   Metadata reading more robust
#   Added support for Fooocus and Fooocus a1111 native embedded metadata

# FIX
#   Sometimes when searching for a word and after it sorting and overlaying,
#      the overlaying stops working on all shown images. (thesis: maybe it is
#      only overlaying the images that are "visible" on the grid if the grid
#      did not had been reduced by the search. Images that are farthest from
#      the first searched image than the height of the grid in images)

# ADD
#   Use im.get_format_mimetype() or Image.MIME[img.format] or img.format
#      to determine the image type. Also to load images regardless of extension
#   Undock and dock the image and embedded info viewers (see teste.py)
#   Multiple projects
#   Images Heart
#   Images Starts
#   Images Tags
#   Images Sets
#   Mute folders to prevent them from appearing without changing the database
#   Rebuild the order of the parameters without needing to rebuild the database
#   Keep metadata reading functions independent, delivering a standard format
#   Allow consolidation of multiple parameters into a single label

import re
import os
import bz2
import glob
import json
import math
import time
import pickle
import shutil
import platform
import datetime
import threading
import subprocess
import collections
import configparser
import tkinter as tk
from operator import itemgetter
from collections import OrderedDict
from tkinter.colorchooser import askcolor
from tkinter import ttk, font, filedialog
from PIL import Image, ImageTk, ImageOps, UnidentifiedImageError

# Constants
COL_NBR = 5
ROW_NBR = 5
GRID_IMG_SZ = 100
INFO_IMG_SZ = 250
BUTT_HEIGHT = 26
FONT_NAME = 'Tahoma'
FONT_SIZE = 10
FONT_WEIGHT = 'normal'
BG_COLOR = 'black'
FONT_COLOR = 'teal'
ACC_COLOR1 = 'goldenrod'
ACC_COLOR2 = 'grey70'
ALERT_COLOR = 'dark red'
# TOP_PATH = 'D:/Stable Diffusion WebUI/stable-diffusion-webui/outputs/test'

FONT = [FONT_NAME, FONT_SIZE, FONT_WEIGHT]

BORDER = 1
PROGRAM_NAME = 'Diffusion\nBrowser'
ALL_PARAMETERS = 'all parameters'
ALL_FOLDERS = 'all paths'
SEARCH_HELP = 'enter search'
TEXT_INFO_DEFAULT = ('Diffusion Browser v3.0\n'
                     'github.com/farique1/diffusion-browser\n'
                     '(c) Fred Rique 2022 - 2024\n\n'
                     'Browse pictures and metadata generated by Stable Diffusion.\n'
                     'Works with embedded data from most generators in the style of Automatic1111.\n'
                     'Converter provided for Fooocus log.html')

LOCAL_PATH = os.path.split(os.path.abspath(__file__))[0]
PROJECT_PATH = 'Projects'
current_project = 'default'
INI_FILE = os.path.join(LOCAL_PATH, PROJECT_PATH, current_project, 'difbrowser.ini')
PARAMETERS_FILE = os.path.join(LOCAL_PATH, PROJECT_PATH, current_project, 'parameters.txt')
DATA_FILE = os.path.join(LOCAL_PATH, PROJECT_PATH, current_project, 'data.pickle')
FOLDERS_FILE = os.path.join(LOCAL_PATH, PROJECT_PATH, current_project, 'folders.json')

OS = platform.system()

with open(PARAMETERS_FILE, 'r') as file:
    TEXT_PARS = file.read().splitlines()

COMBO_VALUES = TEXT_PARS
COMBO_VALUES.insert(0, ALL_PARAMETERS)

# Variable initialization
folders = []
image_list = []
new_pars = []
is_overlay = ''
current_index = 0
current_seed = ''
current_image = ''
multi_index = []
sort_reverse = True
time_format = '%Y-%m-%d %H:%M:%S'
prev_button = None

# .ini file handling
ini_path = os.path.join(LOCAL_PATH, INI_FILE)
config_ini = configparser.ConfigParser()
if os.path.isfile(ini_path):
    try:
        config_ini.read(ini_path)
        config_sec = config_ini['CONFIGS']
        COL_NBR = int(config_sec.get('number_of_columns'))
        ROW_NBR = int(config_sec.get('number_of_lines'))
        GRID_IMG_SZ = int(config_sec.get('grid_image_size'))
        INFO_IMG_SZ = int(config_sec.get('preview_image_size'))
        BUTT_HEIGHT = int(config_sec.get('button_height'))
        FONT_NAME = config_sec.get('font_name')
        FONT_SIZE = int(config_sec.get('font_size'))
        FONT_WEIGHT = config_sec.get('font_weight')
        BG_COLOR = config_sec.get('background_color')
        FONT_COLOR = config_sec.get('main_color')
        ACC_COLOR1 = config_sec.get('accent_color_1')
        ACC_COLOR2 = config_sec.get('accent_color_2')
        ALERT_COLOR = config_sec.get('alert_color')
        # TOP_PATH = config_sec.get('default_path')

        FONT = [FONT_NAME, FONT_SIZE, FONT_WEIGHT]
        # TOP_PATH = os.path.normpath(TOP_PATH)

    except (ValueError, configparser.NoOptionError) as e:
        print(f'.INI file problem: {str(e)}')
        raise SystemExit(0)

# Initialize
root = tk.Tk()

root.configure(background='black')
root.title('Diffusion Browser')
root.protocol("WM_DELETE_WINDOW", lambda: root.destroy())
root.bind_class("Button", "<Key-Return>", lambda event: event.widget.invoke())

if OS == 'Linux':
    root.resizable(True, True)
else:
    root.resizable(True, True)


def resize_image(image, maxsize):
    '''Resize image maintaining aspect ratio and maximum size'''

    r1 = image.size[0] / maxsize[0]  # width ratio
    r2 = image.size[1] / maxsize[1]  # height ratio
    ratio = max(r1, r2)
    newsize = (int(image.size[0] / ratio), int(image.size[1] / ratio))
    image = image.resize(newsize, Image.Resampling.LANCZOS)

    return image


def get_canvas_boundaries():
    try:
        canvas_height = canvas.winfo_height()
        y_srt = canvas.yview()[0]
        y_end = canvas.yview()[1]
        y_len = y_end - y_srt
        total_height = canvas_height / y_len
        canvas_y_top = int(total_height * y_srt / (GRID_IMG_SZ + BORDER * 2))
        canvas_y_bot = int(total_height * y_end / (GRID_IMG_SZ + BORDER * 2)) + 1

        slice_start = canvas_y_top * COL_NBR
        slice_end = canvas_y_bot * COL_NBR + COL_NBR
        slice_end = min(slice_end, len(image_list))

        return slice_start, slice_end

    except tk.TclError:
        raise SystemExit(0)


def render_buttons(image_data, n):

    slice_start, slice_end = get_canvas_boundaries()
    if n < slice_start or n > slice_end:
        image_data['has_image'] = False
        return

    image_data['button'].update()

    try:
        image = Image.open(image_data['file'])
        image = resize_image(image, (GRID_IMG_SZ, GRID_IMG_SZ))
        overlay = ''

        if is_overlay:
            image = image.convert("L")
            image = ImageOps.colorize(image, black=BG_COLOR, white=FONT_COLOR)
            embed_dict = image_data['dic_info']
            overlay = embed_dict.get(is_overlay, '')

        image = ImageTk.PhotoImage(image)
        image_data['button'].config(image=image, text=overlay)
        image_data['button'].image = image
    except tk.TclError:
        raise SystemExit(0)


def refresh_images(x, y):
    '''Refresh images on the grid buttons'''

    if not image_list:
        return

    vsb.set(x, y)

    slice_start, slice_end = get_canvas_boundaries()

    for n in range(slice_start, slice_end):
        image_data = image_list[n]
        if not image_data['has_image'] and len(threading.enumerate()) < 900:
            image_data['has_image'] = True
            t = threading.Thread(target=render_buttons, args=(image_data, n,))
            t.daemon = True
            t.start()


def on_mousewheel(event):
    '''Handles mouse wheel'''

    if OS == 'Linux':
        y_steps = 5
        if event.num == 4:
            y_steps *= -1
    elif OS == 'Darwin':
        y_steps = event.delta
    elif OS == 'Windows':
        y_steps = int(-1 * (event.delta / 120))

    if 'buttons_frame' in str(event.widget):
        canvas.yview_scroll(y_steps, 'units')


def button_select(button):
    button.config(bg=ACC_COLOR1, width=GRID_IMG_SZ - 6, height=GRID_IMG_SZ - 6, bd=3, relief='ridge')


def button_unselect(button):
    button.config(bg=BG_COLOR, width=GRID_IMG_SZ, height=GRID_IMG_SZ, bd=0, relief='flat')


def click_grid_image(idx, shift=False, control=False, right=False):
    '''Handles clicking on a image on the grid'''

    global current_seed
    global prev_button
    global current_index
    global multi_index

    button = image_list[idx]['button']
    if control:
        if button.cget('bg') == BG_COLOR:
            button_select(button)
            multi_index.append(idx)
            button.focus_set()
        else:
            button_unselect(button)
            multi_index.remove(idx)
        return

    if current_index != idx and shift:
        if current_index < idx:
            idx_start, idx_end = current_index, idx
        else:
            idx_start, idx_end = idx, current_index

        for i in range(idx_start, idx_end + 1):
            if i not in multi_index:
                multi_index.append(i)
                button = image_list[i]['button']
                button_select(button)
                button.focus_set()
        return

    if (not right and not shift and multi_index) or (right and button.cget('bg') == BG_COLOR):
        for i in multi_index:
            button = image_list[i]['button']
            button_unselect(button)
        multi_index = []

    if right and button.cget('bg') == ACC_COLOR1:
        return

    multi_index = [idx]

    button = image_list[idx]['button']
    embed_text = image_list[idx]['txt_info']
    image = Image.open(image_list[idx]['file'])

    image = resize_image(image, (INFO_IMG_SZ, INFO_IMG_SZ))
    image = ImageTk.PhotoImage(image)
    img_info['image'] = image
    img_info.image = image
    img_info.config(bg=BG_COLOR)

    # Get tag information for colorizing
    matches = []
    for i, line in enumerate(embed_text.splitlines(), 1):
        for tag in TEXT_PARS:
            tag_colon = f'{tag}:'
            if line.startswith(tag_colon):
                start = f'{str(i)}.{len(tag_colon)}'
                end = f'{str(i)}.{len(line)}'
                content = line[len(tag_colon):]
                matches.append((tag_colon, start, end, content))

    # Draw text
    text_info['state'] = 'normal'
    text_info.delete('1.0', 'end')
    text_info.insert('insert', embed_text)
    for hit in matches:
        if hit[0].startswith('seed:'):
            current_seed = hit[3]
        color = ACC_COLOR2
        if hit[3].strip().replace('.', '').isdigit() \
                or hit[3].strip().replace(' x ', '').isdigit()  \
                or hit[3].strip().replace(' ', '').isdigit():
            color = ACC_COLOR1
        if hit[0].startswith('embedded info'):
            color = ACC_COLOR2
        text_info.tag_add(hit[0], hit[1], hit[2])
        text_info.tag_config(hit[0], foreground=color)
    text_info['state'] = 'disable'

    if not prev_button:
        prev_button = button

    # image_keep = button.image
    button_unselect(prev_button)
    button_select(button)
    button.focus_set()
    # button.update()

    # Give a little time for Python to come to it's senses
    time.sleep(0.05)

    prev_button = button

    current_index = idx


def grid_keys(event, delta, absolute=False, select=False):
    '''Navigate grid with the arrow keys.
    event: TK internal
    delta: Image amout to jump
    absolute: if the jump is relative or absolute (to the first or last image)'''

    global current_index

    prev_current_index = current_index

    if absolute:
        current_index = (len(image_list) - 1) * delta
    else:
        current_index = current_index + delta

    if (current_index < 0) or (current_index > len(image_list) - 1) or \
            not image_list[current_index]['search']:
        current_index = prev_current_index
        return

    image_amount = len(image_list)
    image_y = math.floor(current_index / COL_NBR)
    rows = math.ceil(image_amount / COL_NBR)
    button = image_list[current_index]['button']
    button_y = button.winfo_y()
    canvas_height = canvas.winfo_height()
    y_srt = canvas.yview()[0]
    y_end = canvas.yview()[1]
    y_len = y_end - y_srt
    total_height = int(canvas_height / y_len)
    canvas_y_top = int(total_height * y_srt)
    canvas_y_bot = int(total_height * y_end)
    canvas_position = image_y / rows
    img_len = 1 / rows

    # Only move if selection is outside the grid frame
    if (button_y > canvas_y_bot - GRID_IMG_SZ):
        canvas.yview_moveto(canvas_position - y_len + img_len)
    if (button_y <= canvas_y_top):
        canvas.yview_moveto(canvas_position)

    if select:
        click_grid_image(current_index, control=True)
    else:
        click_grid_image(current_index)

    # button.invoke()
    # button.focus_set()


def maintain_aspect_ratio(event, original, c_full_img, aspect_ratio):
    '''Maintains aspect ratio when resizing the image window'''

    new_aspect_ratio = event.width / event.height
    if new_aspect_ratio > aspect_ratio:
        desired_width = event.width
        desired_height = int(event.width / aspect_ratio)
    else:
        desired_height = event.height
        desired_width = int(event.height * aspect_ratio)

    if event.width != desired_width or event.height != desired_height:
        try:
            event.widget.geometry(f'{desired_width}x{desired_height}')
            size = (desired_width, desired_height)
            resized = original.resize(size, Image.Resampling.LANCZOS)
            image = ImageTk.PhotoImage(resized)
            c_full_img.delete('IMG')
            c_full_img.create_image(0, 0, image=image, anchor='nw', tags='IMG')
            c_full_img.image = image
        except AttributeError:
            pass
        return 'break'


def show_full_image_multi(i):
    '''Its is here so each window can have its own variable reference'''

    if not image_list:
        return

    image_window = tk.Toplevel()
    image_window.title(f'{image_list[i]["file"]}')

    original = Image.open(image_list[i]['file'])

    # Prevent showing images bigger than the screen size
    max_width = min(original.size[0], image_window.winfo_screenwidth())
    max_height = min(original.size[1], image_window.winfo_screenheight())
    original = resize_image(original, (max_width, max_height))

    image = ImageTk.PhotoImage(original)

    x = root.winfo_x()
    y = root.winfo_y() + 30 + BUTT_HEIGHT
    dimensions = f'{image.width()}x{image.height()}+{x}+{y}'
    image_window.geometry(dimensions)

    frame = tk.Frame(image_window)
    frame.columnconfigure(0, weight=1)
    frame.rowconfigure(0, weight=1)

    c_full_img = tk.Canvas(image_window, bd=0, highlightthickness=0)
    c_full_img.create_image(0, 0, image=image, anchor='nw', tags='IMG')
    c_full_img.image = image
    c_full_img.grid(row=0, sticky='news')
    c_full_img.pack(fill='both', expand=1)

    image_window.update()
    width = image_window.winfo_width()
    height = image_window.winfo_height()
    image_window.bind('<Configure>', lambda event: maintain_aspect_ratio(event, original, c_full_img, width / height))
    image_window.bind('<Escape>', lambda event: image_window.destroy())

    image_window.focus_set()


def show_full_image(idx):
    '''Handles clicking on the image preview'''

    if idx is None:
        return

    # Calling a new function each time so each window has its own variable reference
    for i in idx:
        show_full_image_multi(i)


def show_image(idx):

    if idx is None:
        return

    for i in idx:
        path = image_list[i]['file']

        if OS == 'Linux':
            default_app = subprocess.run(['xdg-mime', 'query', 'default', 'inode/directory'],
                                         stdout=subprocess.PIPE).stdout.decode('utf-8').strip()

            if default_app == 'org.kde.dolphin.desktop':
                subprocess.Popen(['dolphin', path])
            else:
                default_app == 'nautilus.desktop'
                subprocess.Popen(['nautilus', path])
        elif OS == 'Darwin':
            subprocess.Popen(["open", path])
        else:
            subprocess.Popen(["explorer", '/open,', path])


def config_requester():
    '''Main configuration window'''

    def test_weight(weight):
        weight = weight.strip()
        if weight != 'normal' and weight != 'bold' and weight != 'italic' and weight != '':
            conf_entries[7].config(bg=ALERT_COLOR)
        else:
            conf_entries[7].config(bg=ACC_COLOR1)

    def test_int(widget):
        entry = widget.get()
        if not entry.isnumeric():
            widget.config(bg=ALERT_COLOR)
        else:
            widget.config(bg=ACC_COLOR1)

    def change_button_height(size):
        '''Update the button height configuration box'''

        test_int(conf_entries[6])

        if conf_entries[6]['bg'] != ALERT_COLOR:
            conf_entries[4].delete(0, 'end')
            conf_entries[4].insert('insert', int(int(size) * 2.5))

    def pick_color(r, cur_col):
        '''Open a color picker'''

        # Open an inactive window to be able to disable the main interface
        dummy_window = tk.Toplevel()
        dummy_window.withdraw()
        config.grab_release()
        dummy_window.grab_set()

        conf_entries[r - 1].delete(0, 'end')
        color = askcolor(color=cur_col, title=conf_labels[r - 1]['text'], parent=config)[1]

        if not color:
            color = cur_col
        conf_entries[r - 1].insert('insert', color)

        dummy_window.destroy()
        config.grab_set()

        change_color(r)

    def change_color(r):
        '''Change the selected color'''

        if r < 9 or r > 13:
            return
        try:
            bt_color_list[r - 9]['bg'] = conf_entries[r - 1].get()
            conf_entries[r - 1].config(bg=ACC_COLOR1)
        except tk.TclError:
            conf_entries[r - 1].config(bg=ALERT_COLOR)

    def accept_config(button, conf_entries):
        '''Close the configuration window applying changes'''

        global COL_NBR
        global ROW_NBR
        global GRID_IMG_SZ
        global INFO_IMG_SZ
        global BUTT_HEIGHT
        global FONT
        global BG_COLOR
        global FONT_COLOR
        global ACC_COLOR1
        global ACC_COLOR2
        global ALERT_COLOR
        # global TOP_PATH

        change_button_height(conf_entries[6].get())

        button.focus_set()

        config.update()

        if conf_entries[0]['bg'] != ALERT_COLOR:
            COL_NBR = int(conf_entries[0].get())
        if conf_entries[1]['bg'] != ALERT_COLOR:
            ROW_NBR = int(conf_entries[1].get())
        if conf_entries[2]['bg'] != ALERT_COLOR:
            GRID_IMG_SZ = int(conf_entries[2].get())
        if conf_entries[3]['bg'] != ALERT_COLOR:
            INFO_IMG_SZ = int(conf_entries[3].get())
        if conf_entries[4]['bg'] != ALERT_COLOR:
            BUTT_HEIGHT = int(conf_entries[4].get())
        if conf_entries[6]['bg'] != ALERT_COLOR \
                and conf_entries[7]['bg'] != ALERT_COLOR:
            FONT = (conf_entries[5].get(),
                    int(conf_entries[6].get()),
                    conf_entries[7].get())
            BG_COLOR = bt_color_list[0]['bg']
            FONT_COLOR = bt_color_list[1]['bg']
            ACC_COLOR1 = bt_color_list[2]['bg']
            ACC_COLOR2 = bt_color_list[3]['bg']
            ALERT_COLOR = bt_color_list[4]['bg']
        # if conf_entries[13]['bg'] != ALERT_COLOR:
        #     TOP_PATH = conf_entries[13].get()

        FONT_NAME = FONT[0]
        FONT_SIZE = FONT[1]
        FONT_WEIGHT = FONT[2]

        t_scr_width = root.winfo_screenwidth() * 0.9
        t_scr_height = root.winfo_screenheight() * 0.9

        # Check if the interface will fit on the current screen size
        if (COL_NBR * GRID_IMG_SZ + INFO_IMG_SZ) > t_scr_width \
                or (ROW_NBR * GRID_IMG_SZ) > t_scr_height \
                or INFO_IMG_SZ > t_scr_height:
            tk.messagebox.showinfo(title='Bad configuration',
                                   message='Interface elements too big or too many.\n'
                                           'Will not fit within 90% of the screen.',
                                   parent=config)
            return

        if not config_ini.has_section('CONFIGS'):
            config_ini.add_section('CONFIGS')
        config_ini.set('CONFIGS', 'number_of_columns', str(COL_NBR))
        config_ini.set('CONFIGS', 'number_of_lines', str(ROW_NBR))
        config_ini.set('CONFIGS', 'grid_image_size', str(GRID_IMG_SZ))
        config_ini.set('CONFIGS', 'preview_image_size', str(INFO_IMG_SZ))
        config_ini.set('CONFIGS', 'button_height', str(BUTT_HEIGHT))
        config_ini.set('CONFIGS', 'font_name', FONT_NAME)
        config_ini.set('CONFIGS', 'font_size', str(FONT_SIZE))
        config_ini.set('CONFIGS', 'font_weight', FONT_WEIGHT)
        config_ini.set('CONFIGS', 'background_color', BG_COLOR)
        config_ini.set('CONFIGS', 'main_color', FONT_COLOR)
        config_ini.set('CONFIGS', 'accent_color_1', ACC_COLOR1)
        config_ini.set('CONFIGS', 'accent_color_2', ACC_COLOR2)
        config_ini.set('CONFIGS', 'alert_color', ALERT_COLOR)
        # config_ini.set('CONFIGS', 'default_path', TOP_PATH)

        with open(ini_path, 'w') as configfile:
            config_ini.write(configfile)

        config.destroy()
        # update_grid()
        reset_interface()

    def font_requester(r, cur_col):
        '''Create a font requester'''

        def siz_min_pls(delta, entry):
            '''Buttons to change the font size'''

            size = int(entry.get())
            size += delta
            if size < 1:
                size = 1
            entry.delete(0, 'end')
            entry.insert('insert', size)

            change_font([font_temp[0], int(size), font_temp[2]])

        def font_weight(weight, weight_list):
            '''Handles clicking on the font weight buttons'''

            global font_temp
            for item in weight_list:
                item[0]['bg'] = FONT_COLOR
                item[0]['fg'] = BG_COLOR

            weight_list[weight][0]['bg'] = BG_COLOR
            weight_list[weight][0]['fg'] = FONT_COLOR

            font_temp[2] = weight_list[weight][1]
            font_temp[1] = int(size_entry.get())

            change_font(font_temp)

        def change_font(font_arg):
            '''Change the current font'''

            global font_temp
            font_temp = font_arg
            font_preview.config(font=font_temp)

        def accept_font():
            '''Close the font requester accepting the changes'''

            conf_entries[4].delete(0, 'end')
            conf_entries[4].insert('insert', int(int(size_entry.get()) * 2.5))
            conf_entries[5].delete(0, 'end')
            conf_entries[5].insert('insert', font_temp[0])
            conf_entries[6].delete(0, 'end')
            conf_entries[6].insert('insert', size_entry.get())
            conf_entries[7].delete(0, 'end')
            conf_entries[7].insert('insert', font_temp[2])
            config.grab_set()
            config.focus_set()
            folders_req.destroy()

        dummy.focus_set()
        config.update()

        if conf_entries[5]['bg'] == ALERT_COLOR \
                or conf_entries[6]['bg'] == ALERT_COLOR \
                or conf_entries[7]['bg'] == ALERT_COLOR:
            return

        # global font_box
        global font_preview
        global size_entry
        global font_temp
        global folders_req

        font_temp = [conf_entries[5].get(),
                     int(conf_entries[6].get()),
                     conf_entries[7].get()]

        folders_req = tk.Toplevel()
        folders_req.title('Font')

        available_fonts = font.families()
        available_fonts = sorted(available_fonts)

        font_box = tk.Listbox(folders_req, highlightthickness=0, relief='flat', name='font_list',
                              bg=ACC_COLOR1, fg=BG_COLOR, selectbackground=FONT_COLOR)
        font_box.grid(row=0, columnspan=3, sticky='news')
        font_box.option_add('font', FONT)

        sb = ttk.Scrollbar(folders_req, orient='vertical')
        sb.grid(row=0, column=3, sticky='news')

        font_box.configure(yscrollcommand=sb.set)
        sb.config(command=font_box.yview)

        config.grab_release()
        folders_req.grab_set()
        folders_req.focus_set()

        for fonts in available_fonts:
            font_box.insert('end', fonts)

        # Duplicate the last element to prevent down key from overflowing the listbox items
        available_fonts.append(available_fonts[-1])

        font_box.bind("<ButtonRelease-1>", lambda e: change_font(
                      [available_fonts[font_box.curselection()[0]], int(size_entry.get()), font_temp[2]]))

        font_box.bind("<Up>", lambda e: change_font(
                      [available_fonts[font_box.curselection()[0] - 1], int(size_entry.get()), font_temp[2]]))

        font_box.bind("<Down>", lambda e: change_font(
                      [available_fonts[font_box.curselection()[0] + 1], int(size_entry.get()), font_temp[2]]))

        weight_list = []
        brd_norm_butt = tk.Frame(folders_req, bg=BG_COLOR)
        brd_norm_butt.grid(row=1, column=0, sticky='nsew')
        norm_butt = tk.Button(brd_norm_butt, text="normal", bg=FONT_COLOR, fg=BG_COLOR,
                              activebackground=ACC_COLOR1, bd=0, command=lambda: font_weight(0, weight_list))
        norm_butt.pack(expand=True, fill='both', pady=1, padx=1)
        weight_list.append([norm_butt, 'normal'])

        brd_norm_bold = tk.Frame(folders_req, bg=BG_COLOR)
        brd_norm_bold.grid(row=1, column=1, sticky='nsew')
        bold_butt = tk.Button(brd_norm_bold, text="bold", bg=FONT_COLOR, fg=BG_COLOR,
                              activebackground=ACC_COLOR1, bd=0, command=lambda: font_weight(1, weight_list))
        bold_butt.pack(expand=True, fill='both', pady=1, padx=1)
        weight_list.append([bold_butt, 'bold'])

        brd_norm_ital = tk.Frame(folders_req, bg=BG_COLOR)
        brd_norm_ital.grid(row=1, column=2, columnspan=2, sticky='nsew')
        ital_butt = tk.Button(brd_norm_ital, text="italic", bg=FONT_COLOR, fg=BG_COLOR,
                              activebackground=ACC_COLOR1, bd=0, command=lambda: font_weight(2, weight_list))
        ital_butt.pack(expand=True, fill='both', pady=1, padx=1)
        weight_list.append([ital_butt, 'italic'])

        size_entry = tk.Entry(folders_req, text="cancel", bd=0, bg=ACC_COLOR1, fg=BG_COLOR)
        size_entry.delete(0, 'end')
        size_entry.insert('insert', conf_entries[6].get())
        size_entry.bind('<Return>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
        size_entry.bind('<Tab>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
        size_entry.bind('<FocusOut>', lambda e: change_font([font_temp[0], int(size_entry.get()), font_temp[2]]))
        size_entry.grid(row=2, column=0, columnspan=2, sticky='nsew')

        brd_siz_frm = tk.Frame(folders_req, bg=BG_COLOR)
        brd_siz_frm.grid(row=2, column=2, columnspan=2, sticky='nsew')

        brd_siz_min = tk.Frame(brd_siz_frm, bg=BG_COLOR)
        brd_siz_min.grid(row=0, column=0, sticky='nsew')
        size_min = tk.Button(brd_siz_min, text="<", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                             command=lambda: siz_min_pls(-1, size_entry))
        size_min.pack(expand=True, fill='both', pady=1, padx=1)

        brd_siz_pls = tk.Frame(brd_siz_frm, bg=BG_COLOR)
        brd_siz_pls.grid(row=0, column=1, sticky='nsew')
        size_pls = tk.Button(brd_siz_pls, text=">", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                             command=lambda: siz_min_pls(1, size_entry))
        size_pls.pack(expand=True, fill='both', pady=1, padx=1)

        brd_siz_frm.columnconfigure(0, weight=1)
        brd_siz_frm.columnconfigure(1, weight=1)

        brd_ok_butt = tk.Frame(folders_req, bg=BG_COLOR)
        brd_ok_butt.grid(row=3, column=0, columnspan=2, sticky='nsew')
        ok_butt = tk.Button(brd_ok_butt, text="OK", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                            activebackground=ACC_COLOR1, command=accept_font)
        ok_butt.pack(expand=True, fill='both', pady=1, padx=1)

        brd_cancel_butt = tk.Frame(folders_req, bg=BG_COLOR)
        brd_cancel_butt.grid(row=3, column=2, columnspan=2, sticky='nsew')
        cancel_butt = tk.Button(brd_cancel_butt, text="cancel", bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                                activebackground=ACC_COLOR1, command=folders_req.destroy)
        cancel_butt.pack(expand=True, fill='both', pady=1, padx=1)

        font_preview = tk.Entry(folders_req, justify='center', bd=0,
                                bg=BG_COLOR, fg=FONT_COLOR, font=(FONT[0], FONT[1], FONT[2]))
        font_preview.insert('insert', 'Diffusion')
        font_preview.grid(row=4, columnspan=4, sticky='nsew')

        folders_req.rowconfigure(0, weight=1)
        folders_req.columnconfigure(0, weight=1)
        folders_req.columnconfigure(1, weight=1)
        folders_req.columnconfigure(2, weight=1)
        folders_req.columnconfigure(3, weight=0)

        folders_req.resizable(True, True)
        folders_req.update_idletasks()
        font_req_width = int(config.winfo_width() / 2)
        folders_req.geometry(f'{font_req_width}x{config.winfo_height()}+{config.winfo_x()}+{config.winfo_y()}')

    global config
    global conf_entries
    global conf_labels
    global bt_color_list
    global dummy

    # Create window
    config = tk.Toplevel()
    config.title('Configuration')
    config.grab_set()
    config.focus_set()
    config.option_add('*font', FONT)
    config.resizable(True, True)
    config_frame = tk.Frame(config, bg=BG_COLOR)
    config_frame.pack(expand=True, fill='both')

    # Blank label to separate interface fro window top
    dummy = tk.Label(config_frame, text=' ', bg=BG_COLOR, fg=FONT_COLOR)
    dummy.grid(row=0)

    config_frame.grid_columnconfigure(0, weight=0)
    # config_frame.grid_columnconfigure(1, weight=0)
    config_frame.grid_columnconfigure(1, weight=1)

    # Interface widgets content
    conf_cont = [['number of columns', COL_NBR, None, None],
                 ['number of rows', ROW_NBR, None, None],
                 ['gird image size', GRID_IMG_SZ, None, None],
                 ['preview image size', INFO_IMG_SZ, None, None],
                 ['button height', BUTT_HEIGHT, None, None],
                 ['font name', FONT[0], 'get', None, font_requester],
                 ['font size', FONT[1], 'get', None, font_requester],
                 ['font weight', FONT[2], 'get', None, font_requester],
                 ['background color', BG_COLOR, 'pick', BG_COLOR, pick_color],
                 ['main color', FONT_COLOR, 'pick', FONT_COLOR, pick_color],
                 ['accent color 1', ACC_COLOR1, 'pick', ACC_COLOR1, pick_color],
                 ['accent color 2', ACC_COLOR2, 'pick', ACC_COLOR2, pick_color],
                 ['alert color', ALERT_COLOR, 'pick', ALERT_COLOR, pick_color]]
    # ['Default path', TOP_PATH, 'get', None, change_config_path]]

    brd_bt_color_list = []
    bt_color_list = []
    conf_entries = []
    conf_labels = []
    for r, cont in enumerate(conf_cont, 1):
        label = tk.Label(config_frame, text=cont[0], bg=BG_COLOR, fg=FONT_COLOR)
        label.grid(row=r, column=0, sticky='e', padx=(20, 0))
        conf_labels.append(label)

        brd_bt_tbox = tk.Frame(config_frame, bg=BG_COLOR)
        brd_bt_tbox.grid(row=r, column=1, sticky='wens')
        tbox = tk.Entry(brd_bt_tbox, bg=ACC_COLOR1, fg=BG_COLOR, width=30, bd=0, name=str(r),
                        selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2)
        tbox.insert('insert', cont[1])
        tbox.pack(expand=True, fill='both', pady=1, padx=1)
        conf_entries.append(tbox)

        config_frame.rowconfigure(r, weight=1)

        if r > 8 and r < 14:
            tbox.bind('<Return>', lambda event, nbr=r: change_color(nbr))
            tbox.bind('<FocusOut>', lambda event, nbr=r: change_color(nbr))

        if (r > 0 and r < 6):
            tbox.bind('<Return>', lambda event, widget=tbox: test_int(widget))
            tbox.bind('<FocusOut>', lambda event, widget=tbox: test_int(widget))

        if cont[2]:
            brd_bt_action = tk.Frame(config_frame, bg=BG_COLOR)
            brd_bt_action.grid(row=r, column=2, sticky='wens')
            action = tk.Button(brd_bt_action, text=cont[2], bd=0,
                               bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
            action.bind('<ButtonRelease-1>', lambda event, func=cont[4], nbr=r, cur_col=cont[3]: func(nbr, cur_col))
            action.pack(expand=True, fill='both', pady=1, padx=1)

        if cont[3]:
            brd_bt_color = tk.Frame(config_frame, bg=BG_COLOR)
            brd_bt_color.grid(row=r, column=3, sticky='wens', padx=(0, 20))
            color = tk.Button(brd_bt_color, text='   ', bd=0, bg=cont[3], activebackground=cont[3])
            color.pack(expand=True, fill='both', pady=1, padx=1)
            color.bind('<ButtonRelease-1>', lambda event, func=cont[4], nbr=r, cur_col=cont[3]: func(nbr, cur_col))
            brd_bt_color_list.append(brd_bt_color)
            bt_color_list.append(color)

    brd_bt_color_list[0]['bg'] = FONT_COLOR

    # Align path text to the right
    # conf_entries[13].xview_moveto(1)

    conf_entries[6].bind('<Return>', lambda e: change_button_height(conf_entries[6].get()))
    conf_entries[6].bind('<FocusOut>', lambda e: change_button_height(conf_entries[6].get()))

    conf_entries[7].bind('<Return>', lambda e: test_weight(conf_entries[7].get()))
    conf_entries[7].bind('<FocusOut>', lambda e: test_weight(conf_entries[7].get()))

    # conf_entries[r - 1].bind('<Return>', lambda e, nbr=r: test_path(nbr, conf_entries[r - 1].get()))
    # conf_entries[r - 1].bind('<FocusOut>', lambda e, nbr=r: test_path(nbr, conf_entries[r - 1].get()))

    btn_frame = tk.Frame(config_frame, bg=BG_COLOR)
    btn_frame.grid(row=r + 1, columnspan=4, sticky='ew', pady=(20, 20))
    btn_frame.grid_columnconfigure(0, weight=1)
    btn_frame.grid_columnconfigure(1, weight=1)

    brd_bt_btn_accept = tk.Frame(btn_frame, bg=BG_COLOR)
    brd_bt_btn_accept.grid(row=0, column=0, sticky='wens', padx=(20, 0))
    btn_accept = tk.Button(brd_bt_btn_accept, text='OK (restart)',
                           bg=FONT_COLOR, fg=BG_COLOR, bd=0, activebackground=ACC_COLOR1)
    btn_accept['command'] = lambda conf_entries=conf_entries: accept_config(btn_accept, conf_entries)
    btn_accept.pack(expand=True, fill='both', pady=1, padx=1)

    brd_btn_cancel = tk.Frame(btn_frame, bg=BG_COLOR)
    brd_btn_cancel.grid(row=0, column=1, sticky='wens', padx=(0, 20))
    btn_cancel = tk.Button(brd_btn_cancel, text='cancel', bd=0, command=config.destroy,
                           bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    btn_cancel.pack(expand=True, fill='both', pady=1, padx=1)

    config.update()
    x = root.winfo_x() + root.winfo_width() - config.winfo_width()
    y = root.winfo_y() + 30 + BUTT_HEIGHT
    config.geometry(f'+{x}+{y}')


def folders_requester():
    '''Create a folders requester'''

    def tree_sort_column(widget, col, reverse):
        l = [(widget.set(k, col), k) for k in widget.get_children('')]
        l.sort(reverse=reverse)

        for index, (_, k) in enumerate(l):
            widget.move(k, '', index)

        widget.heading(col, command=lambda: tree_sort_column(widget, col, not reverse))

    def tree_double_click(event, widget, parent):
        column_subf = widget.column('subf', 'width')
        column_path = widget.column('path', 'width')
        column_active = widget.column('active', 'width')

        if event.x <= column_subf:
            toggle_subfolders(widget)
        elif event.x <= column_path + column_subf:
            change_folder(widget, parent)
        elif event.x <= column_active + column_path + column_subf:
            toggle_active_folders(widget)

    def add_folder(widget, parent):
        '''Add path'''

        folder_selected = filedialog.askdirectory(parent=parent)

        if folder_selected:
            folder_selected = os.path.normpath(folder_selected)
            widget.insert('', 'end', text=('', folder_selected, ''), value=('', folder_selected, ''))

    def change_folder(widget, parent):
        '''Change path'''
        if not widget.selection():
            return

        folder_selected = filedialog.askdirectory(parent=parent)

        if folder_selected:
            folder_selected = os.path.normpath(folder_selected)
            item = widget.selection()[0]
            widget.item(item, text=('', folder_selected, ''), value=('', folder_selected, ''))

    def toggle_subfolders(widget):
        if not widget.selection():
            return

        for item in widget.selection():
            item_values = widget.item(item)['values']
            subfolders = 'YES' if item_values[0] == '' else ''
            widget.item(item, text=(subfolders, item_values[1], item_values[2]), value=(subfolders, item_values[1], item_values[2]))

    def toggle_active_folders(widget):
        if not widget.selection():
            return

        for item in widget.selection():
            item_values = widget.item(item)['values']
            active = 'NO' if item_values[2] == '' else ''
            widget.item(item, text=(item_values[0], item_values[1], active), value=(item_values[0], item_values[1], active))

    def delete_folders(widget, parent):
        if not widget.selection():
            return
        quantity = len(widget.selection())
        message = f'{widget.item(widget.focus())["values"][1]} ' if quantity == 1 else f'{len(widget.selection())} items'
        query = tk.messagebox.askquestion(title='Delete item', message=f'Really delete {message}?', parent=parent)
        if query == 'yes':
            for item in widget.selection():
                widget.delete(item)

    def save_folders(widget, parent):
        global folders

        folders = []
        for item in widget.get_children():
            child = widget.item(item)["values"]
            subfolders = '1' if child[0] == 'YES' else '0'
            active = '0' if child[2] == 'NO' else '1'
            folders.append((subfolders, child[1], active))

        json_object = json.dumps(folders)

        with open(FOLDERS_FILE, "w") as f:
            f.write(json_object)

        parent.destroy()

        update_grid()

    folders_req = tk.Toplevel()
    folders_req.title('Paths')

    root.grab_release()
    folders_req.grab_set()
    folders_req.focus_set()

    folders_req.rowconfigure(0, weight=1)
    folders_req.columnconfigure(0, weight=1)
    folders_req.columnconfigure(1, weight=0)

    folders_tree = ttk.Treeview(folders_req, column=('subf', 'path', 'active'), show='headings', height=100)
    folders_tree.heading('#0', text=' \n\n')
    folders_tree.heading('subf', text='subf\n', command=lambda: tree_sort_column(folders_tree, 'subf', False))
    folders_tree.heading('path', text='paths\n', command=lambda: tree_sort_column(folders_tree, 'path', False))
    folders_tree.heading('active', text='active\n', command=lambda: tree_sort_column(folders_tree, 'active', False))
    folders_tree.column('subf', width=FONT[1] * 3, stretch='no')
    folders_tree.column('active', width=FONT[1] * 4, stretch='no')
    folders_tree.option_add('*font', FONT)
    folders_tree.grid(row=0, sticky='news')

    folders_tree.bind("<Double-1>", lambda event: tree_double_click(event, folders_tree, folders_req))
    folders_tree.bind("<Return>", lambda event: toggle_subfolders(folders_tree))
    folders_tree.bind("<space>", lambda event: toggle_subfolders(folders_tree))
    folders_tree.bind("<Shift-Return>", lambda event: toggle_active_folders(folders_tree))
    folders_tree.bind("<Shift-space>", lambda event: toggle_active_folders(folders_tree))

    sb_folders = ttk.Scrollbar(folders_req, orient='vertical')
    sb_folders.grid(row=0, column=1, sticky='news')
    folders_tree.configure(yscrollcommand=sb_folders.set)
    sb_folders.config(command=folders_tree.yview)

    for folder in folders:
        recursive = 'YES' if folder[0] == '1' else ''
        active = 'NO' if folder[2] == '0' else ''
        folders_tree.insert('', 'end', text=(recursive, folder[1], active), value=(recursive, folder[1], active))

    brd_upper_butt = tk.Frame(folders_req, bg=BG_COLOR)
    brd_upper_butt.grid(row=2, column=0, columnspan=2, sticky='nsew')

    brd_upper_butt.columnconfigure(0, weight=1)
    brd_upper_butt.columnconfigure(1, weight=1)
    brd_upper_butt.columnconfigure(2, weight=1)
    brd_upper_butt.columnconfigure(3, weight=1)
    brd_upper_butt.columnconfigure(4, weight=1)
    brd_upper_butt.columnconfigure(5, weight=1)

    brd_get_butt = tk.Frame(brd_upper_butt, bg=BG_COLOR)
    brd_get_butt.grid(row=0, column=0, sticky='nsew')
    get_butt = tk.Button(brd_get_butt, text="add", bg=FONT_COLOR, fg=BG_COLOR,
                         activebackground=ACC_COLOR1, bd=0)
    get_butt.bind('<Button-1>', lambda event: add_folder(folders_tree, folders_req))
    get_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_change_butt = tk.Frame(brd_upper_butt, bg=BG_COLOR)
    brd_change_butt.grid(row=0, column=1, sticky='nsew')
    change_butt = tk.Button(brd_change_butt, text="change", bg=FONT_COLOR, fg=BG_COLOR,
                            activebackground=ACC_COLOR1, bd=0, command=lambda: change_folder(folders_tree, folders_req))
    change_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_open_butt = tk.Frame(brd_upper_butt, bg=BG_COLOR)
    brd_open_butt.grid(row=0, column=2, sticky='nsew')
    open_butt = tk.Button(brd_open_butt, text="open", bg=FONT_COLOR, fg=BG_COLOR,
                          activebackground=ACC_COLOR1, bd=0, command=lambda: explore_folder(folders_tree.item(folders_tree.focus())))
    open_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_subf_butt = tk.Frame(brd_upper_butt, bg=BG_COLOR)
    brd_subf_butt.grid(row=0, column=3, sticky='nsew')
    subf_butt = tk.Button(brd_subf_butt, text="toggle subfolders", bg=FONT_COLOR, fg=BG_COLOR,
                          activebackground=ACC_COLOR1, bd=0, command=lambda: toggle_subfolders(folders_tree))
    subf_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_active_butt = tk.Frame(brd_upper_butt, bg=BG_COLOR)
    brd_active_butt.grid(row=0, column=4, sticky='nsew')
    active_butt = tk.Button(brd_active_butt, text="toggle active", bg=FONT_COLOR, fg=BG_COLOR,
                            activebackground=ACC_COLOR1, bd=0, command=lambda: toggle_active_folders(folders_tree))
    active_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_del_butt = tk.Frame(brd_upper_butt, bg=BG_COLOR)
    brd_del_butt.grid(row=0, column=5, sticky='nsew')
    del_butt = tk.Button(brd_del_butt, text="delete", bg=ALERT_COLOR, fg=BG_COLOR,
                         activebackground=ACC_COLOR1, bd=0, command=lambda: delete_folders(folders_tree, folders_req))
    del_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_lower_butt = tk.Frame(folders_req, bg=BG_COLOR)
    brd_lower_butt.grid(row=3, column=0, columnspan=2, sticky='nsew')

    brd_lower_butt.columnconfigure(0, weight=1)
    brd_lower_butt.columnconfigure(1, weight=1)

    brd_ok_butt = tk.Frame(brd_lower_butt, bg=BG_COLOR)
    brd_ok_butt.grid(row=0, column=0, sticky='nsew')
    ok_butt = tk.Button(brd_ok_butt, text='OK (rebuild)', bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                        activebackground=ACC_COLOR1, command=lambda: save_folders(folders_tree, folders_req))
    ok_butt.pack(expand=True, fill='both', pady=1, padx=1)

    brd_cancel_butt = tk.Frame(brd_lower_butt, bg=BG_COLOR)
    brd_cancel_butt.grid(row=0, column=1, sticky='nsew')
    cancel_butt = tk.Button(brd_cancel_butt, text='cancel', bd=0, bg=FONT_COLOR, fg=BG_COLOR,
                            activebackground=ACC_COLOR1, command=folders_req.destroy)
    cancel_butt.pack(expand=True, fill='both', pady=1, padx=1)

    folders_req.resizable(True, True)
    folders_req.update_idletasks()
    folders_req.update()
    x = root.winfo_x() + root.winfo_width() - 800
    y = root.winfo_y() + 30 + BUTT_HEIGHT
    folders_req.geometry(f'800x400+{x}+{y}')


def copy_to_clipboard(event, info=''):
    '''Copy to clipboard'''
    try:
        if event:
            if event.num == 1:
                info = text_info.get('sel.first', 'sel.last')
            else:
                text_info.focus_set()
                text_info.tag_add('sel', "1.0", 'end')
                info = text_info.get('1.0', 'end')
                text_info.update()
                time.sleep(0.1)
                text_info.tag_remove('sel', "1.0", 'end')
        root.clipboard_clear()
        root.clipboard_append(info)
        root.update()
    except tk.TclError:
        return


def explore_folder(path, select=False):
    '''Open explorer on the current location'''

    if not image_list:
        return

    if not path or path == 0:
        return

    if isinstance(path, dict):
        if not path['values']:
            return

        path = [path['values'][1]]

    for p in path:

        if isinstance(p, int):
            p = image_list[p]['file']

        p = os.path.normpath(p)

        if OS == 'Linux':
            option = '--select' if select else ''
            default_app = subprocess.run(['xdg-mime', 'query', 'default', 'inode/directory'],
                                         stdout=subprocess.PIPE).stdout.decode('utf-8').strip()

            if default_app == 'org.kde.dolphin.desktop':
                subprocess.Popen(['dolphin', option, p])
            elif default_app == 'nautilus.desktop':
                subprocess.Popen(['nautilus', option, p])
            else:
                subprocess.Popen(['xdg-open', option, p])

        elif OS == 'Darwin':
            option = '-R' if select else ''
            subprocess.Popen(["open", option, p])

        else:
            option = '/select,' if select else '/open,'
            subprocess.Popen(["explorer ", option, p])


def save_info(idx, ask=False):
    '''Save the image information to a text file'''

    if not idx:
        return

    for i in idx:
        embed_text = image_list[i]['txt_info']

        orig_file = image_list[i]['file']
        orig_file = os.path.splitext(orig_file)[0]
        orig_file = f'{orig_file}.txt'
        orig_name = os.path.basename(orig_file)

        if ask:
            orig_file = filedialog.asksaveasfile(initialfile=orig_name)
            if not orig_file:
                continue
            orig_file = orig_file.name

        with open(orig_file, 'w') as f:
            f.write(embed_text)


def reset_interface():
    '''Resets the program'''

    frame_all.destroy()
    main()


def clear_info():
    '''Clear current image and text information'''

    img_info.config(bg=FONT_COLOR, text=PROGRAM_NAME, image='')
    text_info['state'] = 'normal'
    text_info.delete('1.0', 'end')
    text_info.insert('insert', TEXT_INFO_DEFAULT)
    text_info['state'] = 'disable'


def parse_key_value(text):
    # Regular expression pattern to extract key-value pairs
    pattern = r'([^:]+):\s*("[^"\\]*(?:\\.[^"\\]*)*"|[^,\n]+)'
    text = text.replace('\\"', "'")
    matches = re.findall(pattern, text)
    key_values = {}
    for match in matches:
        key = match[0].strip()  # Strip leading/trailing spaces
        value = match[1].strip('"')  # Strip quotes if present
        key_values[key] = value
    return key_values


def read_image_info(original_image, image_path):
    '''Read the images embedded information'''

    def flatten_list(orig_list):
        if orig_list == []:
            return orig_list
        if isinstance(orig_list[0], list):
            return flatten_list(orig_list[0]) + flatten_list(orig_list[1:])
        return orig_list[:1] + flatten_list(orig_list[1:])

    global new_pars

    source = ''
    embed = OrderedDict()
    embed_par = OrderedDict()
    image_format = original_image.format.upper()
    metadata_error = None

    if image_format == 'PNG':
        embed = original_image.text
        embed_raw = ''.join(str(embed))

    elif image_format == 'JPEG':
        img_exif = original_image._getexif()
        embed_raw = ''.join(str(img_exif))

        if img_exif is not None:
            embed = list(img_exif.items())[1][1]

            if not isinstance(embed, int) and not isinstance(embed, str):
                embed = [chr(d) for d in embed if d > 0]
                embed = ''.join(embed)
                embed = embed.removeprefix('UNICODE')

                if embed.startswith('Upscale:'):
                    embed = {'extras': embed}
                else:
                    embed = {'parameters': embed}

    if embed:
        try:
            if isinstance(embed, int) or isinstance(embed, str):
                embed = {}

            is_fooocus = ''
            if 'fooocus_scheme' in embed.keys():
                is_fooocus = 'pure'
                if embed['fooocus_scheme'] == 'a1111':
                    embed = {'parameters': embed['parameters']}
                    is_fooocus = 'a1111'

            if is_fooocus == 'pure':
                source = 'fooocus'
                parameters = json.loads(embed['parameters'])
                for par in parameters:
                    title = par
                    title = title.strip().lower()
                    content = parameters[par]
                    if isinstance(content, list):
                        content = flatten_list(content)
                        content = map(str, content)
                        content = ', '.join(content)
                    if isinstance(content, int) or isinstance(content, float):
                        content = str(content)
                    content = content.strip().lower()
                    embed_par[title] = content

            elif 'parameters' in embed.keys():
                source = 'fooocus' if is_fooocus == 'a1111' else 'automatic1111'
                parameters = embed['parameters']
                prompt = parameters.partition('Steps: ')[0]
                negative_prompt = prompt.partition('Negative prompt: ')[2]
                parameters = 'Steps: ' + parameters.partition('Steps: ')[2]

                if negative_prompt:
                    prompt = prompt.partition('Negative prompt: ')[0]
                    embed_par['prompt'] = prompt.strip().replace('\n', ', ')
                    embed_par['negative prompt'] = negative_prompt.strip().replace('\n', ', ')
                else:
                    embed_par['prompt'] = prompt.strip()

                parameters = parse_key_value(parameters)

                for par in parameters:
                    title = par
                    title = title.strip().lstrip(', ').lower()
                    content = parameters[par]
                    content = content.strip().lower()
                    embed_par[title] = content

            elif 'extras' in embed.keys():
                source = 'automatic1111 extras'
                modules = embed['extras'].split('\n')
                embed_par = {}
                for c, module in enumerate(modules):
                    parameters = parse_key_value(module)
                    for par in parameters:
                        if par:
                            title = par
                            title = f'{title.strip().lstrip(", ").lower()} {str(c + 1)}'
                            content = parameters[par]
                            content = content.strip().lower()
                            embed_par[title] = content
            else:
                try:
                    source = list(embed.keys())[0]
                    embed_par = json.loads(embed[source])
                except (json.decoder.JSONDecodeError, IndexError):
                    embed_par['embedded info'] = embed_raw
        # Sorry for that but these metadata are a mess, never know what may come out of them.
        except Exception as e:
            embed_par['embedded info'] = embed_raw
            metadata_error = (image_path, str(e))

    else:
        embed_par['embedded info'] = 'no information'

    # Additional information
    real_size = original_image.size[0], original_image.size[1]

    img_format = os.path.basename(image_path)
    img_format = img_format.split('.')[-1]

    file_time = os.path.getmtime(image_path)
    file_time = datetime.datetime.fromtimestamp(file_time)
    file_time = file_time.strftime(time_format)

    embed_par[' '] = '\n'
    if source:
        embed_par['source'] = source.lower()
    embed_par['real_size'] = f'{real_size[0]} x {real_size[1]}'
    embed_par['format'] = img_format
    embed_par['created'] = str(file_time)
    embed_par['path'] = os.path.normpath(image_path)

    dif_pars = list(set(embed_par.keys()) - set(TEXT_PARS))
    for par in dif_pars:
        if par not in new_pars and par.strip() != '':
            new_pars.append(par)

    temp_text_pars = TEXT_PARS
    pos = len(temp_text_pars) - 6
    temp_text_pars[pos:pos] = new_pars
    temp_par = OrderedDict()
    for item in temp_text_pars:
        if item in embed_par:
            temp_par[item] = embed_par[item]
    embed_par = temp_par

    embed_list = []
    for key in embed_par:
        if key != ' ':
            embed_list.append(f'{key}: {embed_par[key]}\n')
        else:
            embed_list.append('\n')

    embed_txt = ''.join(embed_list)

    return embed_txt, embed_par, metadata_error


def progress_bar(amount, message, start=0):
    # Create progress bar
    restart = tk.Toplevel()
    restart.title(f'Processing')
    restart.resizable(False, False)
    restart.bind('<Escape>', lambda event: restart.destroy())
    restart_frame = tk.Frame(restart, bg=BG_COLOR)
    restart_frame.pack(expand=True, fill='both')

    load_img = tk.Label(restart_frame, bg=BG_COLOR, fg=FONT_COLOR,
                        font=(FONT[0], int(FONT[1] * 1.2), FONT[2]),
                        text=message)
    load_img.pack(pady=0, padx=50)

    loading = tk.Label(restart_frame, bg=BG_COLOR, fg=ACC_COLOR1,
                       font=(FONT[0], int(FONT[1] * 1.2), FONT[2]),
                       text=f'{start} of {amount}')
    loading.pack(pady=0, padx=50)

    bar_lenght = GRID_IMG_SZ * (COL_NBR + BORDER * 2) / 2
    style = ttk.Style()
    style.configure('TProgressbar', relief='flat', borderwidth=0, background=FONT_COLOR, foreground=BG_COLOR)
    progress = ttk.Progressbar(restart_frame, orient='horizontal', length=bar_lenght, mode='determinate')
    progress.pack(pady=10, padx=50)

    # Update restart to get width and height
    restart.update()

    x = root.winfo_x() + int((((GRID_IMG_SZ + BORDER * 2) * COL_NBR) - restart.winfo_width()) / 2)
    y = root.winfo_y() + BUTT_HEIGHT + int((((GRID_IMG_SZ + BORDER * 2) * ROW_NBR) - restart.winfo_height()) / 2)
    restart.geometry(f'+{x}+{y}')

    return loading, progress, restart


def save_image(event, idx, single=False):

    if idx == 0:
        return

    if single:
        dest_path = filedialog.askdirectory()
        if not dest_path:
            return

    for i in idx:
        orig_file = image_list[i]['file']
        orig_name = os.path.basename(orig_file)

        if single:
            dest_file = os.path.join(dest_path, orig_name)
        else:
            dest_file = filedialog.asksaveasfile(initialfile=orig_name)
            if not dest_file:
                continue
            dest_file = dest_file.name

        shutil.copy2(orig_file, dest_file)


def overlay_info(parameter_string):
    '''Overlay information on grid image'''
    # if len(threading.enumerate()) > ROW_NBR:
    #     return

    global is_overlay

    for image_data in image_list:
        image_data['has_image'] = False

    parameter_string = parameter_string.strip()

    if parameter_string != ALL_PARAMETERS and parameter_string != '':
        is_overlay = parameter_string
    else:
        is_overlay = ''

    refresh_images(vsb.get()[0], vsb.get()[1])


def expose_images(search_string, parameter_string, invert=False, exact=False):
    '''Disable non matching images'''
    # if len(threading.enumerate()) > ROW_NBR:
    #     return

    search_string = enter_search(search_string)
    parameter_string = parameter_string.strip()

    for image_data in image_list:
        embed_dict = image_data['dic_info']
        embed_text = image_data['txt_info']

        if parameter_string != ALL_PARAMETERS and parameter_string != '':
            embed_text = embed_dict.get(parameter_string, '')

        image_data['button'].config(bg=BG_COLOR, state='normal')

        if exact:
            if invert:
                if search_string.lower() == embed_text.lower():
                    image_data['button'].config(bg=ACC_COLOR2, state='disabled')
            else:
                if search_string.lower() != embed_text.lower():
                    image_data['button'].config(bg=ACC_COLOR2, state='disabled')
        else:
            if invert:
                if search_string.lower() in embed_text.lower():
                    image_data['button'].config(bg=ACC_COLOR2, state='disabled')
            else:
                if search_string.lower() not in embed_text.lower():
                    image_data['button'].config(bg=ACC_COLOR2, state='disabled')


def enter_search(search_string):
    '''When entering the search box'''

    if search_string == SEARCH_HELP:
        entry_search.configure(fg=BG_COLOR)
        entry_search.delete(0, 'end')
        return ''

    return search_string


def search_images(search_string, parameter_string, invert=False, exact=False):
    '''Sow images matching a search string'''
    # if len(threading.enumerate()) > ROW_NBR:
    #     return

    global image_list

    if not image_list:
        return

    if parameter_string == 'path':
        search_string = os.path.normpath(search_string)

    search_string = enter_search(search_string)
    parameter_string = parameter_string.strip()

    reverse_label = f'not ' if invert else ''
    search_label = 'all' if search_string == '' else search_string
    parameter_label = 'all' if parameter_string == '' else parameter_string
    exact_label = ', exact' if exact else ''
    loading, progress, restart = progress_bar(amount=1, message='Searching', start=1)
    loading['text'] = f'{reverse_label}{search_label} in {parameter_label}{exact_label}'
    progress['value'] = 100
    progress.update()

    for image_data in image_list:

        embed_text = image_data['txt_info']
        embed_dict = image_data['dic_info']

        embed_search = embed_text

        image_data['search'] = False

        if parameter_string != ALL_PARAMETERS and parameter_string != '':
            embed_search = embed_dict.get(parameter_string, '')

        if exact:
            if invert:
                if search_string.lower() != embed_search.lower():
                    image_data['search'] = True
            else:
                if search_string.lower() == embed_search.lower():
                    image_data['search'] = True
        else:
            if invert:
                if search_string.lower() not in embed_search.lower():
                    image_data['search'] = True
            else:
                if search_string.lower() in embed_search.lower():
                    image_data['search'] = True

    image_list.sort(key=itemgetter('search'), reverse=True)

    if parameter_string != 'path':
        lbl_path.current(0)

    modify_grid()
    clear_info()

    restart.destroy()


def sort_images(parameter_string, reverse=None):
    '''Sort the images'''
    # if len(threading.enumerate()) > ROW_NBR:
    #     return

    global image_list
    global sort_reverse

    parameter_string = parameter_string.strip()

    if parameter_string == ALL_PARAMETERS or parameter_string == '':
        parameter_string = 'created'

    if reverse is not None:
        sort_reverse = not reverse

    reverse_label = f', reverse' if sort_reverse else ''
    loading, progress, restart = progress_bar(amount=1, message='Sorting', start=1)
    loading['text'] = f'{parameter_string}{reverse_label}'
    progress['value'] = 100
    progress.update()

    for c, image_data in enumerate(image_list):

        embed_dict = image_data['dic_info']

        sort = embed_dict.get(parameter_string, '')
        if parameter_string == 'created':
            sort = datetime.datetime.strptime(sort, time_format)
        image_list[c]['sort'] = sort

    # if all items are int make them all int()
    if all(str(items['sort']).isdigit() or items['sort'] == '' for items in image_list):
        for c, image_data in enumerate(image_list):
            image_list[c]['sort'] = int(image_data['sort']) if image_data['sort'] != '' else 0

    sort_reverse = not sort_reverse
    image_list.sort(key=itemgetter('sort'), reverse=sort_reverse)

    modify_grid()
    clear_info()

    restart.destroy()


def modify_grid():
    global prev_button
    global multi_index
    global current_index

    if not image_list:
        return

    images = 0
    bx = 0
    by = 0
    for idx, image_data in enumerate(image_list):

        button = image_data['button']

        if not image_data['search']:
            button.grid_forget()
            continue

        button.grid(row=bx, column=by)
        button = modify_button(button, idx)

        by += 1
        if by % COL_NBR == 0:
            by = 0
            bx += 1

        images += 1

        button_unselect(button)

    lbl_files.config(text=f'{images} images')

    button = None
    prev_button = None
    current_index = 0
    multi_index = []

    # prev_button = button

    canvas.yview_moveto('0')
    refresh_images(vsb.get()[0], vsb.get()[1])

    canvas_height = max((images // COL_NBR) * (GRID_IMG_SZ + BORDER * 2) + GRID_IMG_SZ, canvas.winfo_height())
    canvas.configure(scrollregion=(0, 0, canvas.winfo_width(), canvas_height))


def search_paths():
    path = lbl_path.get()

    if path == ALL_FOLDERS or path == '':
        path = ''

    lbl_path.selection_clear()
    search_images(path, 'path')


def generate_image_list(files):
    global image_list_master
    global COMBO_VALUES
    global TEXT_PARS

    t = len(files)
    loading, progress, restart = progress_bar(t, 'Loading data, please wait.')

    # Get images data
    image_list_temp = []
    image_error = []
    metadata_errors = []

    for idx, file in enumerate(files):
        try:
            original_image = Image.open(file)
        except UnidentifiedImageError:
            image_error.append(file)
            continue
        embed_text, embed_dict, metadata_error = read_image_info(original_image, file)
        if metadata_error:
            metadata_errors.append(metadata_error)

        item_dict = {'button': None,
                     'has_image': False,
                     'txt_info': embed_text,
                     'dic_info': embed_dict,
                     'file': os.path.normpath(file),
                     'search': True,
                     'sort': ''}

        image_list_temp.append(item_dict)

        prog = int(idx / t * 100)
        try:
            loading['text'] = f'{idx} of {t}'
            progress['value'] = prog
        except tk.TclError:
            break
        progress.update()

    lbl_files.config(text=f'{idx} images')

    image_list_master = image_list_temp

    lbl_files.config(text=f'{idx} images')
    restart.destroy()

    if metadata_errors:
        metadata_errors_copy = ''
        metadata_errors_clipboard = ''
        for n, error in enumerate(metadata_errors):
            error_str = ' - '.join(error)
            error_str_clipboard = '", Error: "'.join(error)
            if n < 10:
                metadata_errors_copy += f'{error_str}\n'
            elif n == 10:
                metadata_errors_copy += 'and more...\n'

            metadata_errors_clipboard += f'Path: "{error_str_clipboard}"\n'

        tense = [''] if len(metadata_errors) <= 1 else ['s']

        copy_to_clipboard(None, metadata_errors_clipboard)

        message = (f'Failed to parse metadata from {len(metadata_errors)} image{tense[0]}.\n\n'
                   f'{metadata_errors_copy}\n'
                   f'Full information copied to the clipboard.\n\n')
        tk.messagebox.showinfo(title='Metadata error.', message=message, parent=root)

    if image_error:
        image_error_copy = '\n'.join(image_error)

        tense = [''] if len(image_error) <= 1 else ['s']

        copy_to_clipboard(None, image_error_copy)

        message = (f'Found {len(image_error)} image{tense[0]} with error.\n\n'
                   f'{image_error_copy}\n\n'
                   f'Path{tense[0]} copied to the clipboard.')
        tk.messagebox.showinfo(title='Image error.', message=message, parent=root)

    if new_pars:
        pars_copy = '\n'.join(new_pars)

        tense = ['', 'it', 'its', 'it', 'was'] if len(new_pars) <= 1 else ['s', 'them', 'their', 'they', 'were']

        message = (f'Found {len(new_pars)} new parameter{tense[0]}.\n\n'
                   f'{pars_copy}\n\n'
                   f'{tense[3].capitalize()} {tense[4]} added to the parameters.txt.\n'
                   f'You can change {tense[2]} order on the file.\n')

        tk.messagebox.showinfo(title='New parameter found.', message=message, parent=root)

        copy_to_clipboard(None, pars_copy)

        with open(PARAMETERS_FILE, 'r') as file:
            TEXT_PARS = file.read().splitlines()

        pos = len(TEXT_PARS) - 6
        TEXT_PARS[pos:pos] = new_pars

        with open(PARAMETERS_FILE, 'w') as file:
            file.write('\n'.join(TEXT_PARS))

        COMBO_VALUES = TEXT_PARS
        COMBO_VALUES.insert(0, ALL_PARAMETERS)

    return image_list_temp


def update_grid():
    '''Update new / deleted images files'''

    global image_list

    old_files = [image_data['file'] for image_data in image_list]
    new_files = get_image_paths()

    if collections.Counter(old_files) == collections.Counter(new_files):
        return True

    deleted_files = list(set(old_files) - set(new_files))
    new_files = list(set(new_files) - set(old_files))

    # Make a new list without the images on the deleted list
    # Also flag the ones not deleted as not having images so they can refresh
    # Reset the search and sort parameters
    image_list_temp = []
    for image_data in image_list:
        if image_data['file'] not in deleted_files:
            image_data['has_image'] = False
            image_data['search'] = True
            image_data['sort'] = ''
            image_list_temp.append(image_data)
        else:
            image_data['button'].destroy()

        image_list = image_list_temp

    if new_files:
        image_list_temp = generate_image_list(new_files)
        image_list.extend(image_list_temp)

    image_list_temp = []
    for image_data in image_list:
        image_list_temp.append(image_data.copy())
        image_list_temp[-1]['button'] = None

    with bz2.BZ2File(DATA_FILE, 'wb') as f:
        pickle.dump(image_list_temp, f)

    del image_list_temp

    create_grid()
    sort_images('', reverse=True)
    clear_info()

    lbl_files.config(text=f'{len(image_list)} images')


def create_grid():
    '''Create grid buttons'''
    global image_list

    if not image_list:
        return

    for idx, image_data in enumerate(image_list):
        if image_data['button'] is None:
            button = create_button(blank_image, idx)
            button.config(bg=BG_COLOR)  # Needed to make disabled show correct bg color without affecting border at start
            image_data['button'] = button


def create_button(image, index):

    button = tk.Button(frame_buttons, width=GRID_IMG_SZ, height=GRID_IMG_SZ, borderwidth=0,
                       relief='flat', name=str(index), image=image, highlightthickness=BORDER,
                       activebackground=BG_COLOR, bg=ACC_COLOR2, fg=ACC_COLOR1, bd=0,
                       compound="center", wraplength=GRID_IMG_SZ,
                       justify='center', padx=0, pady=0)

    return button


def modify_button(button, index):

    # button['command'] = lambda index=index: click_grid_image(index)
    button.bind('<Button-1>', lambda event, index=index: click_grid_image(index))
    button.bind('<Shift-Button-1>', lambda event, index=index: click_grid_image(index, shift=True))
    button.bind('<Control-Button-1>', lambda event, index=index: click_grid_image(index, control=True))

    button.bind('<Left>', lambda event: grid_keys(event, -1))
    button.bind('<Right>', lambda event: grid_keys(event, 1))
    button.bind('<Up>', lambda event: grid_keys(event, -COL_NBR))
    button.bind('<Down>', lambda event: grid_keys(event, COL_NBR))

    button.bind('<Shift-Left>', lambda event: grid_keys(event, -1, select=True))
    button.bind('<Shift-Right>', lambda event: grid_keys(event, 1, select=True))
    button.bind('<Shift-Up>', lambda event: grid_keys(event, -COL_NBR, select=True))
    button.bind('<Shift-Down>', lambda event: grid_keys(event, COL_NBR, select=True))

    root.bind('<Alt-Up>', lambda event: grid_keys(event, -COL_NBR * ROW_NBR + COL_NBR))
    root.bind('<Alt-Down>', lambda event: grid_keys(event, COL_NBR * ROW_NBR - COL_NBR))

    root.bind('<Control-Up>', lambda event: grid_keys(event, 0, True))
    root.bind('<Control-Down>', lambda event: grid_keys(event, 1, True))

    button.bind('<Double-Button-1>', lambda event, index=index: show_full_image([index]))
    button.bind('<Return>', lambda event: show_full_image(multi_index))
    button.bind('<space>', lambda event: show_full_image(multi_index))

    button.bind('<Shift-Double-Button-1>', lambda event, index=index: show_image([index]))
    button.bind('<Shift-Return>', lambda event: show_image(multi_index))
    button.bind('<Shift-space>', lambda event: show_image(multi_index))

    button.bind("<Button-3>", lambda event, index=index: menu_popup(event, index))
    button.bind("<Button-2>", lambda event, index=index: menu_popup(event, index))

    button.bind('<Control-s>', lambda event: save_image(event, multi_index))
    button.bind('<Control-S>', lambda event: save_image(event, multi_index))
    button.bind('<Shift-Control-s>', lambda event: save_image(event, multi_index, single=True))
    button.bind('<Shift-Control-S>', lambda event: save_image(event, multi_index, single=True))

    button.bind('<Control-f>', lambda event: explore_folder(multi_index, select=True))
    button.bind('<Control-F>', lambda event: explore_folder(multi_index, select=True))

    button.bind('<Control-c>', lambda event=2: copy_to_clipboard(event, current_index))
    button.bind('<Control-C>', lambda event=2: copy_to_clipboard(event, current_index))

    button.bind('<Control-i>', lambda event: save_info(multi_index))
    button.bind('<Control-I>', lambda event: save_info(multi_index))
    button.bind('<Shift-Control-i>', lambda event: save_info(multi_index, ask=True))
    button.bind('<Shift-Control-I>', lambda event: save_info(multi_index, ask=True))

    return button


def menu_popup(event, idx):
    '''Open popup menu and make index global'''
    global popup_index

    # button = image_list[idx]['button']
    if idx in multi_index:
        click_grid_image(idx, right=True)
    else:
        click_grid_image(idx)

    # button.focus_set()

    pop_menu.delete(0)
    if len(multi_index) > 1:
        label = f'{len(multi_index)} selected'
    else:
        label = os.path.basename(image_list[idx]['file'])[:20] + '...'

    pop_menu.insert_cascade(0, label=label, foreground=FONT_COLOR, background=BG_COLOR,
                            activebackground=BG_COLOR, activeforeground=ACC_COLOR1, command=lambda: menu_items(7))

    try:
        pop_menu.tk_popup(event.x_root, event.y_root)
    finally:
        pop_menu.grab_release()


def menu_items(item):
    '''Deal with menu choices'''

    if item == 7:
        filename = ''
        for i in multi_index:
            filename += f'{image_list[i]["file"]}\n'
        copy_to_clipboard(None, filename)

    elif item == 0:
        show_full_image(multi_index)

    elif item == 1:
        show_image(multi_index)

    elif item == 2:
        explore_folder(multi_index, select=True)

    elif item == 6:
        save_image(None, multi_index)

    elif item == 8:
        save_image(None, multi_index, single=True)

    elif item == 4:
        save_info(multi_index)

    elif item == 5:
        save_info(multi_index, ask=True)

    elif item == 3:
        embed_txt = ''
        for i in multi_index:
            embed_txt += f'{image_list[i]["txt_info"]}\n'
        copy_to_clipboard(None, embed_txt)


def get_image_paths():
    '''Get images from the path'''

    global folders

    files = []
    folders = []

    if not os.path.isfile(FOLDERS_FILE):
        return None

    paths_user = []
    paths_uniques = []
    paths_upper_all = []
    paths_upper_clean = []
    paths_all = []
    try:
        with open(FOLDERS_FILE, 'r') as file:
            folders = json.load(file)
    except (AttributeError, EOFError, ImportError, IndexError) as e:
        tk.messagebox.showinfo(title='Error loading folders.', message=e, parent=root)
        return None
    finally:

        loading, progress, restart = progress_bar(amount=1, message='Scanning images', start=1)
        loading['text'] = f''
        progress['value'] = 100
        progress.update()

        ext = ['.png', '.jpg']
        for folder in folders:
            path = folder[1]
            recursive = True if folder[0] == '1' else False
            active = True if folder[2] == '1' else False
            if os.path.isdir(path) and active:
                paths_user.append(os.path.normpath(path))
                for e in ext:
                    if recursive:
                        file = glob.glob(os.path.normpath(path + '/**/*' + e), recursive=True)
                    else:
                        file = glob.glob(os.path.normpath(path + '/*' + e), recursive=False)
                    files.extend(file)

        restart.destroy()

    paths_all.extend(paths_user)

    for p in files:
        image_path = os.path.dirname(p)
        if image_path not in paths_uniques:
            paths_uniques.append(image_path)
            paths_upper_all.append(os.path.dirname(image_path))

    paths_all.extend(paths_uniques)

    while paths_upper_all:
        path_upper_clean = paths_upper_all.pop()
        if path_upper_clean in paths_upper_all:
            paths_upper_clean.append(path_upper_clean)
            paths_upper_all = [p for p in paths_upper_all if p != path_upper_clean]

    paths_all.extend(paths_upper_clean)

    if paths_all:
        paths_all = list(set(paths_all))
        paths_all.sort()

    paths_all.insert(0, ALL_FOLDERS)
    lbl_path.config(value=paths_all)
    lbl_path.current(0)

    return files


def load_image_list():
    global image_list
    global image_list_master

    if os.path.isfile(DATA_FILE):
        try:
            with bz2.BZ2File(DATA_FILE, 'rb') as f:
                image_list = pickle.load(f)
        except (pickle.UnpicklingError,
                AttributeError, EOFError, ImportError, IndexError,
                Exception) as e:
            tk.messagebox.showinfo(title='Error loading data file.', message=e, parent=root)
            return False

    else:

        files = get_image_paths()

        if files is None:
            return False
        image_list = generate_image_list(files)
        with bz2.BZ2File(DATA_FILE, 'wb') as f:
            pickle.dump(image_list, f)

    return True


def first_run():
    global sort_reverse
    global is_overlay

    is_overlay = ''

    loading, progress, restart = progress_bar(amount=2, message='Initializing', start=1)

    progress['value'] = 50
    progress.update()

    load_success = load_image_list()

    if load_success:
        create_grid()
        skipped = update_grid()
        if skipped:
            sort_images('', reverse=True)

        loading['text'] = f'2 of 2'
        progress['value'] = 100
        progress.update()

    # # Update buttons frames idle tasks to let tkinter calculate buttons sizes
    # frame_buttons.update_idletasks()

    # Set the canvas scrolling region
    canvas.config(scrollregion=canvas.bbox('all'))

    restart.destroy()


def main():
    '''Create the main window'''

    global vsb
    global canvas
    global img_info
    global text_info
    global lbl_files
    global frame_all
    global frame_buttons
    global entry_search
    global pop_menu
    global lbl_key
    global lbl_help
    global lbl_path
    global image_list
    global image_list_master
    global current_index
    global blank_image

    # Create a blank image
    blank_image = Image.new(color=(0, 0, 0), mode="RGB", size=(0, 0))
    blank_image.putalpha(0)
    blank_image = ImageTk.PhotoImage(blank_image, name='blank_image')

    current_index = 0

    # Must be here to refresh when changing config
    root.option_add('*font', FONT)

    root.bind('<Prior>', lambda event: canvas.yview_scroll(-1, 'pages'))
    root.bind('<Next>', lambda event: canvas.yview_scroll(1, 'pages'))

    root.bind('<Home>', lambda event: canvas.yview_moveto(0))
    root.bind('<End>', lambda event: canvas.yview_moveto(1))

    root.bind('<Control-p>', lambda event: explore_folder({'values': ['', lbl_path.get()]}))
    root.bind('<Control-P>', lambda event: explore_folder({'values': ['', lbl_path.get()]}))

    root.bind('<Control-r>', lambda event: update_grid())
    root.bind('<Control-R>', lambda event: update_grid())

    root.bind('<Control-s>', lambda event: entry_search.focus_set())
    root.bind('<Control-S>', lambda event: entry_search.focus_set())

    root.bind('<Control-m>', lambda event: combo_params.focus_set())
    root.bind('<Control-M>', lambda event: combo_params.focus_set())

    root.bind('<Control-o>', lambda event: sort_images(combo_params.get()))
    root.bind('<Control-O>', lambda event: sort_images(combo_params.get()))
    root.bind('<Shift-Control-o>', lambda event: sort_images(''))
    root.bind('<Shift-Control-O>', lambda event: sort_images(''))

    root.bind('<Control-l>', lambda event=2: overlay_info(combo_params.get()))
    root.bind('<Control-L>', lambda event=2: overlay_info(combo_params.get()))
    root.bind('<Shift-Control-l>', lambda event=2: overlay_info(''))
    root.bind('<Shift-Control-L>', lambda event=2: overlay_info(''))

    style = ttk.Style()
    style.theme_use('default')
    style.configure('TCombobox', relief='flat', background=FONT_COLOR, foreground=BG_COLOR,
                    selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2,
                    arrowcolor=BG_COLOR, darkcolor=ACC_COLOR1, borderwidth=0)
    style.map('TCombobox', fieldbackground=[('disabled', ACC_COLOR1), ('!disabled', ACC_COLOR1)])
    style.map('TCombobox', background=[('disabled', ACC_COLOR1), ('pressed', ACC_COLOR2), ('active', ACC_COLOR1)])
    root.option_add('*TCombobox*Listbox*Background', FONT_COLOR)
    root.option_add('*TCombobox*Listbox*Foreground', BG_COLOR)
    root.option_add('*TCombobox*Listbox*selectBackground', ACC_COLOR1)
    root.option_add('*TCombobox*Listbox*selectForeground', BG_COLOR)

    style.configure('Treeview', borderwidth=0, background=ACC_COLOR1, foreground=BG_COLOR, fieldbackground=ACC_COLOR1)
    style.map('Treeview', background=[('selected', FONT_COLOR)], foreground=[('selected', BG_COLOR)])
    style.configure('Treeview.Heading', background=FONT_COLOR, relief='solid', borderwidth=1, height=BUTT_HEIGHT)
    style.map('Treeview.Heading', background=[('pressed', ACC_COLOR2), ('active', ACC_COLOR1)])

    style.configure("Vertical.TScrollbar", troughcolor=BG_COLOR, background=FONT_COLOR, borderwidth=0,
                    arrowcolor=BG_COLOR, selectbackground=ACC_COLOR1, selectforeground=ACC_COLOR1, relief='flat')
    style.map('Vertical.TScrollbar', background=[('disabled', BG_COLOR), ('active', ACC_COLOR1)])
    style.map('Vertical.TScrollbar', arrowcolor=[('disabled', BG_COLOR), ('active', BG_COLOR)])

    # Frame to hold the entire interface
    frame_all = tk.Frame(root, bg=BG_COLOR)
    frame_all.pack(fill=None, expand=False)

    # Top frame for labels and buttons
    frame_top = tk.Frame(frame_all, bg=BG_COLOR, height=BUTT_HEIGHT)
    frame_top.grid(row=0, column=0, sticky='news')
    frame_top.grid_propagate(False)

    frame_top.grid_rowconfigure(0, weight=1)
    frame_top.grid_columnconfigure(0, weight=1)
    frame_top.grid_columnconfigure(1, weight=0)

    # Top left sub frame for labels
    frame_top_l = tk.Frame(frame_top, bg=BG_COLOR)
    frame_top_l.grid(row=0, column=0, sticky='ewns')

    # frame_top_l.grid_rowconfigure(0, weight=1)
    frame_top_l.grid_columnconfigure(0, weight=0)
    frame_top_l.grid_columnconfigure(1, weight=1)

    # Top right sub frame for buttons
    frame_top_r = tk.Frame(frame_top, width=INFO_IMG_SZ, bg=BG_COLOR)
    frame_top_r.grid(row=0, column=1, sticky='ewns')
    frame_top_r.grid_propagate(False)

    # frame_top_r.grid_rowconfigure(0, weight=1)
    frame_top_r.grid_columnconfigure(0, weight=1)
    frame_top_r.grid_columnconfigure(1, weight=1)
    # frame_top_r.grid_columnconfigure(2, weight=2)
    # frame_top_r.grid_columnconfigure(3, weight=2)

    # Number of files label, top left frame
    lbl_files = tk.Label(frame_top_l, bg=BG_COLOR, fg=ACC_COLOR1, text=f'images')
    lbl_files.grid(row=0, column=0, sticky='w', padx=(10, 10))

    # Current path label, top left frame
    brd_lbl_path = tk.Frame(frame_top_l, bg=BG_COLOR)
    brd_lbl_path.grid(row=0, column=1, sticky='nsew')
    lbl_path = ttk.Combobox(brd_lbl_path, name='folders_combo', state='readonly')
    lbl_path.bind("<<ComboboxSelected>>", lambda event: search_paths())
    lbl_path.pack(expand=True, fill='both', pady=1, padx=1)

    # Refresh button, top right frame
    brd_bt_refr = tk.Frame(frame_top_l, bg=BG_COLOR)
    brd_bt_refr.grid(row=0, column=2, sticky='snwe')
    butt_refr = tk.Button(brd_bt_refr, text='refresh', bd=0, command=update_grid,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_refr.pack(expand=True, fill='both', pady=1, padx=1)

    # Open path button, top right frame
    brd_bt_open = tk.Frame(frame_top_l, bg=BG_COLOR)
    brd_bt_open.grid(row=0, column=3, sticky='snwe')
    butt_open = tk.Button(brd_bt_open, text='open path', bd=0, command=lambda: explore_folder({'values': ['', lbl_path.get()]}),
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_open.pack(expand=True, fill='both', pady=1, padx=1)

    # Path button, top right frame
    brd_bt_path = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_path.grid(row=0, column=0, sticky='snwe')
    butt_path = tk.Button(brd_bt_path, text='paths', bd=0, command=folders_requester,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_path.pack(expand=True, fill='both', pady=1, padx=1)

    # Config button, top right frame
    brd_bt_conf = tk.Frame(frame_top_r, bg=BG_COLOR)
    brd_bt_conf.grid(row=0, column=1, sticky='snwe')
    butt_conf = tk.Button(brd_bt_conf, text='config', bd=0, command=config_requester,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_conf.pack(expand=True, fill='both', pady=1, padx=1)

    # Frame for the grid and info
    frame_main = tk.Frame(frame_all, bg=BG_COLOR)
    frame_main.grid(sticky='news')
    frame_main.grid(row=1, column=0, sticky='nw')

    # Frame for the info
    frame_info_height = GRID_IMG_SZ * ROW_NBR + (BORDER * 2 * ROW_NBR)
    info_frame = tk.Frame(frame_main, bg=BG_COLOR, width=INFO_IMG_SZ, height=frame_info_height)
    info_frame.grid(row=0, column=1, sticky='nw')

    # Button to show the selected image
    img_info = tk.Button(info_frame, bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1,
                         font=(FONT[0], FONT[1] * 3, 'bold'), borderwidth=0, text=PROGRAM_NAME)
    img_info.bind('<Button-1>', lambda event: show_full_image([current_index]))
    img_info.bind('<Button-2>', lambda event: show_image([current_index]))
    img_info.bind('<Button-3>', lambda event: show_image([current_index]))
    img_info.bind('<Shift-Button-1>', lambda event: show_image([current_index]))
    img_info.place(x=1, y=1, height=INFO_IMG_SZ - 2, width=INFO_IMG_SZ - 2)

    # Text box to show the selected image info
    text_info_height = GRID_IMG_SZ * ROW_NBR - INFO_IMG_SZ + (BORDER * 2 * ROW_NBR)
    text_info = tk.Text(info_frame, name='text_info',
                        bg=BG_COLOR, fg=FONT_COLOR,
                        selectbackground=FONT_COLOR, selectforeground=BG_COLOR,
                        borderwidth=0, padx=10, pady=10)
    text_info.bind('<ButtonRelease-1>', lambda event: copy_to_clipboard(event))
    text_info.bind('<ButtonRelease-2>', lambda event: copy_to_clipboard(event))
    text_info.bind('<ButtonRelease-3>', lambda event: copy_to_clipboard(event))
    text_info.insert('insert', TEXT_INFO_DEFAULT)
    text_info.place(x=0, y=INFO_IMG_SZ, height=text_info_height, width=INFO_IMG_SZ - 15)
    text_info['state'] = 'disable'

    # Text box info scrollbar
    sb_txt_info = ttk.Scrollbar(info_frame, orient='vertical')
    sb_txt_info.place(x=INFO_IMG_SZ - 15, y=INFO_IMG_SZ, height=text_info_height)
    text_info.configure(yscrollcommand=sb_txt_info.set)
    sb_txt_info.config(command=text_info.yview)

    # Frame for the image grid
    frame_canvas = tk.Frame(frame_main, bg=BG_COLOR)
    frame_canvas.grid(row=0, column=0, sticky='nw', pady=(1, 0))
    frame_canvas.grid_rowconfigure(0, weight=1)
    frame_canvas.grid_columnconfigure(0, weight=1)
    frame_canvas.grid_propagate(False)

    # Add a canvas in that frame
    canvas = tk.Canvas(frame_canvas, bg=BG_COLOR, borderwidth=0, highlightthickness=0)
    canvas.bind_all('<MouseWheel>', on_mousewheel)
    canvas.bind_all("<Button-4>", on_mousewheel)
    canvas.bind_all("<Button-5>", on_mousewheel)

    canvas.grid(row=0, column=0, sticky='news')

    # Create a frame to contain the buttons
    frame_buttons = tk.Frame(canvas, bg=BG_COLOR, name='buttons_frame')
    canvas.create_window((0, 0), window=frame_buttons, anchor='nw')

    # Link a scrollbar to the canvas
    vsb = ttk.Scrollbar(frame_canvas, orient='vertical', command=canvas.yview)
    vsb.grid(row=0, column=1, sticky='ns', padx=(0, 1), pady=(0, 0))
    canvas.configure(yscrollcommand=refresh_images)

    # Resize the canvas and frame
    grid_width = (COL_NBR * GRID_IMG_SZ + (BORDER * 4 * COL_NBR)) + vsb.winfo_width() - 4
    grid_height = ROW_NBR * GRID_IMG_SZ + (BORDER * 2 * ROW_NBR)
    frame_canvas.config(width=grid_width, height=grid_height)

    # Frame for the search and info panel bottom
    bottom_frame = tk.Frame(frame_all, bg=BG_COLOR, height=BUTT_HEIGHT)
    bottom_frame.grid(row=2, column=0, sticky='news')

    # Frame for the search
    search_frame = tk.Frame(bottom_frame, bg=BG_COLOR)
    search_frame.place(x=0, height=BUTT_HEIGHT, width=grid_width)

    # Button to expose
    brd_bt_expose = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_expose.grid(row=0, column=0, sticky='news')
    butt_expose = tk.Button(brd_bt_expose, text='expose', bd=0,
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_expose.bind('<Return>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<space>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<Button-1>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    butt_expose.bind('<Control-Return>', lambda event: expose_images(entry_search.get(), combo_params.get(), invert=True))
    butt_expose.bind('<Control-space>', lambda event: expose_images(entry_search.get(), combo_params.get(), invert=True))
    butt_expose.bind('<Control-Button-1>', lambda event: expose_images(entry_search.get(), combo_params.get(), invert=True))
    butt_expose.bind('<Button-2>', lambda event: expose_images('', ''))
    butt_expose.bind('<Button-3>', lambda event: expose_images('', ''))
    butt_expose.bind('<Shift-Button-1>', lambda event: expose_images('', ''))
    butt_expose.bind('<Shift-Return>', lambda event: expose_images('', ''))
    butt_expose.bind('<Shift-space>', lambda event: expose_images('', ''))
    butt_expose.bind('<Alt-Return>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True))
    butt_expose.bind('<Alt-space>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True))
    butt_expose.bind('<Alt-Button-1>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True))
    butt_expose.bind('<Control-Alt-Return>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_expose.bind('<Control-Alt-space>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_expose.bind('<Control-Alt-Button-1>', lambda event: expose_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_expose.pack(expand=True, fill='both', pady=1, padx=1)

    # Button to search
    brd_bt_search = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_search.grid(row=0, column=1, sticky='news')
    butt_search = tk.Button(brd_bt_search, text='search', bd=0,
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_search.bind('<Return>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<space>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<Button-1>', lambda event: search_images(entry_search.get(), combo_params.get()))
    butt_search.bind('<Control-Return>', lambda event: search_images(entry_search.get(), combo_params.get(), invert=True))
    butt_search.bind('<Control-space>', lambda event: search_images(entry_search.get(), combo_params.get(), invert=True))
    butt_search.bind('<Control-Button-1>', lambda event: search_images(entry_search.get(), combo_params.get(), invert=True))
    butt_search.bind('<Button-2>', lambda event: search_images('', ''))
    butt_search.bind('<Button-3>', lambda event: search_images('', ''))
    butt_search.bind('<Shift-Button-1>', lambda event: search_images('', ''))
    butt_search.bind('<Shift-Return>', lambda event: search_images('', ''))
    butt_search.bind('<Shift-space>', lambda event: search_images('', ''))
    butt_search.bind('<Alt-Return>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True))
    butt_search.bind('<Alt-space>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True))
    butt_search.bind('<Alt-Button-1>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True))
    butt_search.bind('<Control-Alt-Return>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_search.bind('<Control-Alt-space>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_search.bind('<Control-Alt-Button-1>', lambda event: search_images(entry_search.get(), combo_params.get(), exact=True, invert=True))
    butt_search.pack(expand=True, fill='both', pady=1, padx=1)

    # Search entry box
    brd_ent_search = tk.Frame(search_frame, bg=BG_COLOR)
    brd_ent_search.grid(row=0, column=2, sticky='nwes')
    entry_search = tk.Entry(brd_ent_search, bg=ACC_COLOR1, fg=FONT_COLOR, bd=0, name='entry_search',
                            selectbackground=FONT_COLOR, selectforeground=ACC_COLOR2)
    entry_search.insert('insert', SEARCH_HELP)
    entry_search.bind('<FocusIn>', lambda event: enter_search(entry_search.get()))
    entry_search.bind('<Return>', lambda event: search_images(entry_search.get(), combo_params.get()))
    entry_search.bind('<Shift-Return>', lambda event: expose_images(entry_search.get(), combo_params.get()))
    entry_search.bind('<Control-Return>', lambda event: search_images('', ''))
    entry_search.bind('<Control-Shift-Return>', lambda event: expose_images('', ''))
    entry_search.pack(expand=True, fill='both', pady=1, padx=1)

    # Search parameters
    brd_cb_param = tk.Frame(search_frame, bg=BG_COLOR)
    brd_cb_param.grid(row=0, column=3, sticky='snew')
    combo_params = ttk.Combobox(brd_cb_param, values=TEXT_PARS, name='combo_box', width=10)
    combo_params.current(0)
    combo_params.pack(expand=True, fill='both', pady=1, padx=1)
    combo_params.bind("<<ComboboxSelected>>", lambda event: combo_params.selection_clear())

    # Button to sort
    brd_bt_sort = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_sort.grid(row=0, column=4, sticky='news')
    butt_sort = tk.Button(brd_bt_sort, text='sort', bd=0,
                          bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_sort.bind('<Return>', lambda event: sort_images(combo_params.get()))
    butt_sort.bind('<space>', lambda event: sort_images(combo_params.get()))
    butt_sort.bind('<Button-1>', lambda event: sort_images(combo_params.get()))
    butt_sort.bind('<Button-2>', lambda event: sort_images(''))
    butt_sort.bind('<Button-3>', lambda event: sort_images(''))
    butt_sort.bind('<Shift-Return>', lambda event: sort_images(''))
    butt_sort.bind('<Shift-space>', lambda event: sort_images(''))
    butt_sort.bind('<Shift-Button-1>', lambda event: sort_images(''))
    butt_sort.pack(expand=True, fill='both', pady=1, padx=1)

    # Button to show overlay
    brd_bt_overlay = tk.Frame(search_frame, bg=BG_COLOR)
    brd_bt_overlay.grid(row=0, column=5, sticky='news')
    butt_overlay = tk.Button(brd_bt_overlay, text='overlay', bd=0,
                             bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_overlay.bind('<Return>', lambda event: overlay_info(combo_params.get()))
    butt_overlay.bind('<space>', lambda event: overlay_info(combo_params.get()))
    butt_overlay.bind('<Button-1>', lambda event: overlay_info(combo_params.get()))
    butt_overlay.bind('<Button-2>', lambda event: overlay_info(''))
    butt_overlay.bind('<Button-3>', lambda event: overlay_info(''))
    butt_overlay.bind('<Shift-Return>', lambda event: overlay_info(''))
    butt_overlay.bind('<Shift-space>', lambda event: overlay_info(''))
    butt_overlay.bind('<Shift-Button-1>', lambda event: overlay_info(''))
    butt_overlay.pack(expand=True, fill='both', pady=1, padx=1)

    search_frame.grid_rowconfigure(0, weight=1)
    search_frame.grid_columnconfigure(0, weight=0)
    search_frame.grid_columnconfigure(1, weight=0)
    search_frame.grid_columnconfigure(2, weight=2)
    search_frame.grid_columnconfigure(3, weight=1)
    search_frame.grid_columnconfigure(4, weight=0)
    search_frame.grid_columnconfigure(5, weight=0)

    # Frame for the info panel bottom
    info_panel_x = grid_width
    info_panel_frame = tk.Frame(bottom_frame, bg=BG_COLOR)
    info_panel_frame.place(x=info_panel_x, height=BUTT_HEIGHT, width=INFO_IMG_SZ)

    # Button to open folder containing image
    brd_bt_folder = tk.Frame(info_panel_frame, bg=BG_COLOR)
    brd_bt_folder.grid(row=0, column=0, sticky='news')
    butt_folder = tk.Button(brd_bt_folder, text='show in folder', bd=0,
                            command=lambda: explore_folder([current_index], select=True),
                            bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_folder.pack(expand=True, fill='both', pady=1, padx=1)

    # Button to save information
    brd_bt_save_info = tk.Frame(info_panel_frame, bg=BG_COLOR)
    brd_bt_save_info.grid(row=0, column=1, sticky='news')
    butt_save_info = tk.Button(brd_bt_save_info, text='save info', bd=0,
                               bg=FONT_COLOR, fg=BG_COLOR, activebackground=ACC_COLOR1)
    butt_save_info.pack(expand=True, fill='both', pady=1, padx=1)
    butt_save_info.bind('<Return>', lambda event: save_info(multi_index))
    butt_save_info.bind('<space>', lambda event: save_info(multi_index))
    butt_save_info.bind('<Button-1>', lambda event: save_info(multi_index))
    butt_save_info.bind('<Button-2>', lambda event: save_info(multi_index, ask=True))
    butt_save_info.bind('<Button-3>', lambda event: save_info(multi_index, ask=True))
    butt_save_info.bind('<Shift-Return>', lambda event: save_info(multi_index, ask=True))
    butt_save_info.bind('<Shift-space>', lambda event: save_info(multi_index, ask=True))
    butt_save_info.bind('<Shift-Button-1>', lambda event: save_info(multi_index, ask=True))

    info_panel_frame.grid_rowconfigure(0, weight=1)
    info_panel_frame.grid_columnconfigure(0, weight=1)
    info_panel_frame.grid_columnconfigure(1, weight=1)

    # Popup menu
    pop_menu = tk.Menu(root, tearoff=0, relief='flat', bg=FONT_COLOR,
                       activebackground=ACC_COLOR1, activeforeground=BG_COLOR, disabledforeground=ACC_COLOR2,
                       disabled=ACC_COLOR2, borderwidth=0, activeborderwidth=0)
    pop_menu.add_separator()
    pop_menu.add_separator()
    pop_menu.add_command(label='open image(s) internal', foreground=BG_COLOR, command=lambda: menu_items(0))
    pop_menu.add_command(label='open image(s) in system', foreground=BG_COLOR, command=lambda: menu_items(1))
    pop_menu.add_separator()
    pop_menu.add_command(label='show image(s) in folder', foreground=BG_COLOR, command=lambda: menu_items(2))
    pop_menu.add_separator()
    pop_menu.add_command(label='copy image(s) to folders', foreground=BG_COLOR, command=lambda: menu_items(6))
    pop_menu.add_command(label='copy image batch to folder', foreground=BG_COLOR, command=lambda: menu_items(8))
    pop_menu.add_separator()
    pop_menu.add_command(label='save info', foreground=BG_COLOR, command=lambda: menu_items(4))
    pop_menu.add_command(label='save info as', foreground=BG_COLOR, command=lambda: menu_items(5))
    pop_menu.add_separator()
    pop_menu.add_command(label='copy info to clipboard', foreground=BG_COLOR, command=lambda: menu_items(3))

    # Adjustments for MacOS
    # lbl_path.config(highlightbackground=BG_COLOR)
    butt_path.config(highlightbackground=BG_COLOR)
    butt_refr.config(highlightbackground=BG_COLOR)
    butt_open.config(highlightbackground=BG_COLOR)
    butt_conf.config(highlightbackground=BG_COLOR)
    butt_folder.config(highlightbackground=BG_COLOR)
    butt_save_info.config(highlightbackground=BG_COLOR)
    butt_search.config(highlightbackground=BG_COLOR)
    butt_expose.config(highlightbackground=BG_COLOR)
    text_info.config(highlightbackground=BG_COLOR)
    entry_search.config(highlightbackground=BG_COLOR)

    # Launch the GUI
    ico = Image.open(os.path.join(LOCAL_PATH, 'Images', 'Logo.png'))
    ico = ImageTk.PhotoImage(ico)
    root.wm_iconphoto(False, ico)

    root.after(50, lambda: first_run())
    root.mainloop()


if __name__ == '__main__':
    main()
